{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable2Step.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Ownable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\n        _transferOwnership(sender);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n *\n * _Available since v4.1._\n */\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash      Hash of the data to be signed\n     * @param signature Signature byte array associated with _data\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    ) public view virtual override returns (uint256[] memory) {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner or approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner or approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(address to, uint256 id, uint256 amount, bytes memory data) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(address from, uint256 id, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(address from, uint256[] memory ids, uint256[] memory amounts) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\n     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such\n     * that `ownerOf(tokenId)` is `a`.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC777/ERC777.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC777/ERC777.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC777.sol\";\nimport \"./IERC777Recipient.sol\";\nimport \"./IERC777Sender.sol\";\nimport \"../ERC20/IERC20.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/IERC1820Registry.sol\";\n\n/**\n * @dev Implementation of the {IERC777} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * Support for ERC20 is included in this contract, as specified by the EIP: both\n * the ERC777 and ERC20 interfaces can be safely used when interacting with it.\n * Both {IERC777-Sent} and {IERC20-Transfer} events are emitted on token\n * movements.\n *\n * Additionally, the {IERC777-granularity} value is hard-coded to `1`, meaning that there\n * are no special restrictions in the amount of tokens that created, moved, or\n * destroyed. This makes integration with ERC20 applications seamless.\n *\n * CAUTION: This file is deprecated as of v4.9 and will be removed in the next major release.\n */\ncontract ERC777 is Context, IERC777, IERC20 {\n    using Address for address;\n\n    IERC1820Registry internal constant _ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n\n    mapping(address => uint256) private _balances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    bytes32 private constant _TOKENS_SENDER_INTERFACE_HASH = keccak256(\"ERC777TokensSender\");\n    bytes32 private constant _TOKENS_RECIPIENT_INTERFACE_HASH = keccak256(\"ERC777TokensRecipient\");\n\n    // This isn't ever read from - it's only used to respond to the defaultOperators query.\n    address[] private _defaultOperatorsArray;\n\n    // Immutable, but accounts may revoke them (tracked in __revokedDefaultOperators).\n    mapping(address => bool) private _defaultOperators;\n\n    // For each account, a mapping of its operators and revoked default operators.\n    mapping(address => mapping(address => bool)) private _operators;\n    mapping(address => mapping(address => bool)) private _revokedDefaultOperators;\n\n    // ERC20-allowances\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    /**\n     * @dev `defaultOperators` may be an empty array.\n     */\n    constructor(string memory name_, string memory symbol_, address[] memory defaultOperators_) {\n        _name = name_;\n        _symbol = symbol_;\n\n        _defaultOperatorsArray = defaultOperators_;\n        for (uint256 i = 0; i < defaultOperators_.length; i++) {\n            _defaultOperators[defaultOperators_[i]] = true;\n        }\n\n        // register interfaces\n        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256(\"ERC777Token\"), address(this));\n        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256(\"ERC20Token\"), address(this));\n    }\n\n    /**\n     * @dev See {IERC777-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC777-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {ERC20-decimals}.\n     *\n     * Always returns 18, as per the\n     * [ERC777 EIP](https://eips.ethereum.org/EIPS/eip-777#backward-compatibility).\n     */\n    function decimals() public pure virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC777-granularity}.\n     *\n     * This implementation always returns `1`.\n     */\n    function granularity() public view virtual override returns (uint256) {\n        return 1;\n    }\n\n    /**\n     * @dev See {IERC777-totalSupply}.\n     */\n    function totalSupply() public view virtual override(IERC20, IERC777) returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev Returns the amount of tokens owned by an account (`tokenHolder`).\n     */\n    function balanceOf(address tokenHolder) public view virtual override(IERC20, IERC777) returns (uint256) {\n        return _balances[tokenHolder];\n    }\n\n    /**\n     * @dev See {IERC777-send}.\n     *\n     * Also emits a {IERC20-Transfer} event for ERC20 compatibility.\n     */\n    function send(address recipient, uint256 amount, bytes memory data) public virtual override {\n        _send(_msgSender(), recipient, amount, data, \"\", true);\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Unlike `send`, `recipient` is _not_ required to implement the {IERC777Recipient}\n     * interface if it is a contract.\n     *\n     * Also emits a {Sent} event.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _send(_msgSender(), recipient, amount, \"\", \"\", false);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC777-burn}.\n     *\n     * Also emits a {IERC20-Transfer} event for ERC20 compatibility.\n     */\n    function burn(uint256 amount, bytes memory data) public virtual override {\n        _burn(_msgSender(), amount, data, \"\");\n    }\n\n    /**\n     * @dev See {IERC777-isOperatorFor}.\n     */\n    function isOperatorFor(address operator, address tokenHolder) public view virtual override returns (bool) {\n        return\n            operator == tokenHolder ||\n            (_defaultOperators[operator] && !_revokedDefaultOperators[tokenHolder][operator]) ||\n            _operators[tokenHolder][operator];\n    }\n\n    /**\n     * @dev See {IERC777-authorizeOperator}.\n     */\n    function authorizeOperator(address operator) public virtual override {\n        require(_msgSender() != operator, \"ERC777: authorizing self as operator\");\n\n        if (_defaultOperators[operator]) {\n            delete _revokedDefaultOperators[_msgSender()][operator];\n        } else {\n            _operators[_msgSender()][operator] = true;\n        }\n\n        emit AuthorizedOperator(operator, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC777-revokeOperator}.\n     */\n    function revokeOperator(address operator) public virtual override {\n        require(operator != _msgSender(), \"ERC777: revoking self as operator\");\n\n        if (_defaultOperators[operator]) {\n            _revokedDefaultOperators[_msgSender()][operator] = true;\n        } else {\n            delete _operators[_msgSender()][operator];\n        }\n\n        emit RevokedOperator(operator, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC777-defaultOperators}.\n     */\n    function defaultOperators() public view virtual override returns (address[] memory) {\n        return _defaultOperatorsArray;\n    }\n\n    /**\n     * @dev See {IERC777-operatorSend}.\n     *\n     * Emits {Sent} and {IERC20-Transfer} events.\n     */\n    function operatorSend(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes memory data,\n        bytes memory operatorData\n    ) public virtual override {\n        require(isOperatorFor(_msgSender(), sender), \"ERC777: caller is not an operator for holder\");\n        _send(sender, recipient, amount, data, operatorData, true);\n    }\n\n    /**\n     * @dev See {IERC777-operatorBurn}.\n     *\n     * Emits {Burned} and {IERC20-Transfer} events.\n     */\n    function operatorBurn(\n        address account,\n        uint256 amount,\n        bytes memory data,\n        bytes memory operatorData\n    ) public virtual override {\n        require(isOperatorFor(_msgSender(), account), \"ERC777: caller is not an operator for holder\");\n        _burn(account, amount, data, operatorData);\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     *\n     * Note that operator and allowance concepts are orthogonal: operators may\n     * not have allowance, and accounts with allowance may not be operators\n     * themselves.\n     */\n    function allowance(address holder, address spender) public view virtual override returns (uint256) {\n        return _allowances[holder][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Note that accounts cannot have allowance issued by their operators.\n     */\n    function approve(address spender, uint256 value) public virtual override returns (bool) {\n        address holder = _msgSender();\n        _approve(holder, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Note that operator and allowance concepts are orthogonal: operators cannot\n     * call `transferFrom` (unless they have allowance), and accounts with\n     * allowance cannot call `operatorSend` (unless they are operators).\n     *\n     * Emits {Sent}, {IERC20-Transfer} and {IERC20-Approval} events.\n     */\n    function transferFrom(address holder, address recipient, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(holder, spender, amount);\n        _send(holder, recipient, amount, \"\", \"\", false);\n        return true;\n    }\n\n    /**\n     * @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * If a send hook is registered for `account`, the corresponding function\n     * will be called with the caller address as the `operator` and with\n     * `userData` and `operatorData`.\n     *\n     * See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits {Minted} and {IERC20-Transfer} events.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - if `account` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function _mint(address account, uint256 amount, bytes memory userData, bytes memory operatorData) internal virtual {\n        _mint(account, amount, userData, operatorData, true);\n    }\n\n    /**\n     * @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * If `requireReceptionAck` is set to true, and if a send hook is\n     * registered for `account`, the corresponding function will be called with\n     * `operator`, `data` and `operatorData`.\n     *\n     * See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits {Minted} and {IERC20-Transfer} events.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - if `account` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function _mint(\n        address account,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData,\n        bool requireReceptionAck\n    ) internal virtual {\n        require(account != address(0), \"ERC777: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), account, amount);\n\n        // Update state variables\n        _totalSupply += amount;\n        _balances[account] += amount;\n\n        _callTokensReceived(operator, address(0), account, amount, userData, operatorData, requireReceptionAck);\n\n        emit Minted(operator, account, amount, userData, operatorData);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Send tokens\n     * @param from address token holder address\n     * @param to address recipient address\n     * @param amount uint256 amount of tokens to transfer\n     * @param userData bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient\n     */\n    function _send(\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData,\n        bool requireReceptionAck\n    ) internal virtual {\n        require(from != address(0), \"ERC777: transfer from the zero address\");\n        require(to != address(0), \"ERC777: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _callTokensToSend(operator, from, to, amount, userData, operatorData);\n\n        _move(operator, from, to, amount, userData, operatorData);\n\n        _callTokensReceived(operator, from, to, amount, userData, operatorData, requireReceptionAck);\n    }\n\n    /**\n     * @dev Burn tokens\n     * @param from address token holder address\n     * @param amount uint256 amount of tokens to burn\n     * @param data bytes extra information provided by the token holder\n     * @param operatorData bytes extra information provided by the operator (if any)\n     */\n    function _burn(address from, uint256 amount, bytes memory data, bytes memory operatorData) internal virtual {\n        require(from != address(0), \"ERC777: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _callTokensToSend(operator, from, address(0), amount, data, operatorData);\n\n        _beforeTokenTransfer(operator, from, address(0), amount);\n\n        // Update state variables\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC777: burn amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Burned(operator, from, amount, data, operatorData);\n        emit Transfer(from, address(0), amount);\n    }\n\n    function _move(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    ) private {\n        _beforeTokenTransfer(operator, from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC777: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Sent(operator, from, to, amount, userData, operatorData);\n        emit Transfer(from, to, amount);\n    }\n\n    /**\n     * @dev See {ERC20-_approve}.\n     *\n     * Note that accounts cannot have allowance issued by their operators.\n     */\n    function _approve(address holder, address spender, uint256 value) internal virtual {\n        require(holder != address(0), \"ERC777: approve from the zero address\");\n        require(spender != address(0), \"ERC777: approve to the zero address\");\n\n        _allowances[holder][spender] = value;\n        emit Approval(holder, spender, value);\n    }\n\n    /**\n     * @dev Call from.tokensToSend() if the interface is registered\n     * @param operator address operator requesting the transfer\n     * @param from address token holder address\n     * @param to address recipient address\n     * @param amount uint256 amount of tokens to transfer\n     * @param userData bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     */\n    function _callTokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    ) private {\n        address implementer = _ERC1820_REGISTRY.getInterfaceImplementer(from, _TOKENS_SENDER_INTERFACE_HASH);\n        if (implementer != address(0)) {\n            IERC777Sender(implementer).tokensToSend(operator, from, to, amount, userData, operatorData);\n        }\n    }\n\n    /**\n     * @dev Call to.tokensReceived() if the interface is registered. Reverts if the recipient is a contract but\n     * tokensReceived() was not registered for the recipient\n     * @param operator address operator requesting the transfer\n     * @param from address token holder address\n     * @param to address recipient address\n     * @param amount uint256 amount of tokens to transfer\n     * @param userData bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient\n     */\n    function _callTokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData,\n        bool requireReceptionAck\n    ) private {\n        address implementer = _ERC1820_REGISTRY.getInterfaceImplementer(to, _TOKENS_RECIPIENT_INTERFACE_HASH);\n        if (implementer != address(0)) {\n            IERC777Recipient(implementer).tokensReceived(operator, from, to, amount, userData, operatorData);\n        } else if (requireReceptionAck) {\n            require(!to.isContract(), \"ERC777: token recipient contract has no implementer for ERC777TokensRecipient\");\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {IERC20-Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC777: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes\n     * calls to {send}, {transfer}, {operatorSend}, {transferFrom}, minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address operator, address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC777/IERC777.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC777/IERC777.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC777Token standard as defined in the EIP.\n *\n * This contract uses the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 registry standard] to let\n * token holders and recipients react to token movements by using setting implementers\n * for the associated interfaces in said registry. See {IERC1820Registry} and\n * {ERC1820Implementer}.\n */\ninterface IERC777 {\n    /**\n     * @dev Emitted when `amount` tokens are created by `operator` and assigned to `to`.\n     *\n     * Note that some additional user `data` and `operatorData` can be logged in the event.\n     */\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\n\n    /**\n     * @dev Emitted when `operator` destroys `amount` tokens from `account`.\n     *\n     * Note that some additional user `data` and `operatorData` can be logged in the event.\n     */\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\n\n    /**\n     * @dev Emitted when `operator` is made operator for `tokenHolder`.\n     */\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\n\n    /**\n     * @dev Emitted when `operator` is revoked its operator status for `tokenHolder`.\n     */\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the smallest part of the token that is not divisible. This\n     * means all token operations (creation, movement and destruction) must have\n     * amounts that are a multiple of this number.\n     *\n     * For most token contracts, this value will equal 1.\n     */\n    function granularity() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by an account (`owner`).\n     */\n    function balanceOf(address owner) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * If send or receive hooks are registered for the caller and `recipient`,\n     * the corresponding functions will be called with `data` and empty\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits a {Sent} event.\n     *\n     * Requirements\n     *\n     * - the caller must have at least `amount` tokens.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function send(address recipient, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\n     * total supply.\n     *\n     * If a send hook is registered for the caller, the corresponding function\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\n     *\n     * Emits a {Burned} event.\n     *\n     * Requirements\n     *\n     * - the caller must have at least `amount` tokens.\n     */\n    function burn(uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev Returns true if an account is an operator of `tokenHolder`.\n     * Operators can send and burn tokens on behalf of their owners. All\n     * accounts are their own operator.\n     *\n     * See {operatorSend} and {operatorBurn}.\n     */\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\n\n    /**\n     * @dev Make an account an operator of the caller.\n     *\n     * See {isOperatorFor}.\n     *\n     * Emits an {AuthorizedOperator} event.\n     *\n     * Requirements\n     *\n     * - `operator` cannot be calling address.\n     */\n    function authorizeOperator(address operator) external;\n\n    /**\n     * @dev Revoke an account's operator status for the caller.\n     *\n     * See {isOperatorFor} and {defaultOperators}.\n     *\n     * Emits a {RevokedOperator} event.\n     *\n     * Requirements\n     *\n     * - `operator` cannot be calling address.\n     */\n    function revokeOperator(address operator) external;\n\n    /**\n     * @dev Returns the list of default operators. These accounts are operators\n     * for all token holders, even if {authorizeOperator} was never called on\n     * them.\n     *\n     * This list is immutable, but individual holders may revoke these via\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\n     */\n    function defaultOperators() external view returns (address[] memory);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\n     * be an operator of `sender`.\n     *\n     * If send or receive hooks are registered for `sender` and `recipient`,\n     * the corresponding functions will be called with `data` and\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits a {Sent} event.\n     *\n     * Requirements\n     *\n     * - `sender` cannot be the zero address.\n     * - `sender` must have at least `amount` tokens.\n     * - the caller must be an operator for `sender`.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function operatorSend(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\n     * The caller must be an operator of `account`.\n     *\n     * If a send hook is registered for `account`, the corresponding function\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\n     *\n     * Emits a {Burned} event.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     * - the caller must be an operator for `account`.\n     */\n    function operatorBurn(address account, uint256 amount, bytes calldata data, bytes calldata operatorData) external;\n\n    event Sent(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes data,\n        bytes operatorData\n    );\n}\n"
    },
    "@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC777/IERC777Recipient.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.\n *\n * Accounts can be notified of {IERC777} tokens being sent to them by having a\n * contract implement this interface (contract holders can be their own\n * implementer) and registering it on the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\n *\n * See {IERC1820Registry} and {ERC1820Implementer}.\n */\ninterface IERC777Recipient {\n    /**\n     * @dev Called by an {IERC777} token contract whenever tokens are being\n     * moved or created into a registered account (`to`). The type of operation\n     * is conveyed by `from` being the zero address or not.\n     *\n     * This call occurs _after_ the token contract's state is updated, so\n     * {IERC777-balanceOf}, etc., can be used to query the post-operation state.\n     *\n     * This function may revert to prevent the operation from being executed.\n     */\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC777/IERC777Sender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC777/IERC777Sender.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC777TokensSender standard as defined in the EIP.\n *\n * {IERC777} Token holders can be notified of operations performed on their\n * tokens by having a contract implement this interface (contract holders can be\n * their own implementer) and registering it on the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\n *\n * See {IERC1820Registry} and {ERC1820Implementer}.\n */\ninterface IERC777Sender {\n    /**\n     * @dev Called by an {IERC777} token contract whenever a registered holder's\n     * (`from`) tokens are about to be moved or destroyed. The type of operation\n     * is conveyed by `to` being the zero address or not.\n     *\n     * This call occurs _before_ the token contract's state is updated, so\n     * {IERC777-balanceOf}, etc., can be used to query the pre-operation state.\n     *\n     * This function may revert to prevent the operation from being executed.\n     */\n    function tokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/SignatureChecker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\nimport \"../../interfaces/IERC1271.sol\";\n\n/**\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\n * Argent and Gnosis Safe.\n *\n * _Available since v4.1._\n */\nlibrary SignatureChecker {\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {\n        (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(hash, signature);\n        return\n            (error == ECDSA.RecoverError.NoError && recovered == signer) ||\n            isValidERC1271SignatureNow(signer, hash, signature);\n    }\n\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. The signature is validated\n     * against the signer smart contract using ERC1271.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidERC1271SignatureNow(\n        address signer,\n        bytes32 hash,\n        bytes memory signature\n    ) internal view returns (bool) {\n        (bool success, bytes memory result) = signer.staticcall(\n            abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)\n        );\n        return (success &&\n            result.length >= 32 &&\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC1820Registry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/introspection/IERC1820Registry.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the global ERC1820 Registry, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\n * implementers for interfaces in this registry, as well as query support.\n *\n * Implementers may be shared by multiple accounts, and can also implement more\n * than a single interface for each account. Contracts can implement interfaces\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\n * contract.\n *\n * {IERC165} interfaces can also be queried via the registry.\n *\n * For an in-depth explanation and source code analysis, see the EIP text.\n */\ninterface IERC1820Registry {\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\n\n    event ManagerChanged(address indexed account, address indexed newManager);\n\n    /**\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\n     * account is able to set interface implementers for it.\n     *\n     * By default, each account is its own manager. Passing a value of `0x0` in\n     * `newManager` will reset the manager to this initial state.\n     *\n     * Emits a {ManagerChanged} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     */\n    function setManager(address account, address newManager) external;\n\n    /**\n     * @dev Returns the manager for `account`.\n     *\n     * See {setManager}.\n     */\n    function getManager(address account) external view returns (address);\n\n    /**\n     * @dev Sets the `implementer` contract as ``account``'s implementer for\n     * `interfaceHash`.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     * The zero address can also be used in `implementer` to remove an old one.\n     *\n     * See {interfaceHash} to learn how these are created.\n     *\n     * Emits an {InterfaceImplementerSet} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\n     * end in 28 zeroes).\n     * - `implementer` must implement {IERC1820Implementer} and return true when\n     * queried for support, unless `implementer` is the caller. See\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\n     */\n    function setInterfaceImplementer(address account, bytes32 _interfaceHash, address implementer) external;\n\n    /**\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\n     * implementer is registered, returns the zero address.\n     *\n     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\n     * zeroes), `account` will be queried for support of it.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     */\n    function getInterfaceImplementer(address account, bytes32 _interfaceHash) external view returns (address);\n\n    /**\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\n     * corresponding\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\n     */\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\n\n    /**\n     * @notice Updates the cache with whether the contract implements an ERC165 interface or not.\n     * @param account Address of the contract for which to update the cache.\n     * @param interfaceId ERC165 interface for which to update the cache.\n     */\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\n\n    /**\n     * @notice Checks whether a contract implements an ERC165 interface or not.\n     * If the result is not cached a direct lookup on the contract address is performed.\n     * If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\n     * {updateERC165Cache} with the contract address.\n     * @param account Address of the contract to check.\n     * @param interfaceId ERC165 interface to check.\n     * @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\n\n    /**\n     * @notice Checks whether a contract implements an ERC165 interface or not without using or updating the cache.\n     * @param account Address of the contract to check.\n     * @param interfaceId ERC165 interface to check.\n     * @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "contracts/aa-4337/core/BaseAccount.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.21;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-empty-blocks */\n\nimport \"../interfaces/IAccount.sol\";\nimport \"../interfaces/IEntryPoint.sol\";\nimport \"./Helpers.sol\";\n\n/**\n * Basic account implementation.\n * this contract provides the basic logic for implementing the IAccount interface  - validateUserOp\n * specific account implementation should inherit it and provide the account-specific logic\n */\nabstract contract BaseAccount is IAccount {\n    using UserOperationLib for UserOperation;\n\n    //return value in case of signature failure, with no time-range.\n    // equivalent to _packValidationData(true,0,0);\n    uint256 internal constant SIG_VALIDATION_FAILED = 1;\n\n    /**\n     * Return the account nonce.\n     * This method returns the next sequential nonce.\n     * For a nonce of a specific key, use `entrypoint.getNonce(account, key)`\n     */\n    function getNonce() public view virtual returns (uint256) {\n        return entryPoint().getNonce(address(this), 0);\n    }\n\n    /**\n     * return the entryPoint used by this account.\n     * subclass should return the current entryPoint used by this account.\n     */\n    function entryPoint() public view virtual returns (IEntryPoint);\n\n    /**\n     * Validate user's signature and nonce.\n     * subclass doesn't need to override this method. Instead, it should override the specific internal validation methods.\n     */\n    function validateUserOp(\n        UserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    ) external virtual override returns (uint256 validationData) {\n        _requireFromEntryPoint();\n        validationData = _validateSignature(userOp, userOpHash);\n        _validateNonce(userOp.nonce);\n        _payPrefund(missingAccountFunds);\n    }\n\n    /**\n     * ensure the request comes from the known entrypoint.\n     */\n    function _requireFromEntryPoint() internal view virtual {\n        require(\n            msg.sender == address(entryPoint()),\n            \"account: not from EntryPoint\"\n        );\n    }\n\n    /**\n     * validate the signature is valid for this message.\n     * @param userOp validate the userOp.signature field\n     * @param userOpHash convenient field: the hash of the request, to check the signature against\n     *          (also hashes the entrypoint and chain id)\n     * @return validationData signature and time-range of this operation\n     *      <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\n     *         otherwise, an address of an \"authorizer\" contract.\n     *      <6-byte> validUntil - last timestamp this operation is valid. 0 for \"indefinite\"\n     *      <6-byte> validAfter - first timestamp this operation is valid\n     *      If the account doesn't use time-range, it is enough to return SIG_VALIDATION_FAILED value (1) for signature failure.\n     *      Note that the validation code cannot use block.timestamp (or block.number) directly.\n     */\n    function _validateSignature(\n        UserOperation calldata userOp,\n        bytes32 userOpHash\n    ) internal virtual returns (uint256 validationData);\n\n    /**\n     * Validate the nonce of the UserOperation.\n     * This method may validate the nonce requirement of this account.\n     * e.g.\n     * To limit the nonce to use sequenced UserOps only (no \"out of order\" UserOps):\n     *      `require(nonce < type(uint64).max)`\n     * For a hypothetical account that *requires* the nonce to be out-of-order:\n     *      `require(nonce & type(uint64).max == 0)`\n     *\n     * The actual nonce uniqueness is managed by the EntryPoint, and thus no other\n     * action is needed by the account itself.\n     *\n     * @param nonce to validate\n     *\n     * solhint-disable-next-line no-empty-blocks\n     */\n    function _validateNonce(uint256 nonce) internal view virtual {}\n\n    /**\n     * sends to the entrypoint (msg.sender) the missing funds for this transaction.\n     * subclass MAY override this method for better funds management\n     * (e.g. send to the entryPoint more than the minimum required, so that in future transactions\n     * it will not be required to send again)\n     * @param missingAccountFunds the minimum value this method should send the entrypoint.\n     *  this value MAY be zero, in case there is enough deposit, or the userOp has a paymaster.\n     */\n    function _payPrefund(uint256 missingAccountFunds) internal virtual {\n        if (missingAccountFunds != 0) {\n            (bool success, ) = payable(msg.sender).call{\n                value: missingAccountFunds,\n                gas: type(uint256).max\n            }(\"\");\n            (success);\n            //ignore failure (its EntryPoint's job to verify, not account.)\n        }\n    }\n}\n"
    },
    "contracts/aa-4337/core/EntryPoint.sol": {
      "content": "/**\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\n ** Only one instance required on each chain.\n **/\n// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.21;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n\nimport \"../interfaces/IAccount.sol\";\nimport \"../interfaces/IPaymaster.sol\";\nimport \"../interfaces/IEntryPoint.sol\";\n\nimport \"../utils/Exec.sol\";\nimport \"./StakeManager.sol\";\nimport \"./SenderCreator.sol\";\nimport \"./Helpers.sol\";\nimport \"./NonceManager.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract EntryPoint is\n    IEntryPoint,\n    StakeManager,\n    NonceManager,\n    ReentrancyGuard\n{\n    using UserOperationLib for UserOperation;\n\n    SenderCreator private immutable senderCreator = new SenderCreator();\n\n    // internal value used during simulation: need to query aggregator.\n    address private constant SIMULATE_FIND_AGGREGATOR = address(1);\n\n    // marker for inner call revert on out of gas\n    bytes32 private constant INNER_OUT_OF_GAS = hex\"deaddead\";\n\n    uint256 private constant REVERT_REASON_MAX_LEN = 2048;\n\n    /**\n     * for simulation purposes, validateUserOp (and validatePaymasterUserOp) must return this value\n     * in case of signature failure, instead of revert.\n     */\n    uint256 public constant SIG_VALIDATION_FAILED = 1;\n\n    /**\n     * compensate the caller's beneficiary address with the collected fees of all UserOperations.\n     * @param beneficiary the address to receive the fees\n     * @param amount amount to transfer.\n     */\n    function _compensate(address payable beneficiary, uint256 amount) internal {\n        require(beneficiary != address(0), \"AA90 invalid beneficiary\");\n        (bool success, ) = beneficiary.call{value: amount}(\"\");\n        require(success, \"AA91 failed send to beneficiary\");\n    }\n\n    /**\n     * execute a user op\n     * @param opIndex index into the opInfo array\n     * @param userOp the userOp to execute\n     * @param opInfo the opInfo filled by validatePrepayment for this userOp.\n     * @return collected the total amount this userOp paid.\n     */\n    function _executeUserOp(\n        uint256 opIndex,\n        UserOperation calldata userOp,\n        UserOpInfo memory opInfo\n    ) private returns (uint256 collected) {\n        uint256 preGas = gasleft();\n        bytes memory context = getMemoryBytesFromOffset(opInfo.contextOffset);\n\n        try this.innerHandleOp(userOp.callData, opInfo, context) returns (\n            uint256 _actualGasCost\n        ) {\n            collected = _actualGasCost;\n        } catch {\n            bytes32 innerRevertCode;\n            assembly {\n                returndatacopy(0, 0, 32)\n                innerRevertCode := mload(0)\n            }\n            // handleOps was called with gas limit too low. abort entire bundle.\n            if (innerRevertCode == INNER_OUT_OF_GAS) {\n                //report paymaster, since if it is not deliberately caused by the bundler,\n                // it must be a revert caused by paymaster.\n                revert FailedOp(opIndex, \"AA95 out of gas\");\n            }\n\n            uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\n            collected = _handlePostOp(\n                opIndex,\n                IPaymaster.PostOpMode.postOpReverted,\n                opInfo,\n                context,\n                actualGas\n            );\n        }\n    }\n\n    /**\n     * Execute a batch of UserOperations.\n     * no signature aggregator is used.\n     * if any account requires an aggregator (that is, it returned an aggregator when\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\n     * @param ops the operations to execute\n     * @param beneficiary the address to receive the fees\n     */\n    function handleOps(\n        UserOperation[] calldata ops,\n        address payable beneficiary\n    ) public nonReentrant {\n        uint256 opslen = ops.length;\n        UserOpInfo[] memory opInfos = new UserOpInfo[](opslen);\n\n        unchecked {\n            for (uint256 i = 0; i < opslen; i++) {\n                UserOpInfo memory opInfo = opInfos[i];\n                (\n                    uint256 validationData,\n                    uint256 pmValidationData\n                ) = _validatePrepayment(i, ops[i], opInfo);\n                _validateAccountAndPaymasterValidationData(\n                    i,\n                    validationData,\n                    pmValidationData,\n                    address(0)\n                );\n            }\n\n            uint256 collected = 0;\n            emit BeforeExecution();\n\n            for (uint256 i = 0; i < opslen; i++) {\n                collected += _executeUserOp(i, ops[i], opInfos[i]);\n            }\n\n            _compensate(beneficiary, collected);\n        } //unchecked\n    }\n\n    /**\n     * Execute a batch of UserOperation with Aggregators\n     * @param opsPerAggregator the operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts)\n     * @param beneficiary the address to receive the fees\n     */\n    function handleAggregatedOps(\n        UserOpsPerAggregator[] calldata opsPerAggregator,\n        address payable beneficiary\n    ) public nonReentrant {\n        uint256 opasLen = opsPerAggregator.length;\n        uint256 totalOps = 0;\n        for (uint256 i = 0; i < opasLen; i++) {\n            UserOpsPerAggregator calldata opa = opsPerAggregator[i];\n            UserOperation[] calldata ops = opa.userOps;\n            IAggregator aggregator = opa.aggregator;\n\n            //address(1) is special marker of \"signature error\"\n            require(\n                address(aggregator) != address(1),\n                \"AA96 invalid aggregator\"\n            );\n\n            if (address(aggregator) != address(0)) {\n                // solhint-disable-next-line no-empty-blocks\n                try aggregator.validateSignatures(ops, opa.signature) {} catch {\n                    revert SignatureValidationFailed(address(aggregator));\n                }\n            }\n\n            totalOps += ops.length;\n        }\n\n        UserOpInfo[] memory opInfos = new UserOpInfo[](totalOps);\n\n        emit BeforeExecution();\n\n        uint256 opIndex = 0;\n        for (uint256 a = 0; a < opasLen; a++) {\n            UserOpsPerAggregator calldata opa = opsPerAggregator[a];\n            UserOperation[] calldata ops = opa.userOps;\n            IAggregator aggregator = opa.aggregator;\n\n            uint256 opslen = ops.length;\n            for (uint256 i = 0; i < opslen; i++) {\n                UserOpInfo memory opInfo = opInfos[opIndex];\n                (\n                    uint256 validationData,\n                    uint256 paymasterValidationData\n                ) = _validatePrepayment(opIndex, ops[i], opInfo);\n                _validateAccountAndPaymasterValidationData(\n                    i,\n                    validationData,\n                    paymasterValidationData,\n                    address(aggregator)\n                );\n                opIndex++;\n            }\n        }\n\n        uint256 collected = 0;\n        opIndex = 0;\n        for (uint256 a = 0; a < opasLen; a++) {\n            UserOpsPerAggregator calldata opa = opsPerAggregator[a];\n            emit SignatureAggregatorChanged(address(opa.aggregator));\n            UserOperation[] calldata ops = opa.userOps;\n            uint256 opslen = ops.length;\n\n            for (uint256 i = 0; i < opslen; i++) {\n                collected += _executeUserOp(opIndex, ops[i], opInfos[opIndex]);\n                opIndex++;\n            }\n        }\n        emit SignatureAggregatorChanged(address(0));\n\n        _compensate(beneficiary, collected);\n    }\n\n    /// @inheritdoc IEntryPoint\n    function simulateHandleOp(\n        UserOperation calldata op,\n        address target,\n        bytes calldata targetCallData\n    ) external override {\n        UserOpInfo memory opInfo;\n        _simulationOnlyValidations(op);\n        (\n            uint256 validationData,\n            uint256 paymasterValidationData\n        ) = _validatePrepayment(0, op, opInfo);\n        ValidationData memory data = _intersectTimeRange(\n            validationData,\n            paymasterValidationData\n        );\n\n        numberMarker();\n        uint256 paid = _executeUserOp(0, op, opInfo);\n        numberMarker();\n        bool targetSuccess;\n        bytes memory targetResult;\n        if (target != address(0)) {\n            (targetSuccess, targetResult) = target.call(targetCallData);\n        }\n        revert ExecutionResult(\n            opInfo.preOpGas,\n            paid,\n            data.validAfter,\n            data.validUntil,\n            targetSuccess,\n            targetResult\n        );\n    }\n\n    // A memory copy of UserOp static fields only.\n    // Excluding: callData, initCode and signature. Replacing paymasterAndData with paymaster.\n    struct MemoryUserOp {\n        address sender;\n        uint256 nonce;\n        uint256 callGasLimit;\n        uint256 verificationGasLimit;\n        uint256 preVerificationGas;\n        address paymaster;\n        uint256 maxFeePerGas;\n        uint256 maxPriorityFeePerGas;\n    }\n\n    struct UserOpInfo {\n        MemoryUserOp mUserOp;\n        bytes32 userOpHash;\n        uint256 prefund;\n        uint256 contextOffset;\n        uint256 preOpGas;\n    }\n\n    /**\n     * inner function to handle a UserOperation.\n     * Must be declared \"external\" to open a call context, but it can only be called by handleOps.\n     */\n    function innerHandleOp(\n        bytes memory callData,\n        UserOpInfo memory opInfo,\n        bytes calldata context\n    ) external returns (uint256 actualGasCost) {\n        uint256 preGas = gasleft();\n        require(msg.sender == address(this), \"AA92 internal call only\");\n        MemoryUserOp memory mUserOp = opInfo.mUserOp;\n\n        uint callGasLimit = mUserOp.callGasLimit;\n        unchecked {\n            // handleOps was called with gas limit too low. abort entire bundle.\n            if (\n                gasleft() < callGasLimit + mUserOp.verificationGasLimit + 5000\n            ) {\n                assembly {\n                    mstore(0, INNER_OUT_OF_GAS)\n                    revert(0, 32)\n                }\n            }\n        }\n\n        IPaymaster.PostOpMode mode = IPaymaster.PostOpMode.opSucceeded;\n        if (callData.length > 0) {\n            bool success = Exec.call(mUserOp.sender, 0, callData, callGasLimit);\n            if (!success) {\n                bytes memory result = Exec.getReturnData(REVERT_REASON_MAX_LEN);\n                if (result.length > 0) {\n                    emit UserOperationRevertReason(\n                        opInfo.userOpHash,\n                        mUserOp.sender,\n                        mUserOp.nonce,\n                        result\n                    );\n                }\n                mode = IPaymaster.PostOpMode.opReverted;\n            }\n        }\n\n        unchecked {\n            uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\n            //note: opIndex is ignored (relevant only if mode==postOpReverted, which is only possible outside of innerHandleOp)\n            return _handlePostOp(0, mode, opInfo, context, actualGas);\n        }\n    }\n\n    /**\n     * generate a request Id - unique identifier for this request.\n     * the request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\n     */\n    function getUserOpHash(\n        UserOperation calldata userOp\n    ) public view returns (bytes32) {\n        return\n            keccak256(abi.encode(userOp.hash(), address(this), block.chainid));\n    }\n\n    /**\n     * copy general fields from userOp into the memory opInfo structure.\n     */\n    function _copyUserOpToMemory(\n        UserOperation calldata userOp,\n        MemoryUserOp memory mUserOp\n    ) internal pure {\n        mUserOp.sender = userOp.sender;\n        mUserOp.nonce = userOp.nonce;\n        mUserOp.callGasLimit = userOp.callGasLimit;\n        mUserOp.verificationGasLimit = userOp.verificationGasLimit;\n        mUserOp.preVerificationGas = userOp.preVerificationGas;\n        mUserOp.maxFeePerGas = userOp.maxFeePerGas;\n        mUserOp.maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\n        bytes calldata paymasterAndData = userOp.paymasterAndData;\n        if (paymasterAndData.length > 0) {\n            require(\n                paymasterAndData.length >= 20,\n                \"AA93 invalid paymasterAndData\"\n            );\n            mUserOp.paymaster = address(bytes20(paymasterAndData[:20]));\n        } else {\n            mUserOp.paymaster = address(0);\n        }\n    }\n\n    /**\n     * Simulate a call to account.validateUserOp and paymaster.validatePaymasterUserOp.\n     * @dev this method always revert. Successful result is ValidationResult error. other errors are failures.\n     * @dev The node must also verify it doesn't use banned opcodes, and that it doesn't reference storage outside the account's data.\n     * @param userOp the user operation to validate.\n     */\n    function simulateValidation(UserOperation calldata userOp) external {\n        UserOpInfo memory outOpInfo;\n\n        _simulationOnlyValidations(userOp);\n        (\n            uint256 validationData,\n            uint256 paymasterValidationData\n        ) = _validatePrepayment(0, userOp, outOpInfo);\n        StakeInfo memory paymasterInfo = _getStakeInfo(\n            outOpInfo.mUserOp.paymaster\n        );\n        StakeInfo memory senderInfo = _getStakeInfo(outOpInfo.mUserOp.sender);\n        StakeInfo memory factoryInfo;\n        {\n            bytes calldata initCode = userOp.initCode;\n            address factory = initCode.length >= 20\n                ? address(bytes20(initCode[0:20]))\n                : address(0);\n            factoryInfo = _getStakeInfo(factory);\n        }\n\n        ValidationData memory data = _intersectTimeRange(\n            validationData,\n            paymasterValidationData\n        );\n        address aggregator = data.aggregator;\n        bool sigFailed = aggregator == address(1);\n        ReturnInfo memory returnInfo = ReturnInfo(\n            outOpInfo.preOpGas,\n            outOpInfo.prefund,\n            sigFailed,\n            data.validAfter,\n            data.validUntil,\n            getMemoryBytesFromOffset(outOpInfo.contextOffset)\n        );\n\n        if (aggregator != address(0) && aggregator != address(1)) {\n            AggregatorStakeInfo memory aggregatorInfo = AggregatorStakeInfo(\n                aggregator,\n                _getStakeInfo(aggregator)\n            );\n            revert ValidationResultWithAggregation(\n                returnInfo,\n                senderInfo,\n                factoryInfo,\n                paymasterInfo,\n                aggregatorInfo\n            );\n        }\n        revert ValidationResult(\n            returnInfo,\n            senderInfo,\n            factoryInfo,\n            paymasterInfo\n        );\n    }\n\n    function _getRequiredPrefund(\n        MemoryUserOp memory mUserOp\n    ) internal pure returns (uint256 requiredPrefund) {\n        unchecked {\n            //when using a Paymaster, the verificationGasLimit is used also to as a limit for the postOp call.\n            // our security model might call postOp eventually twice\n            uint256 mul = mUserOp.paymaster != address(0) ? 3 : 1;\n            uint256 requiredGas = mUserOp.callGasLimit +\n                mUserOp.verificationGasLimit *\n                mul +\n                mUserOp.preVerificationGas;\n\n            requiredPrefund = requiredGas * mUserOp.maxFeePerGas;\n        }\n    }\n\n    // create the sender's contract if needed.\n    function _createSenderIfNeeded(\n        uint256 opIndex,\n        UserOpInfo memory opInfo,\n        bytes calldata initCode\n    ) internal {\n        if (initCode.length != 0) {\n            address sender = opInfo.mUserOp.sender;\n            if (sender.code.length != 0)\n                revert FailedOp(opIndex, \"AA10 sender already constructed\");\n            address sender1 = senderCreator.createSender{\n                gas: opInfo.mUserOp.verificationGasLimit\n            }(initCode);\n            if (sender1 == address(0))\n                revert FailedOp(opIndex, \"AA13 initCode failed or OOG\");\n            if (sender1 != sender)\n                revert FailedOp(opIndex, \"AA14 initCode must return sender\");\n            if (sender1.code.length == 0)\n                revert FailedOp(opIndex, \"AA15 initCode must create sender\");\n            address factory = address(bytes20(initCode[0:20]));\n            emit AccountDeployed(\n                opInfo.userOpHash,\n                sender,\n                factory,\n                opInfo.mUserOp.paymaster\n            );\n        }\n    }\n\n    /**\n     * Get counterfactual sender address.\n     *  Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\n     * this method always revert, and returns the address in SenderAddressResult error\n     * @param initCode the constructor code to be passed into the UserOperation.\n     */\n    function getSenderAddress(bytes calldata initCode) public {\n        address sender = senderCreator.createSender(initCode);\n        revert SenderAddressResult(sender);\n    }\n\n    function _simulationOnlyValidations(\n        UserOperation calldata userOp\n    ) internal view {\n        // solhint-disable-next-line no-empty-blocks\n        try\n            this._validateSenderAndPaymaster(\n                userOp.initCode,\n                userOp.sender,\n                userOp.paymasterAndData\n            )\n        {} catch Error(string memory revertReason) {\n            if (bytes(revertReason).length != 0) {\n                revert FailedOp(0, revertReason);\n            }\n        }\n    }\n\n    /**\n     * Called only during simulation.\n     * This function always reverts to prevent warm/cold storage differentiation in simulation vs execution.\n     */\n    function _validateSenderAndPaymaster(\n        bytes calldata initCode,\n        address sender,\n        bytes calldata paymasterAndData\n    ) external view {\n        if (initCode.length == 0 && sender.code.length == 0) {\n            // it would revert anyway. but give a meaningful message\n            revert(\"AA20 account not deployed\");\n        }\n        if (paymasterAndData.length >= 20) {\n            address paymaster = address(bytes20(paymasterAndData[0:20]));\n            if (paymaster.code.length == 0) {\n                // it would revert anyway. but give a meaningful message\n                revert(\"AA30 paymaster not deployed\");\n            }\n        }\n        // always revert\n        revert(\"\");\n    }\n\n    /**\n     * call account.validateUserOp.\n     * revert (with FailedOp) in case validateUserOp reverts, or account didn't send required prefund.\n     * decrement account's deposit if needed\n     */\n    function _validateAccountPrepayment(\n        uint256 opIndex,\n        UserOperation calldata op,\n        UserOpInfo memory opInfo,\n        uint256 requiredPrefund\n    )\n        internal\n        returns (\n            uint256 gasUsedByValidateAccountPrepayment,\n            uint256 validationData\n        )\n    {\n        unchecked {\n            uint256 preGas = gasleft();\n            MemoryUserOp memory mUserOp = opInfo.mUserOp;\n            address sender = mUserOp.sender;\n            _createSenderIfNeeded(opIndex, opInfo, op.initCode);\n            address paymaster = mUserOp.paymaster;\n            numberMarker();\n            uint256 missingAccountFunds = 0;\n            if (paymaster == address(0)) {\n                uint256 bal = balanceOf(sender);\n                missingAccountFunds = bal > requiredPrefund\n                    ? 0\n                    : requiredPrefund - bal;\n            }\n            try\n                IAccount(sender).validateUserOp{\n                    gas: mUserOp.verificationGasLimit\n                }(op, opInfo.userOpHash, missingAccountFunds)\n            returns (uint256 _validationData) {\n                validationData = _validationData;\n            } catch Error(string memory revertReason) {\n                revert FailedOp(\n                    opIndex,\n                    string.concat(\"AA23 reverted: \", revertReason)\n                );\n            } catch {\n                revert FailedOp(opIndex, \"AA23 reverted (or OOG)\");\n            }\n            if (paymaster == address(0)) {\n                DepositInfo storage senderInfo = deposits[sender];\n                uint256 deposit = senderInfo.deposit;\n                if (requiredPrefund > deposit) {\n                    revert FailedOp(opIndex, \"AA21 didn't pay prefund\");\n                }\n                senderInfo.deposit = uint112(deposit - requiredPrefund);\n            }\n            gasUsedByValidateAccountPrepayment = preGas - gasleft();\n        }\n    }\n\n    /**\n     * In case the request has a paymaster:\n     * Validate paymaster has enough deposit.\n     * Call paymaster.validatePaymasterUserOp.\n     * Revert with proper FailedOp in case paymaster reverts.\n     * Decrement paymaster's deposit\n     */\n    function _validatePaymasterPrepayment(\n        uint256 opIndex,\n        UserOperation calldata op,\n        UserOpInfo memory opInfo,\n        uint256 requiredPreFund,\n        uint256 gasUsedByValidateAccountPrepayment\n    ) internal returns (bytes memory context, uint256 validationData) {\n        unchecked {\n            MemoryUserOp memory mUserOp = opInfo.mUserOp;\n            uint256 verificationGasLimit = mUserOp.verificationGasLimit;\n            require(\n                verificationGasLimit > gasUsedByValidateAccountPrepayment,\n                \"AA41 too little verificationGas\"\n            );\n            uint256 gas = verificationGasLimit -\n                gasUsedByValidateAccountPrepayment;\n\n            address paymaster = mUserOp.paymaster;\n            DepositInfo storage paymasterInfo = deposits[paymaster];\n            uint256 deposit = paymasterInfo.deposit;\n            if (deposit < requiredPreFund) {\n                revert FailedOp(opIndex, \"AA31 paymaster deposit too low\");\n            }\n            paymasterInfo.deposit = uint112(deposit - requiredPreFund);\n            try\n                IPaymaster(paymaster).validatePaymasterUserOp{gas: gas}(\n                    op,\n                    opInfo.userOpHash,\n                    requiredPreFund\n                )\n            returns (bytes memory _context, uint256 _validationData) {\n                context = _context;\n                validationData = _validationData;\n            } catch Error(string memory revertReason) {\n                revert FailedOp(\n                    opIndex,\n                    string.concat(\"AA33 reverted: \", revertReason)\n                );\n            } catch {\n                revert FailedOp(opIndex, \"AA33 reverted (or OOG)\");\n            }\n        }\n    }\n\n    /**\n     * revert if either account validationData or paymaster validationData is expired\n     */\n    function _validateAccountAndPaymasterValidationData(\n        uint256 opIndex,\n        uint256 validationData,\n        uint256 paymasterValidationData,\n        address expectedAggregator\n    ) internal view {\n        (address aggregator, bool outOfTimeRange) = _getValidationData(\n            validationData\n        );\n        if (expectedAggregator != aggregator) {\n            revert FailedOp(opIndex, \"AA24 signature error\");\n        }\n        if (outOfTimeRange) {\n            revert FailedOp(opIndex, \"AA22 expired or not due\");\n        }\n        //pmAggregator is not a real signature aggregator: we don't have logic to handle it as address.\n        // non-zero address means that the paymaster fails due to some signature check (which is ok only during estimation)\n        address pmAggregator;\n        (pmAggregator, outOfTimeRange) = _getValidationData(\n            paymasterValidationData\n        );\n        if (pmAggregator != address(0)) {\n            revert FailedOp(opIndex, \"AA34 signature error\");\n        }\n        if (outOfTimeRange) {\n            revert FailedOp(opIndex, \"AA32 paymaster expired or not due\");\n        }\n    }\n\n    function _getValidationData(\n        uint256 validationData\n    ) internal view returns (address aggregator, bool outOfTimeRange) {\n        if (validationData == 0) {\n            return (address(0), false);\n        }\n        ValidationData memory data = _parseValidationData(validationData);\n        // solhint-disable-next-line not-rely-on-time\n        outOfTimeRange =\n            block.timestamp > data.validUntil ||\n            block.timestamp < data.validAfter;\n        aggregator = data.aggregator;\n    }\n\n    /**\n     * validate account and paymaster (if defined).\n     * also make sure total validation doesn't exceed verificationGasLimit\n     * this method is called off-chain (simulateValidation()) and on-chain (from handleOps)\n     * @param opIndex the index of this userOp into the \"opInfos\" array\n     * @param userOp the userOp to validate\n     */\n    function _validatePrepayment(\n        uint256 opIndex,\n        UserOperation calldata userOp,\n        UserOpInfo memory outOpInfo\n    )\n        private\n        returns (uint256 validationData, uint256 paymasterValidationData)\n    {\n        uint256 preGas = gasleft();\n        MemoryUserOp memory mUserOp = outOpInfo.mUserOp;\n        _copyUserOpToMemory(userOp, mUserOp);\n        outOpInfo.userOpHash = getUserOpHash(userOp);\n\n        // validate all numeric values in userOp are well below 128 bit, so they can safely be added\n        // and multiplied without causing overflow\n        uint256 maxGasValues = mUserOp.preVerificationGas |\n            mUserOp.verificationGasLimit |\n            mUserOp.callGasLimit |\n            userOp.maxFeePerGas |\n            userOp.maxPriorityFeePerGas;\n        require(maxGasValues <= type(uint120).max, \"AA94 gas values overflow\");\n\n        uint256 gasUsedByValidateAccountPrepayment;\n        uint256 requiredPreFund = _getRequiredPrefund(mUserOp);\n        (\n            gasUsedByValidateAccountPrepayment,\n            validationData\n        ) = _validateAccountPrepayment(\n            opIndex,\n            userOp,\n            outOpInfo,\n            requiredPreFund\n        );\n\n        if (!_validateAndUpdateNonce(mUserOp.sender, mUserOp.nonce)) {\n            revert FailedOp(opIndex, \"AA25 invalid account nonce\");\n        }\n\n        //a \"marker\" where account opcode validation is done and paymaster opcode validation is about to start\n        // (used only by off-chain simulateValidation)\n        numberMarker();\n\n        bytes memory context;\n        if (mUserOp.paymaster != address(0)) {\n            (context, paymasterValidationData) = _validatePaymasterPrepayment(\n                opIndex,\n                userOp,\n                outOpInfo,\n                requiredPreFund,\n                gasUsedByValidateAccountPrepayment\n            );\n        }\n        unchecked {\n            uint256 gasUsed = preGas - gasleft();\n\n            if (userOp.verificationGasLimit < gasUsed) {\n                revert FailedOp(opIndex, \"AA40 over verificationGasLimit\");\n            }\n            outOpInfo.prefund = requiredPreFund;\n            outOpInfo.contextOffset = getOffsetOfMemoryBytes(context);\n            outOpInfo.preOpGas = preGas - gasleft() + userOp.preVerificationGas;\n        }\n    }\n\n    /**\n     * process post-operation.\n     * called just after the callData is executed.\n     * if a paymaster is defined and its validation returned a non-empty context, its postOp is called.\n     * the excess amount is refunded to the account (or paymaster - if it was used in the request)\n     * @param opIndex index in the batch\n     * @param mode - whether is called from innerHandleOp, or outside (postOpReverted)\n     * @param opInfo userOp fields and info collected during validation\n     * @param context the context returned in validatePaymasterUserOp\n     * @param actualGas the gas used so far by this user operation\n     */\n    function _handlePostOp(\n        uint256 opIndex,\n        IPaymaster.PostOpMode mode,\n        UserOpInfo memory opInfo,\n        bytes memory context,\n        uint256 actualGas\n    ) private returns (uint256 actualGasCost) {\n        uint256 preGas = gasleft();\n        unchecked {\n            address refundAddress;\n            MemoryUserOp memory mUserOp = opInfo.mUserOp;\n            uint256 gasPrice = getUserOpGasPrice(mUserOp);\n\n            address paymaster = mUserOp.paymaster;\n            if (paymaster == address(0)) {\n                refundAddress = mUserOp.sender;\n            } else {\n                refundAddress = paymaster;\n                if (context.length > 0) {\n                    actualGasCost = actualGas * gasPrice;\n                    if (mode != IPaymaster.PostOpMode.postOpReverted) {\n                        IPaymaster(paymaster).postOp{\n                            gas: mUserOp.verificationGasLimit\n                        }(mode, context, actualGasCost);\n                    } else {\n                        // solhint-disable-next-line no-empty-blocks\n                        try\n                            IPaymaster(paymaster).postOp{\n                                gas: mUserOp.verificationGasLimit\n                            }(mode, context, actualGasCost)\n                        {} catch Error(string memory reason) {\n                            revert FailedOp(\n                                opIndex,\n                                string.concat(\"AA50 postOp reverted: \", reason)\n                            );\n                        } catch {\n                            revert FailedOp(opIndex, \"AA50 postOp revert\");\n                        }\n                    }\n                }\n            }\n            actualGas += preGas - gasleft();\n            actualGasCost = actualGas * gasPrice;\n            if (opInfo.prefund < actualGasCost) {\n                revert FailedOp(opIndex, \"AA51 prefund below actualGasCost\");\n            }\n            uint256 refund = opInfo.prefund - actualGasCost;\n            _incrementDeposit(refundAddress, refund);\n            bool success = mode == IPaymaster.PostOpMode.opSucceeded;\n            emit UserOperationEvent(\n                opInfo.userOpHash,\n                mUserOp.sender,\n                mUserOp.paymaster,\n                mUserOp.nonce,\n                success,\n                actualGasCost,\n                actualGas\n            );\n        } // unchecked\n    }\n\n    /**\n     * the gas price this UserOp agrees to pay.\n     * relayer/block builder might submit the TX with higher priorityFee, but the user should not\n     */\n    function getUserOpGasPrice(\n        MemoryUserOp memory mUserOp\n    ) internal view returns (uint256) {\n        unchecked {\n            uint256 maxFeePerGas = mUserOp.maxFeePerGas;\n            uint256 maxPriorityFeePerGas = mUserOp.maxPriorityFeePerGas;\n            if (maxFeePerGas == maxPriorityFeePerGas) {\n                //legacy mode (for networks that don't support basefee opcode)\n                return maxFeePerGas;\n            }\n            return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\n        }\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function getOffsetOfMemoryBytes(\n        bytes memory data\n    ) internal pure returns (uint256 offset) {\n        assembly {\n            offset := data\n        }\n    }\n\n    function getMemoryBytesFromOffset(\n        uint256 offset\n    ) internal pure returns (bytes memory data) {\n        assembly {\n            data := offset\n        }\n    }\n\n    //place the NUMBER opcode in the code.\n    // this is used as a marker during simulation, as this OP is completely banned from the simulated code of the\n    // account and paymaster.\n    function numberMarker() internal view {\n        assembly {\n            mstore(0, number())\n        }\n    }\n}\n"
    },
    "contracts/aa-4337/core/Helpers.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.21;\n\n/* solhint-disable no-inline-assembly */\n\n/**\n * returned data from validateUserOp.\n * validateUserOp returns a uint256, with is created by `_packedValidationData` and parsed by `_parseValidationData`\n * @param aggregator - address(0) - the account validated the signature by itself.\n *              address(1) - the account failed to validate the signature.\n *              otherwise - this is an address of a signature aggregator that must be used to validate the signature.\n * @param validAfter - this UserOp is valid only after this timestamp.\n * @param validaUntil - this UserOp is valid only up to this timestamp.\n */\nstruct ValidationData {\n    address aggregator;\n    uint48 validAfter;\n    uint48 validUntil;\n}\n\n//extract sigFailed, validAfter, validUntil.\n// also convert zero validUntil to type(uint48).max\nfunction _parseValidationData(\n    uint validationData\n) pure returns (ValidationData memory data) {\n    address aggregator = address(uint160(validationData));\n    uint48 validUntil = uint48(validationData >> 160);\n    if (validUntil == 0) {\n        validUntil = type(uint48).max;\n    }\n    uint48 validAfter = uint48(validationData >> (48 + 160));\n    return ValidationData(aggregator, validAfter, validUntil);\n}\n\n// intersect account and paymaster ranges.\nfunction _intersectTimeRange(\n    uint256 validationData,\n    uint256 paymasterValidationData\n) pure returns (ValidationData memory) {\n    ValidationData memory accountValidationData = _parseValidationData(\n        validationData\n    );\n    ValidationData memory pmValidationData = _parseValidationData(\n        paymasterValidationData\n    );\n    address aggregator = accountValidationData.aggregator;\n    if (aggregator == address(0)) {\n        aggregator = pmValidationData.aggregator;\n    }\n    uint48 validAfter = accountValidationData.validAfter;\n    uint48 validUntil = accountValidationData.validUntil;\n    uint48 pmValidAfter = pmValidationData.validAfter;\n    uint48 pmValidUntil = pmValidationData.validUntil;\n\n    if (validAfter < pmValidAfter) validAfter = pmValidAfter;\n    if (validUntil > pmValidUntil) validUntil = pmValidUntil;\n    return ValidationData(aggregator, validAfter, validUntil);\n}\n\n/**\n * helper to pack the return value for validateUserOp\n * @param data - the ValidationData to pack\n */\nfunction _packValidationData(\n    ValidationData memory data\n) pure returns (uint256) {\n    return\n        uint160(data.aggregator) |\n        (uint256(data.validUntil) << 160) |\n        (uint256(data.validAfter) << (160 + 48));\n}\n\n/**\n * helper to pack the return value for validateUserOp, when not using an aggregator\n * @param sigFailed - true for signature failure, false for success\n * @param validUntil last timestamp this UserOperation is valid (or zero for infinite)\n * @param validAfter first timestamp this UserOperation is valid\n */\nfunction _packValidationData(\n    bool sigFailed,\n    uint48 validUntil,\n    uint48 validAfter\n) pure returns (uint256) {\n    return\n        (sigFailed ? 1 : 0) |\n        (uint256(validUntil) << 160) |\n        (uint256(validAfter) << (160 + 48));\n}\n\n/**\n * keccak function over calldata.\n * @dev copy calldata into memory, do keccak and drop allocated memory. Strangely, this is more efficient than letting solidity do it.\n */\nfunction calldataKeccak(bytes calldata data) pure returns (bytes32 ret) {\n    assembly {\n        let mem := mload(0x40)\n        let len := data.length\n        calldatacopy(mem, data.offset, len)\n        ret := keccak256(mem, len)\n    }\n}\n"
    },
    "contracts/aa-4337/core/NonceManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.21;\n\nimport \"../interfaces/IEntryPoint.sol\";\n\n/**\n * nonce management functionality\n */\ncontract NonceManager is INonceManager {\n    /**\n     * The next valid sequence number for a given nonce key.\n     */\n    mapping(address => mapping(uint192 => uint256)) public nonceSequenceNumber;\n\n    function getNonce(\n        address sender,\n        uint192 key\n    ) public view override returns (uint256 nonce) {\n        return nonceSequenceNumber[sender][key] | (uint256(key) << 64);\n    }\n\n    // allow an account to manually increment its own nonce.\n    // (mainly so that during construction nonce can be made non-zero,\n    // to \"absorb\" the gas cost of first nonce increment to 1st transaction (construction),\n    // not to 2nd transaction)\n    function incrementNonce(uint192 key) public override {\n        nonceSequenceNumber[msg.sender][key]++;\n    }\n\n    /**\n     * validate nonce uniqueness for this account.\n     * called just after validateUserOp()\n     */\n    function _validateAndUpdateNonce(\n        address sender,\n        uint256 nonce\n    ) internal returns (bool) {\n        uint192 key = uint192(nonce >> 64);\n        uint64 seq = uint64(nonce);\n        return nonceSequenceNumber[sender][key]++ == seq;\n    }\n}\n"
    },
    "contracts/aa-4337/core/SenderCreator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.21;\n\n/**\n * helper contract for EntryPoint, to call userOp.initCode from a \"neutral\" address,\n * which is explicitly not the entryPoint itself.\n */\ncontract SenderCreator {\n    /**\n     * call the \"initCode\" factory to create and return the sender account address\n     * @param initCode the initCode value from a UserOp. contains 20 bytes of factory address, followed by calldata\n     * @return sender the returned address of the created account, or zero address on failure.\n     */\n    function createSender(\n        bytes calldata initCode\n    ) external returns (address sender) {\n        address factory = address(bytes20(initCode[0:20]));\n        bytes memory initCallData = initCode[20:];\n        bool success;\n        /* solhint-disable no-inline-assembly */\n        assembly {\n            success := call(\n                gas(),\n                factory,\n                0,\n                add(initCallData, 0x20),\n                mload(initCallData),\n                0,\n                32\n            )\n            sender := mload(0)\n        }\n        if (!success) {\n            sender = address(0);\n        }\n    }\n}\n"
    },
    "contracts/aa-4337/core/StakeManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport \"../interfaces/IStakeManager.sol\";\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable not-rely-on-time */\n/**\n * manage deposits and stakes.\n * deposit is just a balance used to pay for UserOperations (either by a paymaster or an account)\n * stake is value locked for at least \"unstakeDelay\" by a paymaster.\n */\nabstract contract StakeManager is IStakeManager {\n    /// maps paymaster to their deposits and stakes\n    mapping(address => DepositInfo) public deposits;\n\n    /// @inheritdoc IStakeManager\n    function getDepositInfo(\n        address account\n    ) public view returns (DepositInfo memory info) {\n        return deposits[account];\n    }\n\n    // internal method to return just the stake info\n    function _getStakeInfo(\n        address addr\n    ) internal view returns (StakeInfo memory info) {\n        DepositInfo storage depositInfo = deposits[addr];\n        info.stake = depositInfo.stake;\n        info.unstakeDelaySec = depositInfo.unstakeDelaySec;\n    }\n\n    /// return the deposit (for gas payment) of the account\n    function balanceOf(address account) public view returns (uint256) {\n        return deposits[account].deposit;\n    }\n\n    receive() external payable {\n        depositTo(msg.sender);\n    }\n\n    function _incrementDeposit(address account, uint256 amount) internal {\n        DepositInfo storage info = deposits[account];\n        uint256 newAmount = info.deposit + amount;\n        require(newAmount <= type(uint112).max, \"deposit overflow\");\n        info.deposit = uint112(newAmount);\n    }\n\n    /**\n     * add to the deposit of the given account\n     */\n    function depositTo(address account) public payable {\n        _incrementDeposit(account, msg.value);\n        DepositInfo storage info = deposits[account];\n        emit Deposited(account, info.deposit);\n    }\n\n    /**\n     * add to the account's stake - amount and delay\n     * any pending unstake is first cancelled.\n     * @param unstakeDelaySec the new lock duration before the deposit can be withdrawn.\n     */\n    function addStake(uint32 unstakeDelaySec) public payable {\n        DepositInfo storage info = deposits[msg.sender];\n        require(unstakeDelaySec > 0, \"must specify unstake delay\");\n        require(\n            unstakeDelaySec >= info.unstakeDelaySec,\n            \"cannot decrease unstake time\"\n        );\n        uint256 stake = info.stake + msg.value;\n        require(stake > 0, \"no stake specified\");\n        require(stake <= type(uint112).max, \"stake overflow\");\n        deposits[msg.sender] = DepositInfo(\n            info.deposit,\n            true,\n            uint112(stake),\n            unstakeDelaySec,\n            0\n        );\n        emit StakeLocked(msg.sender, stake, unstakeDelaySec);\n    }\n\n    /**\n     * attempt to unlock the stake.\n     * the value can be withdrawn (using withdrawStake) after the unstake delay.\n     */\n    function unlockStake() external {\n        DepositInfo storage info = deposits[msg.sender];\n        require(info.unstakeDelaySec != 0, \"not staked\");\n        require(info.staked, \"already unstaking\");\n        uint48 withdrawTime = uint48(block.timestamp) + info.unstakeDelaySec;\n        info.withdrawTime = withdrawTime;\n        info.staked = false;\n        emit StakeUnlocked(msg.sender, withdrawTime);\n    }\n\n    /**\n     * withdraw from the (unlocked) stake.\n     * must first call unlockStake and wait for the unstakeDelay to pass\n     * @param withdrawAddress the address to send withdrawn value.\n     */\n    function withdrawStake(address payable withdrawAddress) external {\n        DepositInfo storage info = deposits[msg.sender];\n        uint256 stake = info.stake;\n        require(stake > 0, \"No stake to withdraw\");\n        require(info.withdrawTime > 0, \"must call unlockStake() first\");\n        require(\n            info.withdrawTime <= block.timestamp,\n            \"Stake withdrawal is not due\"\n        );\n        info.unstakeDelaySec = 0;\n        info.withdrawTime = 0;\n        info.stake = 0;\n        emit StakeWithdrawn(msg.sender, withdrawAddress, stake);\n        (bool success, ) = withdrawAddress.call{value: stake}(\"\");\n        require(success, \"failed to withdraw stake\");\n    }\n\n    /**\n     * withdraw from the deposit.\n     * @param withdrawAddress the address to send withdrawn value.\n     * @param withdrawAmount the amount to withdraw.\n     */\n    function withdrawTo(\n        address payable withdrawAddress,\n        uint256 withdrawAmount\n    ) external {\n        DepositInfo storage info = deposits[msg.sender];\n        require(withdrawAmount <= info.deposit, \"Withdraw amount too large\");\n        info.deposit = uint112(info.deposit - withdrawAmount);\n        emit Withdrawn(msg.sender, withdrawAddress, withdrawAmount);\n        (bool success, ) = withdrawAddress.call{value: withdrawAmount}(\"\");\n        require(success, \"failed to withdraw\");\n    }\n}\n"
    },
    "contracts/aa-4337/interfaces/IAccount.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\nimport \"./UserOperation.sol\";\n\ninterface IAccount {\n    /**\n     * Validate user's signature and nonce\n     * the entryPoint will make the call to the recipient only if this validation call returns successfully.\n     * signature failure should be reported by returning SIG_VALIDATION_FAILED (1).\n     * This allows making a \"simulation call\" without a valid signature\n     * Other failures (e.g. nonce mismatch, or invalid signature format) should still revert to signal failure.\n     *\n     * @dev Must validate caller is the entryPoint.\n     *      Must validate the signature and nonce\n     * @param userOp the operation that is about to be executed.\n     * @param userOpHash hash of the user's request data. can be used as the basis for signature.\n     * @param missingAccountFunds missing funds on the account's deposit in the entrypoint.\n     *      This is the minimum amount to transfer to the sender(entryPoint) to be able to make the call.\n     *      The excess is left as a deposit in the entrypoint, for future calls.\n     *      can be withdrawn anytime using \"entryPoint.withdrawTo()\"\n     *      In case there is a paymaster in the request (or the current deposit is high enough), this value will be zero.\n     * @return validationData packaged ValidationData structure. use `_packValidationData` and `_unpackValidationData` to encode and decode\n     *      <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\n     *         otherwise, an address of an \"authorizer\" contract.\n     *      <6-byte> validUntil - last timestamp this operation is valid. 0 for \"indefinite\"\n     *      <6-byte> validAfter - first timestamp this operation is valid\n     *      If an account doesn't use time-range, it is enough to return SIG_VALIDATION_FAILED value (1) for signature failure.\n     *      Note that the validation code cannot use block.timestamp (or block.number) directly.\n     */\n    function validateUserOp(\n        UserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    ) external returns (uint256 validationData);\n}\n"
    },
    "contracts/aa-4337/interfaces/IAggregator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\nimport \"./UserOperation.sol\";\n\n/**\n * Aggregated Signatures validator.\n */\ninterface IAggregator {\n    /**\n     * validate aggregated signature.\n     * revert if the aggregated signature does not match the given list of operations.\n     */\n    function validateSignatures(\n        UserOperation[] calldata userOps,\n        bytes calldata signature\n    ) external view;\n\n    /**\n     * validate signature of a single userOp\n     * This method is should be called by bundler after EntryPoint.simulateValidation() returns (reverts) with ValidationResultWithAggregation\n     * First it validates the signature over the userOp. Then it returns data to be used when creating the handleOps.\n     * @param userOp the userOperation received from the user.\n     * @return sigForUserOp the value to put into the signature field of the userOp when calling handleOps.\n     *    (usually empty, unless account and aggregator support some kind of \"multisig\"\n     */\n    function validateUserOpSignature(\n        UserOperation calldata userOp\n    ) external view returns (bytes memory sigForUserOp);\n\n    /**\n     * aggregate multiple signatures into a single value.\n     * This method is called off-chain to calculate the signature to pass with handleOps()\n     * bundler MAY use optimized custom code perform this aggregation\n     * @param userOps array of UserOperations to collect the signatures from.\n     * @return aggregatedSignature the aggregated signature\n     */\n    function aggregateSignatures(\n        UserOperation[] calldata userOps\n    ) external view returns (bytes memory aggregatedSignature);\n}\n"
    },
    "contracts/aa-4337/interfaces/IEntryPoint.sol": {
      "content": "/**\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\n ** Only one instance required on each chain.\n **/\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable reason-string */\n\nimport \"./UserOperation.sol\";\nimport \"./IStakeManager.sol\";\nimport \"./IAggregator.sol\";\nimport \"./INonceManager.sol\";\n\ninterface IEntryPoint is IStakeManager, INonceManager {\n    /***\n     * An event emitted after each successful request\n     * @param userOpHash - unique identifier for the request (hash its entire content, except signature).\n     * @param sender - the account that generates this request.\n     * @param paymaster - if non-null, the paymaster that pays for this request.\n     * @param nonce - the nonce value from the request.\n     * @param success - true if the sender transaction succeeded, false if reverted.\n     * @param actualGasCost - actual amount paid (by account or paymaster) for this UserOperation.\n     * @param actualGasUsed - total gas used by this UserOperation (including preVerification, creation, validation and execution).\n     */\n    event UserOperationEvent(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        address indexed paymaster,\n        uint256 nonce,\n        bool success,\n        uint256 actualGasCost,\n        uint256 actualGasUsed\n    );\n\n    /**\n     * account \"sender\" was deployed.\n     * @param userOpHash the userOp that deployed this account. UserOperationEvent will follow.\n     * @param sender the account that is deployed\n     * @param factory the factory used to deploy this account (in the initCode)\n     * @param paymaster the paymaster used by this UserOp\n     */\n    event AccountDeployed(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        address factory,\n        address paymaster\n    );\n\n    /**\n     * An event emitted if the UserOperation \"callData\" reverted with non-zero length\n     * @param userOpHash the request unique identifier.\n     * @param sender the sender of this request\n     * @param nonce the nonce used in the request\n     * @param revertReason - the return bytes from the (reverted) call to \"callData\".\n     */\n    event UserOperationRevertReason(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        uint256 nonce,\n        bytes revertReason\n    );\n\n    /**\n     * an event emitted by handleOps(), before starting the execution loop.\n     * any event emitted before this event, is part of the validation.\n     */\n    event BeforeExecution();\n\n    /**\n     * signature aggregator used by the following UserOperationEvents within this bundle.\n     */\n    event SignatureAggregatorChanged(address indexed aggregator);\n\n    /**\n     * a custom revert error of handleOps, to identify the offending op.\n     *  NOTE: if simulateValidation passes successfully, there should be no reason for handleOps to fail on it.\n     *  @param opIndex - index into the array of ops to the failed one (in simulateValidation, this is always zero)\n     *  @param reason - revert reason\n     *      The string starts with a unique code \"AAmn\", where \"m\" is \"1\" for factory, \"2\" for account and \"3\" for paymaster issues,\n     *      so a failure can be attributed to the correct entity.\n     *   Should be caught in off-chain handleOps simulation and not happen on-chain.\n     *   Useful for mitigating DoS attempts against batchers or for troubleshooting of factory/account/paymaster reverts.\n     */\n    error FailedOp(uint256 opIndex, string reason);\n\n    /**\n     * error case when a signature aggregator fails to verify the aggregated signature it had created.\n     */\n    error SignatureValidationFailed(address aggregator);\n\n    /**\n     * Successful result from simulateValidation.\n     * @param returnInfo gas and time-range returned values\n     * @param senderInfo stake information about the sender\n     * @param factoryInfo stake information about the factory (if any)\n     * @param paymasterInfo stake information about the paymaster (if any)\n     */\n    error ValidationResult(\n        ReturnInfo returnInfo,\n        StakeInfo senderInfo,\n        StakeInfo factoryInfo,\n        StakeInfo paymasterInfo\n    );\n\n    /**\n     * Successful result from simulateValidation, if the account returns a signature aggregator\n     * @param returnInfo gas and time-range returned values\n     * @param senderInfo stake information about the sender\n     * @param factoryInfo stake information about the factory (if any)\n     * @param paymasterInfo stake information about the paymaster (if any)\n     * @param aggregatorInfo signature aggregation info (if the account requires signature aggregator)\n     *      bundler MUST use it to verify the signature, or reject the UserOperation\n     */\n    error ValidationResultWithAggregation(\n        ReturnInfo returnInfo,\n        StakeInfo senderInfo,\n        StakeInfo factoryInfo,\n        StakeInfo paymasterInfo,\n        AggregatorStakeInfo aggregatorInfo\n    );\n\n    /**\n     * return value of getSenderAddress\n     */\n    error SenderAddressResult(address sender);\n\n    /**\n     * return value of simulateHandleOp\n     */\n    error ExecutionResult(\n        uint256 preOpGas,\n        uint256 paid,\n        uint48 validAfter,\n        uint48 validUntil,\n        bool targetSuccess,\n        bytes targetResult\n    );\n\n    //UserOps handled, per aggregator\n    struct UserOpsPerAggregator {\n        UserOperation[] userOps;\n        // aggregator address\n        IAggregator aggregator;\n        // aggregated signature\n        bytes signature;\n    }\n\n    /**\n     * Execute a batch of UserOperation.\n     * no signature aggregator is used.\n     * if any account requires an aggregator (that is, it returned an aggregator when\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\n     * @param ops the operations to execute\n     * @param beneficiary the address to receive the fees\n     */\n    function handleOps(\n        UserOperation[] calldata ops,\n        address payable beneficiary\n    ) external;\n\n    /**\n     * Execute a batch of UserOperation with Aggregators\n     * @param opsPerAggregator the operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts)\n     * @param beneficiary the address to receive the fees\n     */\n    function handleAggregatedOps(\n        UserOpsPerAggregator[] calldata opsPerAggregator,\n        address payable beneficiary\n    ) external;\n\n    /**\n     * generate a request Id - unique identifier for this request.\n     * the request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\n     */\n    function getUserOpHash(\n        UserOperation calldata userOp\n    ) external view returns (bytes32);\n\n    /**\n     * Simulate a call to account.validateUserOp and paymaster.validatePaymasterUserOp.\n     * @dev this method always revert. Successful result is ValidationResult error. other errors are failures.\n     * @dev The node must also verify it doesn't use banned opcodes, and that it doesn't reference storage outside the account's data.\n     * @param userOp the user operation to validate.\n     */\n    function simulateValidation(UserOperation calldata userOp) external;\n\n    /**\n     * gas and return values during simulation\n     * @param preOpGas the gas used for validation (including preValidationGas)\n     * @param prefund the required prefund for this operation\n     * @param sigFailed validateUserOp's (or paymaster's) signature check failed\n     * @param validAfter - first timestamp this UserOp is valid (merging account and paymaster time-range)\n     * @param validUntil - last timestamp this UserOp is valid (merging account and paymaster time-range)\n     * @param paymasterContext returned by validatePaymasterUserOp (to be passed into postOp)\n     */\n    struct ReturnInfo {\n        uint256 preOpGas;\n        uint256 prefund;\n        bool sigFailed;\n        uint48 validAfter;\n        uint48 validUntil;\n        bytes paymasterContext;\n    }\n\n    /**\n     * returned aggregated signature info.\n     * the aggregator returned by the account, and its current stake.\n     */\n    struct AggregatorStakeInfo {\n        address aggregator;\n        StakeInfo stakeInfo;\n    }\n\n    /**\n     * Get counterfactual sender address.\n     *  Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\n     * this method always revert, and returns the address in SenderAddressResult error\n     * @param initCode the constructor code to be passed into the UserOperation.\n     */\n    function getSenderAddress(bytes memory initCode) external;\n\n    /**\n     * simulate full execution of a UserOperation (including both validation and target execution)\n     * this method will always revert with \"ExecutionResult\".\n     * it performs full validation of the UserOperation, but ignores signature error.\n     * an optional target address is called after the userop succeeds, and its value is returned\n     * (before the entire call is reverted)\n     * Note that in order to collect the the success/failure of the target call, it must be executed\n     * with trace enabled to track the emitted events.\n     * @param op the UserOperation to simulate\n     * @param target if nonzero, a target address to call after userop simulation. If called, the targetSuccess and targetResult\n     *        are set to the return from that call.\n     * @param targetCallData callData to pass to target address\n     */\n    function simulateHandleOp(\n        UserOperation calldata op,\n        address target,\n        bytes calldata targetCallData\n    ) external;\n}\n"
    },
    "contracts/aa-4337/interfaces/INonceManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\ninterface INonceManager {\n    /**\n     * Return the next nonce for this sender.\n     * Within a given key, the nonce values are sequenced (starting with zero, and incremented by one on each userop)\n     * But UserOp with different keys can come with arbitrary order.\n     *\n     * @param sender the account address\n     * @param key the high 192 bit of the nonce\n     * @return nonce a full nonce to pass for next UserOp with this sender.\n     */\n    function getNonce(\n        address sender,\n        uint192 key\n    ) external view returns (uint256 nonce);\n\n    /**\n     * Manually increment the nonce of the sender.\n     * This method is exposed just for completeness..\n     * Account does NOT need to call it, neither during validation, nor elsewhere,\n     * as the EntryPoint will update the nonce regardless.\n     * Possible use-case is call it with various keys to \"initialize\" their nonces to one, so that future\n     * UserOperations will not pay extra for the first transaction with a given key.\n     */\n    function incrementNonce(uint192 key) external;\n}\n"
    },
    "contracts/aa-4337/interfaces/IPaymaster.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\nimport \"./UserOperation.sol\";\n\n/**\n * the interface exposed by a paymaster contract, who agrees to pay the gas for user's operations.\n * a paymaster must hold a stake to cover the required entrypoint stake and also the gas for the transaction.\n */\ninterface IPaymaster {\n    enum PostOpMode {\n        opSucceeded, // user op succeeded\n        opReverted, // user op reverted. still has to pay for gas.\n        postOpReverted //user op succeeded, but caused postOp to revert. Now it's a 2nd call, after user's op was deliberately reverted.\n    }\n\n    /**\n     * payment validation: check if paymaster agrees to pay.\n     * Must verify sender is the entryPoint.\n     * Revert to reject this request.\n     * Note that bundlers will reject this method if it changes the state, unless the paymaster is trusted (whitelisted)\n     * The paymaster pre-pays using its deposit, and receive back a refund after the postOp method returns.\n     * @param userOp the user operation\n     * @param userOpHash hash of the user's request data.\n     * @param maxCost the maximum cost of this transaction (based on maximum gas and gas price from userOp)\n     * @return context value to send to a postOp\n     *      zero length to signify postOp is not required.\n     * @return validationData signature and time-range of this operation, encoded the same as the return value of validateUserOperation\n     *      <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\n     *         otherwise, an address of an \"authorizer\" contract.\n     *      <6-byte> validUntil - last timestamp this operation is valid. 0 for \"indefinite\"\n     *      <6-byte> validAfter - first timestamp this operation is valid\n     *      Note that the validation code cannot use block.timestamp (or block.number) directly.\n     */\n    function validatePaymasterUserOp(\n        UserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 maxCost\n    ) external returns (bytes memory context, uint256 validationData);\n\n    /**\n     * post-operation handler.\n     * Must verify sender is the entryPoint\n     * @param mode enum with the following options:\n     *      opSucceeded - user operation succeeded.\n     *      opReverted  - user op reverted. still has to pay for gas.\n     *      postOpReverted - user op succeeded, but caused postOp (in mode=opSucceeded) to revert.\n     *                       Now this is the 2nd call, after user's op was deliberately reverted.\n     * @param context - the context value returned by validatePaymasterUserOp\n     * @param actualGasCost - actual gas used so far (without this postOp call).\n     */\n    function postOp(\n        PostOpMode mode,\n        bytes calldata context,\n        uint256 actualGasCost\n    ) external;\n}\n"
    },
    "contracts/aa-4337/interfaces/IStakeManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.12;\n\n/**\n * manage deposits and stakes.\n * deposit is just a balance used to pay for UserOperations (either by a paymaster or an account)\n * stake is value locked for at least \"unstakeDelay\" by the staked entity.\n */\ninterface IStakeManager {\n    event Deposited(address indexed account, uint256 totalDeposit);\n\n    event Withdrawn(\n        address indexed account,\n        address withdrawAddress,\n        uint256 amount\n    );\n\n    /// Emitted when stake or unstake delay are modified\n    event StakeLocked(\n        address indexed account,\n        uint256 totalStaked,\n        uint256 unstakeDelaySec\n    );\n\n    /// Emitted once a stake is scheduled for withdrawal\n    event StakeUnlocked(address indexed account, uint256 withdrawTime);\n\n    event StakeWithdrawn(\n        address indexed account,\n        address withdrawAddress,\n        uint256 amount\n    );\n\n    /**\n     * @param deposit the entity's deposit\n     * @param staked true if this entity is staked.\n     * @param stake actual amount of ether staked for this entity.\n     * @param unstakeDelaySec minimum delay to withdraw the stake.\n     * @param withdrawTime - first block timestamp where 'withdrawStake' will be callable, or zero if already locked\n     * @dev sizes were chosen so that (deposit,staked, stake) fit into one cell (used during handleOps)\n     *    and the rest fit into a 2nd cell.\n     *    112 bit allows for 10^15 eth\n     *    48 bit for full timestamp\n     *    32 bit allows 150 years for unstake delay\n     */\n    struct DepositInfo {\n        uint112 deposit;\n        bool staked;\n        uint112 stake;\n        uint32 unstakeDelaySec;\n        uint48 withdrawTime;\n    }\n\n    //API struct used by getStakeInfo and simulateValidation\n    struct StakeInfo {\n        uint256 stake;\n        uint256 unstakeDelaySec;\n    }\n\n    /// @return info - full deposit information of given account\n    function getDepositInfo(\n        address account\n    ) external view returns (DepositInfo memory info);\n\n    /// @return the deposit (for gas payment) of the account\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * add to the deposit of the given account\n     */\n    function depositTo(address account) external payable;\n\n    /**\n     * add to the account's stake - amount and delay\n     * any pending unstake is first cancelled.\n     * @param _unstakeDelaySec the new lock duration before the deposit can be withdrawn.\n     */\n    function addStake(uint32 _unstakeDelaySec) external payable;\n\n    /**\n     * attempt to unlock the stake.\n     * the value can be withdrawn (using withdrawStake) after the unstake delay.\n     */\n    function unlockStake() external;\n\n    /**\n     * withdraw from the (unlocked) stake.\n     * must first call unlockStake and wait for the unstakeDelay to pass\n     * @param withdrawAddress the address to send withdrawn value.\n     */\n    function withdrawStake(address payable withdrawAddress) external;\n\n    /**\n     * withdraw from the deposit.\n     * @param withdrawAddress the address to send withdrawn value.\n     * @param withdrawAmount the amount to withdraw.\n     */\n    function withdrawTo(\n        address payable withdrawAddress,\n        uint256 withdrawAmount\n    ) external;\n}\n"
    },
    "contracts/aa-4337/interfaces/UserOperation.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/* solhint-disable no-inline-assembly */\n\nimport {calldataKeccak} from \"../core/Helpers.sol\";\n\n/**\n * User Operation struct\n * @param sender the sender account of this request.\n * @param nonce unique value the sender uses to verify it is not a replay.\n * @param initCode if set, the account contract will be created by this constructor/\n * @param callData the method call to execute on this account.\n * @param callGasLimit the gas limit passed to the callData method call.\n * @param verificationGasLimit gas used for validateUserOp and validatePaymasterUserOp.\n * @param preVerificationGas gas not calculated by the handleOps method, but added to the gas paid. Covers batch overhead.\n * @param maxFeePerGas same as EIP-1559 gas parameter.\n * @param maxPriorityFeePerGas same as EIP-1559 gas parameter.\n * @param paymasterAndData if set, this field holds the paymaster address and paymaster-specific data. the paymaster will pay for the transaction instead of the sender.\n * @param signature sender-verified signature over the entire request, the EntryPoint address and the chain ID.\n */\nstruct UserOperation {\n    address sender;\n    uint256 nonce;\n    bytes initCode;\n    bytes callData;\n    uint256 callGasLimit;\n    uint256 verificationGasLimit;\n    uint256 preVerificationGas;\n    uint256 maxFeePerGas;\n    uint256 maxPriorityFeePerGas;\n    bytes paymasterAndData;\n    bytes signature;\n}\n\n/**\n * Utility functions helpful when working with UserOperation structs.\n */\nlibrary UserOperationLib {\n    function getSender(\n        UserOperation calldata userOp\n    ) internal pure returns (address) {\n        address data;\n        //read sender from userOp, which is first userOp member (saves 800 gas...)\n        assembly {\n            data := calldataload(userOp)\n        }\n        return address(uint160(data));\n    }\n\n    //relayer/block builder might submit the TX with higher priorityFee, but the user should not\n    // pay above what he signed for.\n    function gasPrice(\n        UserOperation calldata userOp\n    ) internal view returns (uint256) {\n        unchecked {\n            uint256 maxFeePerGas = userOp.maxFeePerGas;\n            uint256 maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\n            if (maxFeePerGas == maxPriorityFeePerGas) {\n                //legacy mode (for networks that don't support basefee opcode)\n                return maxFeePerGas;\n            }\n            return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\n        }\n    }\n\n    function pack(\n        UserOperation calldata userOp\n    ) internal pure returns (bytes memory ret) {\n        address sender = getSender(userOp);\n        uint256 nonce = userOp.nonce;\n        bytes32 hashInitCode = calldataKeccak(userOp.initCode);\n        bytes32 hashCallData = calldataKeccak(userOp.callData);\n        uint256 callGasLimit = userOp.callGasLimit;\n        uint256 verificationGasLimit = userOp.verificationGasLimit;\n        uint256 preVerificationGas = userOp.preVerificationGas;\n        uint256 maxFeePerGas = userOp.maxFeePerGas;\n        uint256 maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\n        bytes32 hashPaymasterAndData = calldataKeccak(userOp.paymasterAndData);\n\n        return\n            abi.encode(\n                sender,\n                nonce,\n                hashInitCode,\n                hashCallData,\n                callGasLimit,\n                verificationGasLimit,\n                preVerificationGas,\n                maxFeePerGas,\n                maxPriorityFeePerGas,\n                hashPaymasterAndData\n            );\n    }\n\n    function hash(\n        UserOperation calldata userOp\n    ) internal pure returns (bytes32) {\n        return keccak256(pack(userOp));\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}\n"
    },
    "contracts/aa-4337/utils/Exec.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.5 <0.9.0;\n\n// solhint-disable no-inline-assembly\n\n/**\n * Utility functions helpful when making different kinds of contract calls in Solidity.\n */\nlibrary Exec {\n    function call(\n        address to,\n        uint256 value,\n        bytes memory data,\n        uint256 txGas\n    ) internal returns (bool success) {\n        assembly {\n            success := call(\n                txGas,\n                to,\n                value,\n                add(data, 0x20),\n                mload(data),\n                0,\n                0\n            )\n        }\n    }\n\n    function staticcall(\n        address to,\n        bytes memory data,\n        uint256 txGas\n    ) internal view returns (bool success) {\n        assembly {\n            success := staticcall(txGas, to, add(data, 0x20), mload(data), 0, 0)\n        }\n    }\n\n    function delegateCall(\n        address to,\n        bytes memory data,\n        uint256 txGas\n    ) internal returns (bool success) {\n        assembly {\n            success := delegatecall(\n                txGas,\n                to,\n                add(data, 0x20),\n                mload(data),\n                0,\n                0\n            )\n        }\n    }\n\n    // get returned data from last call or calldelegate\n    function getReturnData(\n        uint256 maxLen\n    ) internal pure returns (bytes memory returnData) {\n        assembly {\n            let len := returndatasize()\n            if gt(len, maxLen) {\n                len := maxLen\n            }\n            let ptr := mload(0x40)\n            mstore(0x40, add(ptr, add(len, 0x20)))\n            mstore(ptr, len)\n            returndatacopy(add(ptr, 0x20), 0, len)\n            returnData := ptr\n        }\n    }\n\n    // revert with explicit byte array (probably reverted info from call)\n    function revertWithData(bytes memory returnData) internal pure {\n        assembly {\n            revert(add(returnData, 32), mload(returnData))\n        }\n    }\n\n    function callAndRevert(\n        address to,\n        bytes memory data,\n        uint256 maxLen\n    ) internal {\n        bool success = call(to, 0, data, gasleft());\n        if (!success) {\n            revertWithData(getReturnData(maxLen));\n        }\n    }\n}\n"
    },
    "contracts/Barz.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {LibDiamond} from \"./libraries/LibDiamond.sol\";\nimport {IBarz} from \"./interfaces/IBarz.sol\";\n\n/**\n * @title Barz\n * @dev A diamond proxy wallet with a modular & upgradeable architecture\n * @author David Yongjun Kim (@Powerstream3604)\n */\ncontract Barz is IBarz {\n    /**\n     * @notice Initializes Barz with the given parameters. Barz account is intended to be created from Barz Factory for stable deployment.\n     * @dev This method makes a delegate call to account facet and account facet handles the initialization.\n     *      With modular architecture, Barz encompasses wide spectrum of architecture and logic.\n     *      The only requirement is account facet to comply with initialize() interface.\n     *      Barz doesn't include built-in functions and is a full proxy, for maximum extensibility and modularity.\n     * @param _accountFacet Address of Account Facet in charge of the Barz initialization\n     * @param _verificationFacet Address of Verification Facet for verifying the signature. Could be any signature scheme\n     * @param _entryPoint Address of Entry Point contract\n     * @param _facetRegistry Address of Facet Registry. Facet Registry is a registry holding trusted facets that could be added to user's wallet\n     * @param _defaultFallBack Address of Default FallBack Handler. Middleware contract for more efficient deployment\n     * @param _ownerPublicKey Bytes of Owner Public Key using for initialization\n     */\n    constructor(\n        address _accountFacet,\n        address _verificationFacet,\n        address _entryPoint,\n        address _facetRegistry,\n        address _defaultFallBack,\n        bytes memory _ownerPublicKey\n    ) payable {\n        bytes memory initCall = abi.encodeWithSignature(\n            \"initialize(address,address,address,address,bytes)\",\n            _verificationFacet,\n            _entryPoint,\n            _facetRegistry,\n            _defaultFallBack,\n            _ownerPublicKey\n        );\n        (bool success, bytes memory result) = _accountFacet.delegatecall(\n            initCall\n        );\n        if (!success || uint256(bytes32(result)) != 1) {\n            revert Barz__InitializationFailure();\n        }\n    }\n\n    /**\n     * @notice Fallback function for Barz complying with Diamond Standard with customization of adding Default Fallback Handler\n     * @dev Find facet for function that is called and execute the function if a facet is found and return any value.\n     */\n    fallback() external payable {\n        LibDiamond.DiamondStorage storage ds;\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\n        // get diamond storage\n        assembly {\n            ds.slot := position\n        }\n        // get facet from function selector\n        address facet = address(bytes20(ds.facets[msg.sig]));\n        if (facet == address(0))\n            facet = ds.defaultFallbackHandler.facetAddress(msg.sig);\n        require(facet != address(0), \"Barz: Function does not exist\");\n        // Execute external function from facet using delegatecall and return any value.\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // execute function call using the facet\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @notice Receive function to receive native token without data\n     */\n    receive() external payable {}\n}\n"
    },
    "contracts/BarzFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {Barz} from \"./Barz.sol\";\nimport {IBarzFactory} from \"./interfaces/IBarzFactory.sol\";\n\n/**\n * @title Barz Factory\n * @dev Contract to easily deploy Barz to a pre-computed address with a single call\n * @author David Yongjun Kim (@Powerstream3604)\n */\ncontract BarzFactory is IBarzFactory {\n    event BarzDeployed(address);\n\n    address public immutable accountFacet;\n    address public immutable entryPoint;\n    address public immutable facetRegistry;\n    address public immutable defaultFallback;\n\n    /**\n     * @notice Sets the initialization data for Barz contract initialization\n     * @param _accountFacet Account Facet to be used to create Barz\n     * @param _entryPoint Entrypoint contract to be used to create Barz. This uses canonical EntryPoint deployed by EF\n     * @param _facetRegistry Facet Registry to be used to create Barz\n     * @param _defaultFallback Default Fallback Handler to be used to create Barz\n     */\n    constructor(\n        address _accountFacet,\n        address _entryPoint,\n        address _facetRegistry,\n        address _defaultFallback\n    ) {\n        accountFacet = _accountFacet;\n        entryPoint = _entryPoint;\n        facetRegistry = _facetRegistry;\n        defaultFallback = _defaultFallback;\n    }\n\n    /**\n     * @notice Creates the Barz with a single call. It creates the Barz contract with the givent verification facet\n     * @param _verificationFacet Address of verification facet used for creating the barz account\n     * @param _owner Public Key of the owner to initialize barz account\n     * @param _salt Salt used for deploying barz with create2\n     * @return barz Instance of Barz contract deployed with the given parameters\n     */\n    function createAccount(\n        address _verificationFacet,\n        bytes calldata _owner,\n        uint256 _salt\n    ) external override returns (Barz barz) {\n        address addr = getAddress(_verificationFacet, _owner, _salt);\n        uint codeSize = addr.code.length;\n        if (codeSize > 0) {\n            return Barz(payable(addr));\n        }\n        barz = new Barz{salt: bytes32(_salt)}(\n            accountFacet,\n            _verificationFacet,\n            entryPoint,\n            facetRegistry,\n            defaultFallback,\n            _owner\n        );\n        emit BarzDeployed(address(barz));\n    }\n\n    /**\n     * @notice Calculates the address of Barz with the given parameters\n     * @param _verificationFacet Address of verification facet used for creating the barz account\n     * @param _owner Public Key of the owner to initialize barz account\n     * @param _salt Salt used for deploying barz with create2\n     * @return barzAddress Precalculated Barz address\n     */\n    function getAddress(\n        address _verificationFacet,\n        bytes calldata _owner,\n        uint256 _salt\n    ) public view override returns (address barzAddress) {\n        bytes memory bytecode = getBytecode(\n            accountFacet,\n            _verificationFacet,\n            entryPoint,\n            facetRegistry,\n            defaultFallback,\n            _owner\n        );\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                bytes1(0xff),\n                address(this),\n                _salt,\n                keccak256(bytecode)\n            )\n        );\n        barzAddress = address(uint160(uint256(hash)));\n    }\n\n    /**\n     * @notice Returns the bytecode of Barz with the given parameter\n     * @param _accountFacet Account Facet to be used to create Barz\n     * @param _verificationFacet Verification Facet to be used to create Barz\n     * @param _entryPoint Entrypoint contract to be used to create Barz. This uses canonical EntryPoint deployed by EF\n     * @param _facetRegistry Facet Registry to be used to create Barz\n     * @param _defaultFallback Default Fallback Handler to be used to create Barz\n     * @param _ownerPublicKey Public Key of owner to be used to initialize Barz ownership\n     * @return barzBytecode Bytecode of Barz\n     */\n    function getBytecode(\n        address _accountFacet,\n        address _verificationFacet,\n        address _entryPoint,\n        address _facetRegistry,\n        address _defaultFallback,\n        bytes calldata _ownerPublicKey\n    ) public pure override returns (bytes memory barzBytecode) {\n        bytes memory bytecode = type(Barz).creationCode;\n        barzBytecode = abi.encodePacked(\n            bytecode,\n            abi.encode(\n                _accountFacet,\n                _verificationFacet,\n                _entryPoint,\n                _facetRegistry,\n                _defaultFallback,\n                _ownerPublicKey\n            )\n        );\n    }\n\n    /**\n     * @notice Returns the creation code of the Barz contract\n     * @return creationCode Creation code of Barz\n     */\n    function getCreationCode()\n        public\n        pure\n        override\n        returns (bytes memory creationCode)\n    {\n        creationCode = type(Barz).creationCode;\n    }\n}\n"
    },
    "contracts/facets/AccountFacet.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {UserOperation} from \"../aa-4337/interfaces/UserOperation.sol\";\nimport {IEntryPoint} from \"../aa-4337/interfaces/IEntryPoint.sol\";\nimport {BaseAccount} from \"../aa-4337/core/BaseAccount.sol\";\nimport {LibAppStorage, BarzStorage} from \"../libraries/LibAppStorage.sol\";\nimport {LibDiamond} from \"../libraries/LibDiamond.sol\";\nimport {LibLoupe} from \"../libraries/LibLoupe.sol\";\nimport {IFacetRegistry} from \"../infrastructure/interfaces/IFacetRegistry.sol\";\nimport {IDiamondCut} from \"../facets/base/interfaces/IDiamondCut.sol\";\nimport {IDiamondLoupe} from \"../facets/base/interfaces/IDiamondLoupe.sol\";\nimport {IVerificationFacet} from \"./interfaces/IVerificationFacet.sol\";\nimport {IERC1271} from \"../interfaces/ERC/IERC1271.sol\";\nimport {IAccountFacet} from \"./interfaces/IAccountFacet.sol\";\n\n/**\n * @title Account Facet\n * @dev Account module contract that provides the account features and initialization of signer\n *      compatible with EIP-1271 & EIP-4337\n * @author David Yongjun Kim (@Powerstream3604)\n */\ncontract AccountFacet is BarzStorage, BaseAccount, IAccountFacet {\n    using ECDSA for bytes32;\n\n    /**\n     * @notice This constructor ensures that this contract can only be used as singleton for Proxy contracts\n     */\n    constructor() {\n        LibAppStorage.enforceAccountInitialize();\n    }\n\n    /**\n     * @notice Returns the address of EntryPoint contract registered to Barz account\n     */\n    function entryPoint() public view override returns (IEntryPoint) {\n        return s.entryPoint;\n    }\n\n    /**\n     * @notice Initializes the initial storage of the Barz contract.\n     * @dev This method can only be called during the initialization or signature migration.\n     *      If the proxy contract was created without initialization, anyone can call initialize.\n     *      Barz calls initialize in constructor in an atomic transaction during deployment\n     * @param _verificationFacet Facet contract handling the verificationi\n     * @param _anEntryPoint Entrypoint contract defined in EIP-4337 handling the flow of UserOp\n     * @param _facetRegistry Registry of Facets that hold all facet information\n     * @param _defaultFallBackHandler Middleware contract for default facets\n     * @param _ownerPublicKey Bytes of owner public key\n     */\n    function initialize(\n        address _verificationFacet,\n        address _anEntryPoint,\n        address _facetRegistry,\n        address _defaultFallBackHandler,\n        bytes calldata _ownerPublicKey\n    ) public override returns (uint256 initSuccess) {\n        LibAppStorage.enforceAccountInitialize();\n        s.entryPoint = IEntryPoint(_anEntryPoint);\n        s.facetRegistry = IFacetRegistry(_facetRegistry);\n        LibDiamond.diamondStorage().defaultFallbackHandler = IDiamondLoupe(\n            _defaultFallBackHandler\n        );\n\n        _cutDiamondAccountFacet(_verificationFacet);\n\n        bytes memory initCall = abi.encodeWithSignature(\n            \"initializeSigner(bytes)\",\n            _ownerPublicKey\n        );\n        // Every Verification Facet should comply with initializeSigner(bytes)\n        // to be compatible with the Barz contract(for initialization)\n        (bool success, bytes memory result) = _verificationFacet.delegatecall(\n            initCall\n        );\n        if (!success || uint256(bytes32(result)) != 1) {\n            revert AccountFacet__InitializationFailure();\n        }\n\n        initSuccess = 1;\n        emit AccountInitialized(s.entryPoint, _ownerPublicKey);\n    }\n\n    function _cutDiamondAccountFacet(address _verificationFacet) internal {\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1);\n\n        bytes4 ownerVerificationFuncSelector = IVerificationFacet(\n            _verificationFacet\n        ).validateOwnerSignatureSelector();\n\n        bytes4[] memory verificationFunctionSelectors = new bytes4[](3);\n        verificationFunctionSelectors[0] = IERC1271.isValidSignature.selector;\n        verificationFunctionSelectors[1] = ownerVerificationFuncSelector;\n        verificationFunctionSelectors[2] = IVerificationFacet.owner.selector;\n        cut[0] = IDiamondCut.FacetCut({\n            facetAddress: _verificationFacet,\n            action: IDiamondCut.FacetCutAction.Add,\n            functionSelectors: verificationFunctionSelectors\n        });\n\n        LibDiamond.diamondCut(cut, address(0), \"\");\n    }\n\n    /**\n     * @notice Calls the destination with inputted calldata and value from EntryPoint\n     * @dev This method executes the calldata coming from the EntryPoint.\n     *      Barz will make a call to this function for majority of typical execution(e.g. Swap, Token Transfer)\n     * @param _dest Address of destination where the call will be forwarded to\n     * @param _value Amount of native coin the owner is willing to send(e.g. ETH, BNB)\n     * @param _func Bytes of calldata to execute in the destination address\n     */\n    function execute(\n        address _dest,\n        uint256 _value,\n        bytes calldata _func\n    ) external override onlyWhenUnlocked {\n        _requireFromEntryPoint();\n        _call(_dest, _value, _func);\n    }\n\n    /**\n     * @notice Batch calls the destination with inputted calldata and value from EntryPoint\n     * @dev This method batch executes the calldata coming from the EntryPoint.\n     *      Barz will make a call to this function for majority of typical execution(e.g. Swap, Token Transfer)\n     * @param _dest Array of addresses of destination where the call will be forwarded to\n     * @param _value Array of amount of native coin the owner is willing to send(e.g. ETH, BNB)\n     * @param _func Array of bytes of calldata to execute in the destination address\n     */\n    function executeBatch(\n        address[] calldata _dest,\n        uint256[] calldata _value,\n        bytes[] calldata _func\n    ) external override onlyWhenUnlocked {\n        _requireFromEntryPoint();\n        uint256 destLength = _dest.length;\n        require(\n            destLength == _func.length && destLength == _value.length,\n            \"wrong array lengths\"\n        );\n        for (uint256 i; i < destLength; ) {\n            _call(_dest[i], _value[i], _func[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Validates the signature field of UserOperation\n     * @dev This method validates if the signature of UserOp is indeed valid by delegating the call to Verification Facet\n     *      Barz makes a call to the pre-registered Verification Facet address in App Storage\n     * @param _userOp UserOperation from owner to be validated\n     * @param _userOpHash Hash of UserOperation given from the EntryPoint contract\n     */\n    function _validateSignature(\n        UserOperation calldata _userOp,\n        bytes32 _userOpHash\n    ) internal override returns (uint256 validationData) {\n        // Get Facet with Function Selector\n        address facet = LibLoupe.facetAddress(s.validateOwnerSignatureSelector);\n        if (facet == address(0))\n            revert AccountFacet__NonExistentVerificationFacet();\n\n        // Make function call to VerificationFacet\n        bytes memory validateCall = abi.encodeWithSelector(\n            s.validateOwnerSignatureSelector,\n            _userOp,\n            _userOpHash\n        );\n        (bool success, bytes memory result) = facet.delegatecall(validateCall);\n        if (!success) revert AccountFacet__CallNotSuccessful();\n        validationData = uint256(bytes32(result));\n        if (validationData == 0) emit VerificationSuccess(_userOpHash);\n        else emit VerificationFailure(_userOpHash);\n    }\n\n    /**\n     * @notice Calls the target with the inputted value and calldata\n     * @dev This method is the actual function in Barz that makes a call with an arbitrary owner-given data\n     * @param _target Address of the destination contract which the call is getting forwarded to\n     * @param _value Amount of Native coin the owner is wanting to make in this call\n     * @param _data Calldata the owner is forwarding together in the call e.g. Swap/Token Transfer\n     */\n    function _call(\n        address _target,\n        uint256 _value,\n        bytes memory _data\n    ) internal {\n        if (_checkRestrictions(_target, _value, _data) == 1)\n            revert AccountFacet__RestrictionsFailure();\n\n        (bool success, bytes memory result) = _target.call{value: _value}(\n            _data\n        );\n        if (!success) {\n            assembly {\n                revert(add(result, 32), mload(result))\n            }\n        }\n    }\n\n    /**\n     * @notice Checks restrictions if the restrictions facet exists\n     * @dev This method checks if the restrictions facet exists and makes a verification call to an array of restrictions facet\n     * @param _target Address the call is getting forwarded to\n     * @param _value Amount of native coin the call is sending together with the call\n     * @param _data Calldata to trigger execution in target address\n     */\n    function _checkRestrictions(\n        address _target,\n        uint256 _value,\n        bytes memory _data\n    ) internal returns (uint256 result) {\n        address facet = LibDiamond.restrictionsFacet();\n        // NOTE: No restrictions facet, so restriction validation passes\n        if (facet == address(0)) return 0;\n        bytes memory call = abi.encodeWithSignature(\n            \"verifyRestrictions(address,address,uint256,bytes)\",\n            address(this),\n            _target,\n            _value,\n            _data\n        );\n        (bool success, bytes memory response) = facet.delegatecall(call);\n        if (!success) revert AccountFacet__RestrictionsFailure();\n        result = uint256(bytes32(response));\n    }\n}\n"
    },
    "contracts/facets/AccountRecoveryFacet.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {SignatureChecker} from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport {LibAppStorage} from \"../libraries/LibAppStorage.sol\";\nimport {LibDiamond} from \"../libraries/LibDiamond.sol\";\nimport {LibLoupe} from \"../libraries/LibLoupe.sol\";\nimport {LibGuardian} from \"../libraries/LibGuardian.sol\";\nimport {LibFacetStorage, RecoveryStorage, RecoveryConfig, RecoveryApprovalConfig, ApprovalConfig} from \"../libraries/LibFacetStorage.sol\";\nimport {Modifiers} from \"./Modifiers.sol\";\nimport {ISecurityManager} from \"../infrastructure/interfaces/ISecurityManager.sol\";\nimport {IVerificationFacet} from \"./interfaces/IVerificationFacet.sol\";\nimport {IAccountRecoveryFacet} from \"./interfaces/IAccountRecoveryFacet.sol\";\n\n/**\n * @title Account Recovery Facet\n * @dev Contract that enables recovery of accounts when owner key is unavailable\n * @author David Yongjun Kim (@Powerstream3604)\n */\ncontract AccountRecoveryFacet is IAccountRecoveryFacet, Modifiers {\n    ISecurityManager public immutable securityManager;\n\n    /**\n     * @notice This constructor sets the Security Manager address which is an immutable variable.\n     *         Immutable variables do not impact the storage of diamond\n     * @param _securityManager Security Manager contract that holds the security related variables for all wallets\n     */\n    constructor(address _securityManager) {\n        securityManager = ISecurityManager(_securityManager);\n    }\n\n    /**\n     * @notice Approve recovery of account as guardian\n     * @dev This method can only be called by guardian and guardian inputs the public key of the new owner\n     *      When the threshold(majority of guardians) passes, it automatically executes account recovery\n     * @param _recoveryPublicKey Bytes of newly recovered public key of the owner\n     */\n    function approveAccountRecovery(\n        bytes calldata _recoveryPublicKey\n    ) external override onlyGuardian {\n        RecoveryApprovalConfig storage rs = LibFacetStorage\n            .recoveryStorage()\n            .recoveryApprovalConfigs[INNER_STRUCT];\n        validateNewOwner(_recoveryPublicKey);\n        bytes32 recoveryPublicKeyHash = getApprovalRecoveryKeyHash(\n            _recoveryPublicKey,\n            \"ExecuteRecovery\"\n        );\n        uint64 approvalValidUntil = uint64(\n            block.timestamp + _getApprovalValidationPeriod()\n        );\n        rs.isNewOwnerApproved[recoveryPublicKeyHash][\n            msg.sender\n        ] = ApprovalConfig(true, approvalValidUntil);\n        emit RecoveryApproved(\n            _recoveryPublicKey,\n            msg.sender,\n            approvalValidUntil\n        );\n        if (\n            getRecoveryApprovalCountWithTimeValidity(recoveryPublicKeyHash) >=\n            LibGuardian.majorityOfGuardians()\n        ) _executeRecovery(_recoveryPublicKey);\n    }\n\n    /**\n     * @notice Revoke recovery of account as guardian\n     * @dev This method can only be called by guardian and guardian inputs the public key of the new owner\n            When the threshold(majority of guardians) passes, it automatically revokes account recovery when recovery is pending\n     * @param _recoveryPublicKey Bytes of newly recovered public key of the owner\n     */\n    function revokeAccountRecoveryApproval(\n        bytes calldata _recoveryPublicKey\n    ) external override onlyGuardian {\n        RecoveryApprovalConfig storage rs = LibFacetStorage\n            .recoveryStorage()\n            .recoveryApprovalConfigs[INNER_STRUCT];\n        validateNewOwner(_recoveryPublicKey);\n        bytes32 recoveryPublicKeyHash = getApprovalRecoveryKeyHash(\n            _recoveryPublicKey,\n            \"ExecuteRecovery\"\n        );\n        if (\n            !rs\n            .isNewOwnerApproved[recoveryPublicKeyHash][msg.sender].isApproved ||\n            !(block.timestamp <\n                rs\n                .isNewOwnerApproved[recoveryPublicKeyHash][msg.sender]\n                    .validUntil)\n        ) revert AccountRecoveryFacet__NonExistentApproval();\n\n        rs.isNewOwnerApproved[recoveryPublicKeyHash][\n            msg.sender\n        ] = ApprovalConfig(false, 0);\n        emit RecoveryApprovalRevoked(_recoveryPublicKey, msg.sender);\n    }\n\n    /**\n     * @notice Executes recovery with signatures or on-chain pre-approvals\n     * @dev This method validates the signatures of guardians or checks the on-chain pre-approved calls to check if the threshold passes\n     *      When the threshold passes, account recovery is executed and revert otherwise\n     * @param _recoveryPublicKey Bytes of newly recovered public key of the owner\n     * @param _guardians Array of guardians address that are approving the recovery of Account\n     * @param _signatures Array of signature bytes that signed the approval hash\n     */\n    function executeRecovery(\n        bytes calldata _recoveryPublicKey,\n        address[] calldata _guardians,\n        bytes[] calldata _signatures\n    ) external override {\n        if (_isRecoveryPending())\n            revert AccountRecoveryFacet__RecoveryAlreadyOngoing();\n        uint256 guardiansLength = _guardians.length;\n        if (guardiansLength != _signatures.length)\n            revert AccountRecoveryFacet__InvalidArrayLength();\n        validateNewOwner(_recoveryPublicKey);\n\n        bytes32 recoveryPublicKeyHash = getApprovalRecoveryKeyHash(\n            _recoveryPublicKey,\n            \"ExecuteRecovery\"\n        );\n\n        _checkApprover(_guardians);\n        _checkDuplicateOnChainApprover(recoveryPublicKeyHash, _guardians);\n\n        if (\n            guardiansLength +\n                getRecoveryApprovalCountWithTimeValidity(\n                    recoveryPublicKeyHash\n                ) <\n            LibGuardian.majorityOfGuardians()\n        ) revert AccountRecoveryFacet__InsufficientGuardians();\n        for (uint256 i; i < guardiansLength; ) {\n            if (!LibGuardian.isGuardian(_guardians[i]))\n                revert AccountRecoveryFacet__InvalidGuardian();\n            if (\n                !SignatureChecker.isValidSignatureNow(\n                    _guardians[i],\n                    recoveryPublicKeyHash,\n                    _signatures[i]\n                )\n            ) revert AccountRecoveryFacet__InvalidGuardianSignature();\n            unchecked {\n                ++i;\n            }\n        }\n        _executeRecovery(_recoveryPublicKey);\n    }\n\n    /**\n     * @notice Executes recovery of the account. Note that execution and finalization is a different process\n     * @dev Executes the recovery and adds recovery data to recovery configuration. Locks the account\n     * @param _recoveryPublicKey Public Key of the account for recovery\n     */\n    function _executeRecovery(bytes memory _recoveryPublicKey) internal {\n        RecoveryStorage storage rs = LibFacetStorage.recoveryStorage();\n        ++rs.nonce;\n        uint64 executeAfter = uint64(block.timestamp + _getRecoveryPeriod());\n        rs.recoveryConfigs[INNER_STRUCT] = RecoveryConfig(\n            _recoveryPublicKey,\n            executeAfter // NOTE: Remove guardian Count\n        );\n        LibAppStorage.setLock(\n            block.timestamp + _getLockPeriod(),\n            AccountRecoveryFacet.executeRecovery.selector\n        );\n        emit RecoveryExecuted(_recoveryPublicKey, executeAfter);\n    }\n\n    /**\n     * @notice Finalize recovery after recovery pending period. Recovery pending period can be set by user beforehand in SecurityManager\n     * @dev This method finalizes recovery and fully changes the ownership of the account to the newly inputted recovery public key\n     */\n    function finalizeRecovery() external override {\n        RecoveryStorage storage rs = LibFacetStorage.recoveryStorage();\n\n        if (!_isRecoveryPending())\n            revert AccountRecoveryFacet__NonexistentRecovery();\n        if (\n            uint64(block.timestamp) <=\n            rs.recoveryConfigs[INNER_STRUCT].executeAfter\n        ) revert AccountRecoveryFacet__RecoveryPeriodNotOver();\n        bytes memory recoveryOwner = rs\n            .recoveryConfigs[INNER_STRUCT]\n            .recoveryPublicKey;\n\n        delete rs.recoveryConfigs[INNER_STRUCT];\n\n        LibAppStorage.setLock(0, bytes4(0));\n\n        LibAppStorage.initiateSignerMigration();\n        address verificationFacet = address(\n            bytes20(\n                LibDiamond.diamondStorage().facets[\n                    s.validateOwnerSignatureSelector\n                ]\n            )\n        );\n        bytes memory uninitCall = abi.encodeWithSignature(\n            \"uninitializeSigner()\"\n        );\n        (bool success, bytes memory result) = verificationFacet.delegatecall(\n            uninitCall\n        );\n        if (!success) revert AccountRecoveryFacet__CallNotSuccesful();\n        uint256 validationData = uint256(bytes32(result));\n        if (validationData != 1)\n            revert AccountRecoveryFacet__SignerUninitializationFailure();\n        bytes memory initCall = abi.encodeWithSignature(\n            \"initializeSigner(bytes)\",\n            recoveryOwner\n        );\n        (success, result) = verificationFacet.delegatecall(initCall);\n        if (!success) revert AccountRecoveryFacet__CallNotSuccesful();\n        validationData = uint256(bytes32(result));\n        if (validationData != 1)\n            revert AccountRecoveryFacet__SignerInitializationFailure();\n        LibAppStorage.finalizeSignerMigration();\n        emit RecoveryFinalized(recoveryOwner);\n    }\n\n    /**\n     * @notice Approves the cancellation of recovery\n     * @dev This method approves the cancellation of recovery when recovery is still pending - waiting for finalization\n     * @param _recoveryPublicKey Bytes of public key which is pending for recovery\n     */\n    function approveCancelRecovery(\n        bytes calldata _recoveryPublicKey\n    ) external override onlyGuardian {\n        RecoveryApprovalConfig storage rs = LibFacetStorage\n            .recoveryStorage()\n            .recoveryApprovalConfigs[INNER_STRUCT];\n        validateNewOwner(_recoveryPublicKey);\n        bytes32 recoveryPublicKeyHash = getApprovalRecoveryKeyHash(\n            _recoveryPublicKey,\n            \"CancelRecovery\"\n        );\n        uint64 approvalValidUntil = uint64(\n            block.timestamp + _getApprovalValidationPeriod()\n        );\n        rs.isNewOwnerApproved[recoveryPublicKeyHash][\n            msg.sender\n        ] = ApprovalConfig(true, approvalValidUntil);\n        emit RecoveryCancellationApproved(_recoveryPublicKey, msg.sender);\n        if (\n            getRecoveryApprovalCountWithTimeValidity(recoveryPublicKeyHash) >=\n            LibGuardian.majorityOfGuardians()\n        ) {\n            _cancelRecovery(_recoveryPublicKey);\n        }\n    }\n\n    /**\n     * @notice Hardstops an ongoing recovery\n     * @dev This method provides a safety mechanism to protect owners of malicious guardians.\n     *      Owners can hardstop recovery when an malicious guardians starts the recovery process.\n     * @param _signature Signature of the owner that signs the hash to hardstop recovery\n     */\n    function hardstopRecovery(bytes calldata _signature) external override {\n        if (!_isRecoveryPending())\n            revert AccountRecoveryFacet__NonexistentRecovery();\n        bytes32 recoveryPublicKeyHash = getApprovalRecoveryKeyHash(\n            \"0\",\n            \"HardstopRecovery\"\n        );\n        if (\n            !SignatureChecker.isValidSignatureNow(\n                address(this),\n                recoveryPublicKeyHash,\n                _signature\n            )\n        ) revert AccountRecoveryFacet__InvalidOwnerSignature();\n        RecoveryStorage storage rs = LibFacetStorage.recoveryStorage();\n        ++rs.nonce;\n        delete rs.recoveryConfigs[INNER_STRUCT];\n        LibAppStorage.setLock(0, bytes4(0));\n        emit RecoveryHardstopped();\n    }\n\n    /**\n     * @notice Cancels recovery with signatures or on-chain pre-approvals\n     * @dev This method validates the signatures of guardians or checks the on-chain pre-approved calls to check if the threshold passes\n     *      When the threshold passes, account recovery is canceled and revert otherwise\n     * @param _recoveryPublicKey Bytes of newly recovered public key of the owner\n     * @param _guardians Array of guardians address that are approving the recovery of Account\n     * @param _signatures Array of signature bytes that signed the cancellation approval hash\n     */\n    function cancelRecovery(\n        bytes calldata _recoveryPublicKey,\n        address[] calldata _guardians,\n        bytes[] calldata _signatures\n    ) external override {\n        uint256 guardiansLength = _guardians.length;\n        if (guardiansLength != _signatures.length)\n            revert AccountRecoveryFacet__InvalidArrayLength();\n        validateNewOwner(_recoveryPublicKey);\n\n        bytes32 recoveryPublicKeyHash = getApprovalRecoveryKeyHash(\n            _recoveryPublicKey,\n            \"CancelRecovery\"\n        );\n\n        _checkApprover(_guardians);\n        _checkDuplicateOnChainApprover(recoveryPublicKeyHash, _guardians);\n\n        if (\n            guardiansLength +\n                getRecoveryApprovalCountWithTimeValidity(\n                    recoveryPublicKeyHash\n                ) <\n            LibGuardian.majorityOfGuardians()\n        ) revert AccountRecoveryFacet__InsufficientGuardians();\n        for (uint256 i; i < guardiansLength; ) {\n            if (!LibGuardian.isGuardian(_guardians[i]))\n                revert AccountRecoveryFacet__CallerNotGuardian();\n            if (\n                !SignatureChecker.isValidSignatureNow(\n                    _guardians[i],\n                    recoveryPublicKeyHash,\n                    _signatures[i]\n                )\n            ) revert AccountRecoveryFacet__InvalidGuardianSignature();\n            unchecked {\n                ++i;\n            }\n        }\n        _cancelRecovery(_recoveryPublicKey);\n    }\n\n    /**\n     * @notice Cancel recovery when the recovery is pending. Unlock the account as well\n     * @dev This method checks if the recovery is pending and reverts if not pending.\n     *      It increases the recovery nonce and deletes the recovery information and gets a small portion of gas in return\n     * @param _recoveryPublicKey Bytes of newly recovered public key of the owner\n     */\n    function _cancelRecovery(bytes memory _recoveryPublicKey) internal {\n        if (!_isRecoveryPending())\n            revert AccountRecoveryFacet__NonexistentRecovery();\n        LibAppStorage.setLock(0, bytes4(0));\n        RecoveryStorage storage rs = LibFacetStorage.recoveryStorage();\n        ++rs.nonce;\n        delete rs.recoveryConfigs[INNER_STRUCT];\n        emit RecoveryCanceled(_recoveryPublicKey);\n    }\n\n    /**\n     * @notice Validates the format of public key to be used for recovery\n     * @dev This method checks if the public key format is correct and reverts otherwise\n     * @param _recoveryPublicKey Bytes of newly recovered public key of the owner\n     */\n    function validateNewOwner(bytes memory _recoveryPublicKey) public view {\n        if (\n            !IVerificationFacet(\n                LibLoupe.facetAddress(s.validateOwnerSignatureSelector)\n            ).isValidKeyType(_recoveryPublicKey)\n        ) revert AccountRecoveryFacet__InvalidRecoveryPublicKey();\n    }\n\n    /**\n     * @notice Checks if recovery is currently pending\n     * @return isPending Boolean indicating if recovery is pending\n     */\n    function _isRecoveryPending() internal view returns (bool isPending) {\n        RecoveryStorage storage rs = LibFacetStorage.recoveryStorage();\n        isPending = (rs.recoveryConfigs[INNER_STRUCT].executeAfter > 0);\n    }\n\n    /**\n     * @notice Calculate the recovery hash dependent on chain, wallet address, nonce with EIP-191 prefix for safety\n     * @dev Returns the keccak256 hash of EIP-191 msg hash packed with public key, salt, nonce, wallet address, etc\n     * @param _recoveryPublicKey Bytes of newly recovered public key of the owner\n     * @param _saltString Salt string to uniquely identify each recovery hash and for security\n     * @return recoveryKeyHash Bytes32 string of the recovery hash\n     */\n    function getApprovalRecoveryKeyHash(\n        bytes memory _recoveryPublicKey,\n        string memory _saltString\n    ) public view override returns (bytes32 recoveryKeyHash) {\n        recoveryKeyHash = keccak256(\n            abi.encodePacked(\n                \"\\x19Ethereum Signed Message:\\n32\",\n                keccak256(\n                    abi.encode(\n                        _recoveryPublicKey,\n                        _saltString,\n                        address(this),\n                        block.chainid,\n                        LibFacetStorage.recoveryStorage().nonce\n                    )\n                )\n            )\n        );\n    }\n\n    /**\n     * @notice Check the onchain approval of guardians and returns the number of guardians that approved\n     * @dev Loop through the guardian addresses and returns the number of guardians that approved this recovery hash\n     * @param _recoveryPublicKeyHash Bytes hash of newly recovered public key and recovery value of the account\n     * @return approvalCount Number of guardians that approved\n     */\n    function getRecoveryApprovalCountWithTimeValidity(\n        bytes32 _recoveryPublicKeyHash\n    ) public view override returns (uint256 approvalCount) {\n        address[] memory guardians = LibGuardian.getGuardians();\n        uint256 guardianLength = guardians.length;\n        for (uint256 i; i < guardianLength; ) {\n            if (isRecoveryApproved(_recoveryPublicKeyHash, guardians[i])) {\n                unchecked {\n                    ++approvalCount;\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Checks if the recovery is approved by the given approver\n     * @param _recoveryPublicKeyHash Hash of the public key and configuration for recovery\n     * @param _approver Address of approver\n     * @return isApproved Bool value if recovery hash is approved\n     */\n    function isRecoveryApproved(\n        bytes32 _recoveryPublicKeyHash,\n        address _approver\n    ) public view override returns (bool isApproved) {\n        RecoveryApprovalConfig storage rs = LibFacetStorage\n            .recoveryStorage()\n            .recoveryApprovalConfigs[INNER_STRUCT];\n        if (\n            rs\n            .isNewOwnerApproved[_recoveryPublicKeyHash][_approver].isApproved &&\n            block.timestamp <\n            rs.isNewOwnerApproved[_recoveryPublicKeyHash][_approver].validUntil\n        ) {\n            isApproved = true;\n        }\n    }\n\n    /**\n     * @notice Checks if their is duplicate approver is included in off-chain approval verification and on-chain approval\n     *         Approvers who approved on-chain should not be included in the off-chain approval\n     * @param _recoveryPublicKeyHash Hash of recovery information\n     * @param _approvers List of approver addresses\n     */\n    function _checkDuplicateOnChainApprover(\n        bytes32 _recoveryPublicKeyHash,\n        address[] memory _approvers\n    ) public view {\n        address[] memory guardians = LibGuardian.getGuardians();\n        uint256 guardianLength = guardians.length;\n        uint256 approversLength = _approvers.length;\n        for (uint256 i; i < guardianLength; ) {\n            if (isRecoveryApproved(_recoveryPublicKeyHash, guardians[i])) {\n                for (uint256 j; j < approversLength; ) {\n                    if (_approvers[j] == guardians[i])\n                        revert AccountRecoveryFacet__DuplicateApproval();\n                    unchecked {\n                        ++j;\n                    }\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Returns the lock period of this wallet address from security manager\n     * @return lockPeriod value of lock period\n     */\n    function _getLockPeriod() internal view returns (uint256 lockPeriod) {\n        lockPeriod = securityManager.lockPeriodOf(address(this));\n        if (lockPeriod == 0) revert AccountRecoveryFacet__InvalidLockPeriod();\n    }\n\n    /**\n     * @notice Returns the lock period of this wallet address from security manager\n     * @return recoveryPeriod value of recovery period\n     */\n    function _getRecoveryPeriod()\n        internal\n        view\n        returns (uint256 recoveryPeriod)\n    {\n        recoveryPeriod = securityManager.recoveryPeriodOf(address(this));\n        if (recoveryPeriod == 0)\n            revert AccountRecoveryFacet__InvalidRecoveryPeriod();\n    }\n\n    /**\n     * @notice Returns the approval validation period of this wallet address from security manager\n     * @return approvalValidationPeriod value of approval validation period\n     */\n    function _getApprovalValidationPeriod()\n        internal\n        view\n        returns (uint256 approvalValidationPeriod)\n    {\n        approvalValidationPeriod = securityManager.approvalValidationPeriodOf(\n            address(this)\n        );\n        if (approvalValidationPeriod == 0)\n            revert AccountRecoveryFacet__InvalidApprovalValidationPeriod();\n    }\n\n    /**\n     * @notice Returns the recovery nonce of this wallet address from security manager\n     * @return nonce value of recovery nonce\n     */\n    function getRecoveryNonce() public view override returns (uint128 nonce) {\n        nonce = LibFacetStorage.recoveryStorage().nonce;\n    }\n\n    /**\n     * @notice Returns the recovery information of the pending recovery\n     * @return recoveryConfig value struct of pending recovery\n     */\n    function getPendingRecovery()\n        public\n        view\n        override\n        returns (RecoveryConfig memory recoveryConfig)\n    {\n        recoveryConfig = LibFacetStorage.recoveryStorage().recoveryConfigs[\n            INNER_STRUCT\n        ];\n    }\n}\n"
    },
    "contracts/facets/base/DiamondCutFacet.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {LibDiamond} from \"../../libraries/LibDiamond.sol\";\nimport {LibGuardian} from \"../../libraries/LibGuardian.sol\";\nimport {ISecurityManager} from \"../../infrastructure/interfaces/ISecurityManager.sol\";\nimport {SignatureChecker} from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport {LibFacetStorage, DiamondCutApprovalConfig, ApprovalConfig} from \"../../libraries/LibFacetStorage.sol\";\nimport {Modifiers} from \"../Modifiers.sol\";\nimport {IDiamondCut} from \"./interfaces/IDiamondCut.sol\";\n\n/**\n * @title DiamondCut Facet\n * @dev Responsible for adding/removing/replace facets in Barz\n * @author David Yongjun Kim (@Powerstream3604)\n */\ncontract DiamondCutFacet is Modifiers, IDiamondCut {\n    ISecurityManager public immutable securityManager;\n\n    /**\n     * @notice This constructor sets the Security Manager address which is an immutable variable.\n     *         Immutable variables do not impact the storage of diamond\n     * @param _securityManager Security Manager contract that holds the security related variables for all wallets\n     */\n    constructor(address _securityManager) {\n        securityManager = ISecurityManager(_securityManager);\n    }\n\n    /**\n     * @notice Updates the flag for the interfaceId\n     * @param _interfaceId InterfaceID to update the mapping\n     * @param _flag Bool value to update the mapping of the given interface ID\n     */\n    function updateSupportsInterface(\n        bytes4 _interfaceId,\n        bool _flag\n    ) external override onlyWhenUnlocked {\n        LibDiamond.enforceIsSelf();\n        LibDiamond.diamondStorage().supportedInterfaces[_interfaceId] = _flag;\n        emit SupportsInterfaceUpdated(_interfaceId, _flag);\n    }\n\n    /**\n     * @notice Add/replace/remove any number of functions and optionally execute\n     *         a function with delegatecall when guardians don't exist\n     * @param _diamondCut Contains the facet addresses and function selectors\n     * @param _init The address of the contract or facet to execute _calldata\n     * @param _calldata A function call, including function selector and arguments\n     *                  _calldata is executed with delegatecall on _init\n     */\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external override onlyWhenUnlocked {\n        LibDiamond.enforceIsSelf();\n\n        _checkFacetCutValidity(_diamondCut);\n        // require approval from guardian if guardian exists\n        if (0 != LibGuardian.guardianCount())\n            revert DiamondCutFacet__InvalidRouteWithGuardian();\n\n        ++LibFacetStorage.diamondCutStorage().nonce;\n        LibDiamond.diamondCut(_diamondCut, _init, _calldata);\n    }\n\n    /**\n     * @notice Add/replace/remove any number of functions and optionally execute\n     *         a function with delegatecall when guardians exist\n     * @param _diamondCut Contains the facet addresses and function selectors\n     * @param _init The address of the contract or facet to execute _calldata\n     * @param _calldata A function call, including function selector and arguments\n     *                  _calldata is executed with delegatecall on _init\n     * @param _approvers Guardian or owner address that approves the diamond cut\n     * @param _signatures Signature of Guardians or owner that approves the diamond cut\n     */\n    function diamondCutWithGuardian(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata,\n        address[] calldata _approvers,\n        bytes[] calldata _signatures\n    ) external override onlyWhenUnlocked {\n        uint256 approverLength = _approvers.length;\n        if (approverLength != _signatures.length)\n            revert DiamondCutFacet__InvalidArrayLength();\n        _checkFacetCutValidity(_diamondCut);\n        if (0 == LibGuardian.guardianCount())\n            revert DiamondCutFacet__InvalidRouteWithGuardian();\n\n        bytes32 cutHash = getDiamondCutHash(_diamondCut, _init, _calldata);\n\n        _checkApprover(_approvers);\n        _checkDuplicateOnChainApprover(cutHash, _approvers);\n\n        bool onChainOwnerApproval = getOwnerCutApprovalWithTimeValidity(\n            cutHash\n        );\n\n        uint256 threshold = onChainOwnerApproval ? 0 : 1;\n        if (\n            approverLength +\n                getDiamondCutApprovalCountWithTimeValidity(cutHash) <\n            LibGuardian.majorityOfGuardians() + threshold\n        ) revert DiamondCutFacet__InsufficientApprovers();\n\n        bool ownerApproved;\n        for (uint256 i; i < approverLength; ) {\n            if (\n                !LibGuardian.isGuardian(_approvers[i]) &&\n                _approvers[i] != address(this)\n            ) revert DiamondCutFacet__InvalidApprover();\n            if (_approvers[i] == address(this)) {\n                if (onChainOwnerApproval)\n                    revert DiamondCutFacet__OwnerAlreadyApproved();\n                ownerApproved = true;\n            }\n            if (\n                !SignatureChecker.isValidSignatureNow(\n                    _approvers[i],\n                    cutHash,\n                    _signatures[i]\n                )\n            ) revert DiamondCutFacet__InvalidApproverSignature();\n            unchecked {\n                ++i;\n            }\n        }\n        if (!ownerApproved && !onChainOwnerApproval)\n            revert DiamondCutFacet__LackOfOwnerApproval();\n\n        ++LibFacetStorage.diamondCutStorage().nonce;\n        LibDiamond.diamondCut(_diamondCut, _init, _calldata);\n    }\n\n    /**\n     * @notice Approves diamond cut. This can only be called directly from guardian or owner\n     * @param _diamondCut Contains the facet addresses and function selectors\n     * @param _init The address of the contract or facet to execute _calldata\n     * @param _calldata A function call, including function selector and arguments\n     *                  _calldata is executed with delegatecall on _init\n     */\n    function approveDiamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) public override onlyGuardianOrOwner onlyWhenUnlocked {\n        if (LibGuardian.guardianCount() == 0)\n            revert DiamondCutFacet__InvalidRouteWithoutGuardian();\n        DiamondCutApprovalConfig storage ds = LibFacetStorage\n            .diamondCutStorage()\n            .diamondCutApprovalConfigs[INNER_STRUCT];\n        _checkFacetCutValidity(_diamondCut);\n\n        bytes32 cutHash = getDiamondCutHash(_diamondCut, _init, _calldata);\n        uint64 approvalValidUntil = uint64(\n            block.timestamp + getApprovalValidationPeriod()\n        );\n        ds.isDiamondCutApproved[cutHash][msg.sender] = ApprovalConfig(\n            true,\n            approvalValidUntil\n        );\n        emit DiamondCutApproved(_diamondCut, _init, _calldata);\n        if (\n            (getDiamondCutApprovalCountWithTimeValidity(cutHash) >=\n                LibGuardian.majorityOfGuardians()) &&\n            getOwnerCutApprovalWithTimeValidity(cutHash)\n        ) {\n            ++LibFacetStorage.diamondCutStorage().nonce;\n            LibDiamond.diamondCut(_diamondCut, _init, _calldata);\n        }\n    }\n\n    /**\n     * @notice Revokes the approval of diamond cut. This can only be called directly from guardian or owner\n     * @param _diamondCut Contains the facet addresses and function selectors\n     * @param _init The address of the contract or facet to execute _calldata\n     * @param _calldata A function call, including function selector and arguments\n     *                  _calldata is executed with delegatecall on _init\n     */\n    function revokeDiamondCutApproval(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) public override onlyGuardianOrOwner onlyWhenUnlocked {\n        DiamondCutApprovalConfig storage ds = LibFacetStorage\n            .diamondCutStorage()\n            .diamondCutApprovalConfigs[INNER_STRUCT];\n        bytes32 cutHash = getDiamondCutHash(_diamondCut, _init, _calldata);\n        if (!ds.isDiamondCutApproved[cutHash][msg.sender].isApproved)\n            revert DiamondCutFacet__CannotRevokeUnapproved();\n        ds.isDiamondCutApproved[cutHash][msg.sender] = ApprovalConfig(false, 0);\n        emit DiamondCutApprovalRevoked(_diamondCut, _init, _calldata);\n    }\n\n    /**\n     * @notice Gets the number of approvals of diamond cut from guardians\n     * @param _diamondCutHash Hash of diamondCut information including the facet addresses and function selectors\n     */\n    function getDiamondCutApprovalCountWithTimeValidity(\n        bytes32 _diamondCutHash\n    ) public view override returns (uint256 approvalCount) {\n        address[] memory guardians = LibGuardian.getGuardians();\n        uint256 guardiansLength = guardians.length;\n        for (uint256 i; i < guardiansLength; ) {\n            if (isCutApproved(_diamondCutHash, guardians[i])) {\n                unchecked {\n                    ++approvalCount;\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return approvalCount;\n    }\n\n    /**\n     * @notice Returns if the owner has approved the diamond cut\n     * @param _diamondCutHash Hash of diamondCut information including the facet addresses and function selectors\n     * @return isApprovedByOwner Bool value showing if the owner approved the cut\n     */\n    function getOwnerCutApprovalWithTimeValidity(\n        bytes32 _diamondCutHash\n    ) public view override returns (bool isApprovedByOwner) {\n        isApprovedByOwner = isCutApproved(_diamondCutHash, address(this));\n    }\n\n    /**\n     * @notice Returns if the given approver has approved the diamond cut\n     * @param _diamondCutHash Hash of diamondCut information including the facet addresses and function selectors\n     * @param _approver Address of approver\n     * @return isApproved Bool value showing if the approver approved the cut\n     */\n    function isCutApproved(\n        bytes32 _diamondCutHash,\n        address _approver\n    ) public view override returns (bool isApproved) {\n        DiamondCutApprovalConfig storage ds = LibFacetStorage\n            .diamondCutStorage()\n            .diamondCutApprovalConfigs[INNER_STRUCT];\n        isApproved = (ds\n        .isDiamondCutApproved[_diamondCutHash][_approver].isApproved &&\n            block.timestamp <\n            ds.isDiamondCutApproved[_diamondCutHash][_approver].validUntil);\n    }\n\n    /**\n     * @notice Checks if their is duplicate approver is included in off-chain approval verification and on-chain approval\n     *         Approvers who approved on-chain should not be included in the off-chain approval\n     * @param _diamondCutHash Hash of diamondCut information including the facet addresses and function selectors\n     * @param _approvers List of approver addresses\n     */\n    function _checkDuplicateOnChainApprover(\n        bytes32 _diamondCutHash,\n        address[] memory _approvers\n    ) public view {\n        address[] memory guardians = LibGuardian.getGuardians();\n        uint256 guardianLength = guardians.length;\n        uint256 approversLength = _approvers.length;\n        for (uint256 i; i < guardianLength; ) {\n            if (isCutApproved(_diamondCutHash, guardians[i])) {\n                for (uint256 j; j < approversLength; ) {\n                    if (_approvers[j] == guardians[i])\n                        revert DiamondCutFacet__DuplicateApproval();\n                    unchecked {\n                        ++j;\n                    }\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Returns the diamond cut hash. This function ensures that this hash is safe from replay attack by including\n     *         salt, address, chainId, and nonce, etc.\n     * @param _diamondCut Contains the facet addresses and function selectors\n     * @param _init The address of the contract or facet to execute _calldata\n     * @param _calldata A function call, including function selector and arguments\n     *                  _calldata is executed with delegatecall on _init\n     * @return cutHash Diamond Cut Hash\n     */\n    function getDiamondCutHash(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) public view override returns (bytes32 cutHash) {\n        cutHash = keccak256(\n            abi.encodePacked(\n                \"\\x19Ethereum Signed Message:\\n32\",\n                keccak256(\n                    abi.encode(\n                        keccak256(abi.encode(_diamondCut)),\n                        _init,\n                        _calldata,\n                        address(this),\n                        block.chainid,\n                        LibFacetStorage.diamondCutStorage().nonce\n                    )\n                )\n            )\n        );\n    }\n\n    /**\n     * @notice Returns the approval validation Period\n     * @dev This method fetches the validation period from the security manager\n     * @return approvalValidationPeriod Approval validation period of Barz contract fetched from security manager\n     */\n    function getApprovalValidationPeriod()\n        internal\n        view\n        returns (uint256 approvalValidationPeriod)\n    {\n        approvalValidationPeriod = securityManager.approvalValidationPeriodOf(\n            address(this)\n        );\n        if (approvalValidationPeriod <= 0)\n            revert DiamondCutFacet__InvalidApprovalValidationPeriod();\n    }\n\n    /**\n     * @notice Returns the diamond cut nonce of this wallet\n     * @dev This method fetches the nonce from diamond cut storage\n     * @return cutNonce Nonce of diamond cut to protect from reply attacks\n     */\n    function getDiamondCutNonce()\n        public\n        view\n        override\n        returns (uint128 cutNonce)\n    {\n        cutNonce = LibFacetStorage.diamondCutStorage().nonce;\n    }\n}\n"
    },
    "contracts/facets/base/DiamondLoupeFacet.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {IERC777Recipient} from \"@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol\";\nimport {IERC165} from \"../../interfaces/ERC/IERC165.sol\";\nimport {IERC1271} from \"../../interfaces/ERC/IERC1271.sol\";\nimport {IERC677Receiver} from \"../../interfaces/ERC/IERC677Receiver.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {IERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport {LibDiamond} from \"../../libraries/LibDiamond.sol\";\nimport {LibLoupe} from \"../../libraries/LibLoupe.sol\";\nimport {LibUtils} from \"../../libraries/LibUtils.sol\";\nimport {IDiamondCut} from \"../../facets/base/interfaces/IDiamondCut.sol\";\nimport {IStorageLoupe} from \"./interfaces/IStorageLoupe.sol\";\nimport {IDiamondLoupe} from \"./interfaces/IDiamondLoupe.sol\";\n\n/**\n * @title DiamondLoupe Facet\n * @dev DiamondLoupe contract compatible with EIP-2535\n * @author David Yongjun Kim (@Powerstream3604)\n */\ncontract DiamondLoupeFacet is IDiamondLoupe, IStorageLoupe, IERC165 {\n    // Diamond Loupe Functions\n    ////////////////////////////////////////////////////////////////////\n    /// These functions are expected to be called frequently by tools off-chain.\n\n    /**\n     * @notice Gets all facets and their selectors.\n     * @dev Barz uses a special architecture called default fallback handler. Default Fallback handler is used as a middleware\n     *      that holds the mapping of facet function selector and facet address that Barz uses. This helps Barz to reduce\n     *      significant amount of gas during the initialization process.\n     *      Hence, this method aggregates both the facet information from DefaulFallbackHandler and in diamond storage and shows the data to users.\n     * @return facets_ Facet\n     */\n    function facets() public view override returns (Facet[] memory facets_) {\n        Facet[] memory defaultFacet = LibDiamond\n            .diamondStorage()\n            .defaultFallbackHandler\n            .facets();\n        Facet[] memory _facets = LibLoupe.facets();\n        uint256 numFacets = _facets.length;\n        bytes4[] memory keys;\n        address[] memory values;\n        for (uint256 i; i < numFacets; ) {\n            uint256 selectorsLength = _facets[i].functionSelectors.length;\n            for (uint256 j; j < selectorsLength; ) {\n                (keys, values) = LibUtils.setValue(\n                    keys,\n                    values,\n                    _facets[i].functionSelectors[j],\n                    _facets[i].facetAddress\n                );\n                unchecked {\n                    ++j;\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        {\n            bool iIncrement;\n            for (uint256 i; i < defaultFacet.length; ) {\n                bool jIncrement;\n                for (\n                    uint256 j;\n                    j < defaultFacet[i].functionSelectors.length;\n\n                ) {\n                    if (\n                        LibUtils.getValue(\n                            keys,\n                            values,\n                            defaultFacet[i].functionSelectors[j]\n                        ) != address(0)\n                    ) {\n                        if (defaultFacet[i].functionSelectors.length == 1) {\n                            defaultFacet = LibUtils.removeFacetElement(\n                                defaultFacet,\n                                i\n                            );\n                            iIncrement = true;\n                            break;\n                        }\n                        defaultFacet[i].functionSelectors = LibUtils\n                            .removeElement(\n                                defaultFacet[i].functionSelectors,\n                                j\n                            );\n                        jIncrement = true;\n                    }\n                    if (!jIncrement) {\n                        unchecked {\n                            ++j;\n                        }\n                    } else {\n                        jIncrement = false;\n                    }\n                }\n                if (!iIncrement) {\n                    unchecked {\n                        ++i;\n                    }\n                } else {\n                    iIncrement = false;\n                }\n            }\n        }\n        {\n            uint256 facetLength = numFacets + defaultFacet.length;\n            facets_ = new Facet[](facetLength);\n            uint256 defaultFacetIndex;\n            for (uint256 i; i < facetLength; ) {\n                if (i < numFacets) {\n                    facets_[i] = _facets[i];\n                    bool jIncrementor;\n                    for (uint256 j; j < defaultFacet.length; ) {\n                        if (\n                            facets_[i].facetAddress ==\n                            defaultFacet[j].facetAddress\n                        ) {\n                            facets_[i].functionSelectors = LibUtils.mergeArrays(\n                                _facets[i].functionSelectors,\n                                defaultFacet[j].functionSelectors\n                            );\n                            defaultFacet = LibUtils.removeFacetElement(\n                                defaultFacet,\n                                j\n                            );\n                            jIncrementor = true;\n                            {\n                                facets_ = LibUtils.removeFacetElement(\n                                    facets_,\n                                    facets_.length - 1\n                                );\n                            }\n                            --facetLength;\n                        }\n                        if (!jIncrementor) {\n                            unchecked {\n                                ++j;\n                            }\n                        } else {\n                            jIncrementor = false;\n                        }\n                    }\n                } else {\n                    facets_[i] = defaultFacet[defaultFacetIndex];\n                    ++defaultFacetIndex;\n                }\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Gets all the function selectors provided by a facet.\n     * @param _facet The facet address.\n     * @return facetFunctionSelectors_\n     */\n    function facetFunctionSelectors(\n        address _facet\n    ) external view override returns (bytes4[] memory facetFunctionSelectors_) {\n        Facet[] memory facet = facets();\n        uint256 facetLength = facet.length;\n        for (uint256 i; i < facetLength; ) {\n            if (facet[i].facetAddress == _facet)\n                return facet[i].functionSelectors;\n            unchecked {\n                ++i;\n            }\n        }\n        return facetFunctionSelectors_;\n    }\n\n    /**\n     * @notice Get all the facet addresses used by Barz.\n     * @return facetAddresses_\n     */\n    function facetAddresses()\n        external\n        view\n        override\n        returns (address[] memory facetAddresses_)\n    {\n        Facet[] memory facet = facets();\n        uint256 facetLength = facet.length;\n        facetAddresses_ = new address[](facetLength);\n        for (uint256 i; i < facetLength; ) {\n            facetAddresses_[i] = facet[i].facetAddress;\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Gets the facet that supports the given selector.\n     * @dev If facet is not found return address(0).\n     * @param _functionSelector The function selector.\n     * @return facetAddress_ The facet address.\n     */\n    function facetAddress(\n        bytes4 _functionSelector\n    ) external view override returns (address facetAddress_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n\n        facetAddress_ = address(bytes20(ds.facets[_functionSelector]));\n        if (facetAddress_ == address(0)) {\n            facetAddress_ = IDiamondLoupe(ds.defaultFallbackHandler)\n                .facetAddress(_functionSelector);\n        }\n    }\n\n    /**\n     * @notice SupportInterface to be compatible with EIP 165\n     * @param _interfaceId Interface ID for detecting the interface\n     * @return isSupported Bool value showing if the standard is supported in the contract\n     */\n    function supportsInterface(\n        bytes4 _interfaceId\n    ) external view override returns (bool isSupported) {\n        isSupported =\n            _interfaceId == type(IERC165).interfaceId ||\n            _interfaceId == IDiamondCut.diamondCut.selector ||\n            _interfaceId == type(IDiamondLoupe).interfaceId ||\n            _interfaceId == type(IERC1155Receiver).interfaceId ||\n            _interfaceId == type(IERC721Receiver).interfaceId ||\n            _interfaceId == type(IERC777Recipient).interfaceId ||\n            _interfaceId == IERC1271.isValidSignature.selector ||\n            _interfaceId == type(IERC677Receiver).interfaceId ||\n            LibDiamond.diamondStorage().supportedInterfaces[_interfaceId];\n    }\n\n    /**\n     * @notice Returns the facet from the diamond storage. This excludes the facets from the default fallback handler\n     * @return facets_ Facet information attached directly to diamond storage\n     */\n    function facetsFromStorage()\n        external\n        view\n        override\n        returns (Facet[] memory facets_)\n    {\n        facets_ = LibLoupe.facets();\n    }\n\n    /**\n     * @notice Returns the facet address attached to the given function selector. This excludes the facets from the default fallback handler\n     * @param _functionSelector Function selector to fetch the facet address from diamond storage\n     * @return facetAddress_ Facet address mapped with the function selector\n     */\n    function facetAddressFromStorage(\n        bytes4 _functionSelector\n    ) external view override returns (address facetAddress_) {\n        facetAddress_ = LibLoupe.facetAddress(_functionSelector);\n    }\n\n    /**\n     * @notice Returns all facet addresses attached directly to diamond storage. This excludes the facets from the default fallback handler\n     * @return facetAddresses_ All facet addresses attached directly to diamond storage\n     */\n    function facetAddressesFromStorage()\n        external\n        view\n        override\n        returns (address[] memory facetAddresses_)\n    {\n        facetAddresses_ = LibLoupe.facetAddresses();\n    }\n\n    /**\n     * @notice Returns function selectors of given facet address attached directly to diamond storage. This excludes the facets from the default fallback handler\n     * @param _facet Facet address to fetch the facet function selectors from diamond storage\n     * @return facetFunctionSelectors_ Facet function selectors of the given facet address\n     */\n    function facetFunctionSelectorsFromStorage(\n        address _facet\n    ) external view override returns (bytes4[] memory facetFunctionSelectors_) {\n        facetFunctionSelectors_ = LibLoupe.facetFunctionSelectors(_facet);\n    }\n}\n"
    },
    "contracts/facets/base/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\n/**\n * @title DiamondCut Facet Interface\n * @dev Interface for DiamondCut Facet responsible for adding/removing/replace facets in Barz\n * @author David Yongjun Kim (@Powerstream3604)\n */\ninterface IDiamondCut {\n    error DiamondCutFacet__InvalidRouteWithGuardian();\n    error DiamondCutFacet__InvalidRouteWithoutGuardian();\n    error DiamondCutFacet__InvalidArrayLength();\n    error DiamondCutFacet__InsufficientApprovers();\n    error DiamondCutFacet__InvalidApprover();\n    error DiamondCutFacet__InvalidApproverSignature();\n    error DiamondCutFacet__InvalidApprovalValidationPeriod();\n    error DiamondCutFacet__CannotRevokeUnapproved();\n    error DiamondCutFacet__GuardianApprovalNotRequired();\n    error DiamondCutFacet__LackOfOwnerApproval();\n    error DiamondCutFacet__OwnerAlreadyApproved();\n    error DiamondCutFacet__DuplicateApproval();\n\n    event DiamondCutApproved(\n        FacetCut[] diamondCut,\n        address init,\n        bytes initCalldata\n    );\n    event DiamondCutApprovalRevoked(\n        FacetCut[] diamondCut,\n        address init,\n        bytes initCalldata\n    );\n\n    event SupportsInterfaceUpdated(bytes4 interfaceId, bool _lag);\n\n    enum FacetCutAction {\n        Add,\n        Replace,\n        Remove\n    }\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param diamondCut Contains the facet addresses and function selectors\n    /// @param init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata diamondCut,\n        address init,\n        bytes calldata _calldata\n    ) external;\n\n    function updateSupportsInterface(bytes4 interfaceId, bool flag) external;\n\n    function diamondCutWithGuardian(\n        FacetCut[] calldata diamondCut,\n        address init,\n        bytes calldata _calldata,\n        address[] calldata approvers,\n        bytes[] calldata signatures\n    ) external;\n\n    function approveDiamondCut(\n        FacetCut[] calldata diamondCut,\n        address init,\n        bytes calldata _calldata\n    ) external;\n\n    function revokeDiamondCutApproval(\n        FacetCut[] calldata diamondCut,\n        address init,\n        bytes calldata _calldata\n    ) external;\n\n    function getDiamondCutApprovalCountWithTimeValidity(\n        bytes32 diamondCutHash\n    ) external view returns (uint256);\n\n    function getOwnerCutApprovalWithTimeValidity(\n        bytes32 diamondCutHash\n    ) external view returns (bool);\n\n    function isCutApproved(\n        bytes32 diamondCutHash,\n        address approver\n    ) external view returns (bool);\n\n    function getDiamondCutHash(\n        FacetCut[] calldata diamondCut,\n        address init,\n        bytes calldata _calldata\n    ) external view returns (bytes32);\n\n    function getDiamondCutNonce() external view returns (uint128);\n}\n"
    },
    "contracts/facets/base/interfaces/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\n// A loupe is a small magnifying glass used to look at diamonds.\n// These functions look at diamonds\ninterface IDiamondLoupe {\n    /// These functions are expected to be called frequently\n    /// by tools.\n\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Gets all facet addresses and their four byte function selectors.\n    /// @return facets_ Facet\n    function facets() external view returns (Facet[] memory facets_);\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(\n        address _facet\n    ) external view returns (bytes4[] memory facetFunctionSelectors_);\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses()\n        external\n        view\n        returns (address[] memory facetAddresses_);\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(\n        bytes4 _functionSelector\n    ) external view returns (address facetAddress_);\n}\n"
    },
    "contracts/facets/base/interfaces/IStorageLoupe.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {IDiamondLoupe} from \"./IDiamondLoupe.sol\";\n\n/**\n * @title LoupeFromStorage Interface\n * @dev Interface contract to function as a loupe facet directly attached to diamond storage of Barz\n * @author David Yongjun Kim (@Powerstream3604)\n */\ninterface IStorageLoupe {\n    /// These functions are expected to be called frequently\n    /// by tools.\n\n    /// @notice Gets all facet addresses and their four byte function selectors.\n    /// @return facets_ Facet\n    function facetsFromStorage()\n        external\n        view\n        returns (IDiamondLoupe.Facet[] memory);\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    function facetFunctionSelectorsFromStorage(\n        address _facet\n    ) external view returns (bytes4[] memory);\n\n    /// @notice Get all the facet addresses used by a diamond.\n    function facetAddressesFromStorage()\n        external\n        view\n        returns (address[] memory);\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    function facetAddressFromStorage(\n        bytes4 _functionSelector\n    ) external view returns (address);\n}\n"
    },
    "contracts/facets/GuardianFacet.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {LibDiamond} from \"../libraries/LibDiamond.sol\";\nimport {LibFacetStorage, GuardianStorage, StorageConfig} from \"../libraries/LibFacetStorage.sol\";\nimport {LibGuardian} from \"../libraries/LibGuardian.sol\";\nimport {ISecurityManager} from \"../infrastructure/interfaces/ISecurityManager.sol\";\nimport {IGuardianFacet} from \"./interfaces/IGuardianFacet.sol\";\nimport {IVerificationFacet} from \"./interfaces/IVerificationFacet.sol\";\n\n/**\n * @title Guardian Facet\n * @dev Contract that enables addition/removal of guardians from Barz\n * @author David Yongjun Kim (@Powerstream3604)\n */\ncontract GuardianFacet is IGuardianFacet {\n    ISecurityManager public immutable securityManager;\n    uint8 public constant INNER_STRUCT = 0;\n\n    /**\n     * @notice This constructor sets the Security Manager address which is an immutable variable.\n     *         Immutable variables do not impact the storage of diamond\n     * @param _securityManager Security Manager contract that holds the security related variables for all wallets\n     */\n    constructor(address _securityManager) {\n        securityManager = ISecurityManager(_securityManager);\n    }\n\n    /**\n     * @notice Add guardians to Barz.\n     * @dev This method internally calls addGuardian which checks the validity of guardian address and adds\n     *      as guardian if valid\n     * @param _guardians Array of addresses to add as guardian\n     */\n    function addGuardians(address[] calldata _guardians) external override {\n        LibDiamond.enforceIsSelf();\n        uint256 guardiansLength = _guardians.length;\n        for (uint256 i; i < guardiansLength; ) {\n            addGuardian(_guardians[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Add a guardian to Barz.\n     * @dev This method checks if the function is called by the owner and validates the address of guardian\n     *      When the validation passes, guardian address is added to the pending state waiting for confirmation\n     * @param _guardian Address to add as guardian\n     */\n    function addGuardian(address _guardian) public override {\n        LibDiamond.enforceIsSelf();\n        GuardianStorage storage gs = LibFacetStorage.guardianStorage();\n        if (_guardian == address(this))\n            revert GuardianFacet__GuardianCannotBeSelf();\n        if (isGuardian(_guardian)) revert GuardianFacet__DuplicateGuardian();\n        if (_guardian == address(0))\n            revert GuardianFacet__ZeroAddressGuardian();\n        if (\n            keccak256(abi.encodePacked(_guardian)) ==\n            keccak256(IVerificationFacet(address(this)).owner())\n        ) revert GuardianFacet__OwnerCannotBeGuardian();\n\n        bytes32 id = keccak256(abi.encodePacked(_guardian, \"ADD\"));\n        if (\n            gs.pending[id] != 0 ||\n            block.timestamp <= gs.pending[id] + getSecurityWindow()\n        ) revert GuardianFacet__DuplicateGuardianAddition();\n\n        uint256 securityPeriod = getAdditionSecurityPeriod();\n        gs.pending[id] = block.timestamp + securityPeriod;\n        emit GuardianAdditionRequested(\n            _guardian,\n            block.timestamp + securityPeriod\n        );\n    }\n\n    /**\n     * @notice Remove guardians from Barz.\n     * @dev This method internally calls removeGuardian which checks the validity of guardian and removes\n     *      guardian when the request is valid\n     * @param _guardians Array of addresses to be removed\n     */\n    function removeGuardians(address[] calldata _guardians) external override {\n        LibDiamond.enforceIsSelf();\n        uint256 guardiansLength = _guardians.length;\n        for (uint256 i; i < guardiansLength; ) {\n            removeGuardian(_guardians[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Remove a guardian from Barz.\n     * @dev This method validates if the guardian to be removed is a guardian and puts the guardian removal\n     *      to a pending state waiting to be confirmed.\n     * @param _guardian Address of guardian to be removed\n     */\n    function removeGuardian(address _guardian) public override {\n        LibDiamond.enforceIsSelf();\n        if (!isGuardian(_guardian)) revert GuardianFacet__NonExistentGuardian();\n        GuardianStorage storage gs = LibFacetStorage.guardianStorage();\n        bytes32 id = keccak256(abi.encodePacked(_guardian, \"REMOVE\"));\n        if (\n            gs.pending[id] != 0 ||\n            block.timestamp <= gs.pending[id] + getSecurityWindow()\n        ) revert GuardianFacet__DuplicateGuardianRemoval();\n\n        uint256 securityPeriod = getRemovalSecurityPeriod();\n        gs.pending[id] = block.timestamp + securityPeriod;\n        emit GuardianRemovalRequested(\n            _guardian,\n            block.timestamp + securityPeriod\n        );\n    }\n\n    /**\n     * @notice Confirm addition of guardians\n     * @dev This method internally calls confirmGuardianAddition which checks the validity of pending request.\n     *      Guardians are fully added when they pass the validation. Anyone can call this function.\n     * @param _guardians Array of guardian addresses to be added\n     */\n    function confirmGuardianAdditions(\n        address[] calldata _guardians\n    ) external override {\n        uint256 guardiansLength = _guardians.length;\n        for (uint256 i; i < guardiansLength; ) {\n            confirmGuardianAddition(_guardians[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Confirm addition of a guardian\n     * @dev This method checks the validity of pending request.\n     *      Guardians are fully added when they pass the validation. Anyone can call this function.\n     * @param _guardian Guardian address to be added\n     */\n    function confirmGuardianAddition(address _guardian) public override {\n        bytes32 id = keccak256(abi.encodePacked(_guardian, \"ADD\"));\n        GuardianStorage storage gs = LibFacetStorage.guardianStorage();\n        if (gs.pending[id] == 0) revert GuardianFacet__UnknownPendingAddition();\n        if (gs.pending[id] >= block.timestamp)\n            revert GuardianFacet__PendingAdditionNotOver();\n        if (block.timestamp >= gs.pending[id] + getSecurityWindow())\n            revert GuardianFacet__PendingAdditionExpired();\n\n        _addGuardian(_guardian);\n\n        delete gs.pending[id];\n        emit GuardianAdded(_guardian);\n    }\n\n    /**\n     * @notice Confirm removal of guardians\n     * @dev This method internally calls confirmGuardianRemoval to check the validity guardian removal confirmation.\n     *      Guardians are fully removed when they pass the validation. Anyone can call this function.\n     * @param _guardians Array of guardian addresses to be removed\n     */\n    function confirmGuardianRemovals(\n        address[] calldata _guardians\n    ) external override {\n        uint256 guardiansLength = _guardians.length;\n        for (uint256 i; i < guardiansLength; ) {\n            confirmGuardianRemoval(_guardians[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Confirm removal of a guardian\n     * @dev This method checks the validity guardian removal confirmation.\n     *      Guardian is fully removed when they pass the validation. Anyone can call this function.\n     * @param _guardian Guardian address to be removed\n     */\n    function confirmGuardianRemoval(address _guardian) public override {\n        bytes32 id = keccak256(abi.encodePacked(_guardian, \"REMOVE\"));\n        GuardianStorage storage gs = LibFacetStorage.guardianStorage();\n        if (gs.pending[id] == 0) revert GuardianFacet__UnknownPendingRemoval();\n        if (gs.pending[id] >= block.timestamp)\n            revert GuardianFacet__PendingRemovalNotOver();\n        if (block.timestamp >= gs.pending[id] + getSecurityWindow())\n            revert GuardianFacet__PendingAdditionExpired();\n\n        _removeGuardian(_guardian);\n        delete gs.pending[id];\n        emit GuardianRemoved(_guardian);\n    }\n\n    /**\n     * @notice Cancel pending guardian addition\n     * @dev This method checks if the previous request for guardian request exists.\n     *      It reverts if previous request is not pending and cancels the addition otherwise.\n     * @param _guardian Guardian address to be canceled from addition\n     */\n    function cancelGuardianAddition(address _guardian) public override {\n        LibDiamond.enforceIsSelf();\n        bytes32 id = keccak256(abi.encodePacked(_guardian, \"ADD\"));\n        GuardianStorage storage gs = LibFacetStorage.guardianStorage();\n        if (gs.pending[id] == 0) revert GuardianFacet__UnknownPendingAddition();\n        delete gs.pending[id];\n        emit GuardianAdditionCancelled(_guardian);\n    }\n\n    /**\n     * @notice Cancel pending guardian removal\n     * @dev This method checks if the previous request for guardian request exists.\n     *      It reverts if previous request is not pending and cancels the removal otherwise.\n     * @param _guardian Guardian address to be canceled from removal\n     */\n    function cancelGuardianRemoval(address _guardian) public override {\n        LibDiamond.enforceIsSelf();\n        bytes32 id = keccak256(abi.encodePacked(_guardian, \"REMOVE\"));\n        GuardianStorage storage gs = LibFacetStorage.guardianStorage();\n        if (gs.pending[id] == 0) revert GuardianFacet__UnknownPendingRemoval();\n        delete gs.pending[id];\n        emit GuardianRemovalCancelled(_guardian);\n    }\n\n    /**\n     * @notice Get the addition security period of current account from security manager\n     * @dev This method returns the uint value if addition security period\n     * @return additionSecurityPeriod Uint256 value of addition security period\n     */\n    function getAdditionSecurityPeriod()\n        public\n        view\n        override\n        returns (uint256 additionSecurityPeriod)\n    {\n        additionSecurityPeriod = securityManager.additionSecurityPeriodOf(\n            address(this)\n        );\n        if (additionSecurityPeriod == 0)\n            revert GuardianFacet__InvalidAdditionSecurityPeriod();\n    }\n\n    /**\n     * @notice Get the removal security period of current account from security manager\n     * @dev This method returns the uint value if removal security period\n     * @return removalSecurityPeriod Uint256 value of removal security period\n     */\n    function getRemovalSecurityPeriod()\n        public\n        view\n        override\n        returns (uint256 removalSecurityPeriod)\n    {\n        removalSecurityPeriod = securityManager.removalSecurityPeriodOf(\n            address(this)\n        );\n        if (removalSecurityPeriod == 0)\n            revert GuardianFacet__InvalidRemovalSecurityPeriod();\n    }\n\n    /**\n     * @notice Get the security window of current account from security manager\n     * @dev This method returns the uint value if security window\n     * @return securityWindow Uint256 value of removal security period\n     */\n    function getSecurityWindow()\n        public\n        view\n        override\n        returns (uint256 securityWindow)\n    {\n        securityWindow = securityManager.securityWindowOf(address(this));\n        if (securityWindow == 0) revert GuardianFacet__InvalidSecurityWindow();\n    }\n\n    /**\n     * @notice Checks if the addition of the given guardian address is pending\n     * @dev This method returns the bool value of whether the guardian address is pending addition\n     * @return isPending Bool value of representing the pending of guardian addition\n     */\n    function isAdditionPending(\n        address _guardian\n    ) public view override returns (bool isPending) {\n        bytes32 id = keccak256(abi.encodePacked(_guardian, \"ADD\"));\n        isPending = _isPending(id);\n    }\n\n    /**\n     * @notice Checks if the removal of the given guardian address is pending\n     * @dev This method returns the bool value of whether the guardian address is pending removal\n     * @return isPending Bool value of representing the pending of guardian removal\n     */\n    function isRemovalPending(\n        address _guardian\n    ) public view override returns (bool isPending) {\n        bytes32 id = keccak256(abi.encodePacked(_guardian, \"REMOVE\"));\n        isPending = _isPending(id);\n    }\n\n    /**\n     * @notice Checks if the given hash is pending\n     * @dev This method returns the bool value whether the hash is pending\n     * @return isPending Bool value of representing the pending of guardian operation\n     */\n    function _isPending(\n        bytes32 _idHash\n    ) internal view returns (bool isPending) {\n        GuardianStorage storage gs = LibFacetStorage.guardianStorage();\n        isPending = ((gs.pending[_idHash] > 0 &&\n            gs.pending[_idHash] < block.timestamp) &&\n            block.timestamp < gs.pending[_idHash] + getSecurityWindow());\n    }\n\n    /**\n     * @notice Adds guardian to storage config. This is called when guardian is fully added.\n     * @dev This method add guardian address and config information to Facet Storage dedicated for guardian\n     *      When this function is called, guardian is fully added to this Barz Smart Account\n     * @param _guardian Address of guardian to be added\n     */\n    function _addGuardian(address _guardian) internal {\n        if (!isAdditionPending(_guardian))\n            revert GuardianFacet__InvalidGuardianAddition();\n        StorageConfig storage config = LibFacetStorage\n            .guardianStorage()\n            .configs[INNER_STRUCT];\n        if (config.info[_guardian].exists)\n            revert GuardianFacet__AlreadyExists();\n\n        config.info[_guardian].exists = true;\n        config.info[_guardian].index = uint128(config.addresses.length);\n        config.addresses.push(_guardian);\n    }\n\n    /**\n     * @notice Removes guardian to storage config. This is called when guardian is fully removed.\n     * @dev This method remove guardian address and config information to Facet Storage dedicated for guardian\n     *      When this function is called, guardian is fully removed from this Barz Smart Account\n     * @param _guardian Address of guardian to be removed\n     */\n    function _removeGuardian(address _guardian) internal {\n        if (!isRemovalPending(_guardian))\n            revert GuardianFacet__InvalidGuardianRemoval();\n        StorageConfig storage config = LibFacetStorage\n            .guardianStorage()\n            .configs[INNER_STRUCT];\n        if (!config.info[_guardian].exists)\n            revert GuardianFacet__NonExistentGuardian();\n\n        address lastAddress = config.addresses[config.addresses.length - 1];\n        if (_guardian != lastAddress) {\n            uint128 targetIndex = config.info[_guardian].index;\n            config.addresses[targetIndex] = lastAddress;\n            config.info[lastAddress].index = targetIndex;\n        }\n        config.addresses.pop();\n        delete config.info[_guardian];\n\n        emit GuardianRemoved(_guardian);\n    }\n\n    /**\n     * @notice Reads guardian storage and fetches the addresses into an array from the storage\n     * @dev This method fetches the guardian storage and returns the list of guardian addresses\n     * @return addresses Array of addresses comprised of guardian\n     */\n    function getGuardians()\n        public\n        view\n        override\n        returns (address[] memory addresses)\n    {\n        StorageConfig storage config = LibFacetStorage\n            .guardianStorage()\n            .configs[INNER_STRUCT];\n        addresses = new address[](config.addresses.length);\n        uint256 addressesLen = config.addresses.length;\n        for (uint256 i; i < addressesLen; ) {\n            addresses[i] = config.addresses[i];\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Returns the number of majority of guardians\n     * @return majorityOfGuardians_ Number of majority of guardians e.g., 2 if 3 guardians / 3 if 5 guardians\n     */\n    function majorityOfGuardians()\n        public\n        view\n        override\n        returns (uint256 majorityOfGuardians_)\n    {\n        majorityOfGuardians_ = LibGuardian.majorityOfGuardians();\n    }\n\n    /**\n     * @notice Reads guardian storage and fetches the addresses into an array from the storage\n     * @dev This method fetches the guardian storage and returns the list of guardian addresses\n     * @return guardianNumber Array of guardians in the account\n     */\n    function guardianCount()\n        public\n        view\n        override\n        returns (uint256 guardianNumber)\n    {\n        StorageConfig storage config = LibFacetStorage\n            .guardianStorage()\n            .configs[INNER_STRUCT];\n        guardianNumber = config.addresses.length;\n    }\n\n    /**\n     * @notice Reads guardian storage and checks if the given address is a guardian\n     * @return isGuardian_ Bool value representing if the given address is guardian\n     */\n    function isGuardian(\n        address _guardian\n    ) public view override returns (bool isGuardian_) {\n        StorageConfig storage config = LibFacetStorage\n            .guardianStorage()\n            .configs[INNER_STRUCT];\n        isGuardian_ = config.info[_guardian].exists;\n    }\n\n    /**\n     * @notice Checks if the guardian number is zero and returns of guardian facet is okay to be removed\n     * @return isRemovable Bool value representing if guardian facet is removable\n     */\n    function isGuardianFacetRemovable()\n        external\n        view\n        override\n        returns (bool isRemovable)\n    {\n        isRemovable = (0 == guardianCount());\n    }\n}\n"
    },
    "contracts/facets/interfaces/IAccountFacet.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {IEntryPoint} from \"../../aa-4337/interfaces/IEntryPoint.sol\";\n\n/**\n * @title Account Facet Interface\n * @dev Interface of module contract that provides the account features and init/unitialization of signer\n *      compatible with EIP-1271 & EIP-4337\n * @author David Yongjun Kim (@Powerstream3604)\n */\ninterface IAccountFacet {\n    event AccountInitialized(\n        IEntryPoint indexed entryPoint,\n        bytes indexed ownerPublicKey\n    );\n    // NOTE: Added Below Event\n    event VerificationSuccess(bytes32);\n    event VerificationFailure(bytes32);\n\n    error AccountFacet__InitializationFailure();\n    error AccountFacet__RestrictionsFailure();\n    error AccountFacet__NonExistentVerificationFacet();\n    error AccountFacet__CallNotSuccessful();\n\n    function initialize(\n        address verificationFacet,\n        address anEntryPoint,\n        address facetRegistry,\n        address _defaultFallBack,\n        bytes calldata _ownerPublicKey\n    ) external returns (uint256);\n\n    function execute(address dest, uint256 value, bytes calldata func) external;\n\n    function executeBatch(\n        address[] calldata dest,\n        uint256[] calldata value,\n        bytes[] calldata func\n    ) external;\n}\n"
    },
    "contracts/facets/interfaces/IAccountRecoveryFacet.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {RecoveryConfig} from \"../../libraries/LibFacetStorage.sol\";\n\n/**\n * @title Account Recovery Facet Interface\n * @dev Interface of contract that enables recovery of accounts when owner key is unavailable\n * @author David Yongjun Kim (@Powerstream3604)\n */\ninterface IAccountRecoveryFacet {\n    event RecoveryExecuted(\n        bytes indexed recoveryPublicKey,\n        uint64 executeAfter\n    );\n    event RecoveryFinalized(bytes indexed recoveryPublicKey);\n    event RecoveryCanceled(bytes indexed recoveryPublicKey);\n    event RecoveryApproved(\n        bytes indexed recoveryPublicKey,\n        address indexed guardian,\n        uint64 validUntil\n    );\n    event RecoveryApprovalRevoked(\n        bytes indexed recoveryPublicKey,\n        address indexed guardian\n    );\n    event RecoveryCancellationApproved(\n        bytes indexed recoveryPublicKey,\n        address indexed guardian\n    );\n    event RecoveryHardstopped();\n\n    error AccountRecoveryFacet__CallerNotGuardian();\n    error AccountRecoveryFacet__InvalidRecoveryPublicKey();\n    error AccountRecoveryFacet__SignerInitializationFailure();\n    error AccountRecoveryFacet__SignerUninitializationFailure();\n    error AccountRecoveryFacet__InvalidArrayLength();\n    error AccountRecoveryFacet__InsufficientGuardians();\n    error AccountRecoveryFacet__RecoveryAlreadyOngoing();\n    error AccountRecoveryFacet__NonexistentRecovery();\n    error AccountRecoveryFacet__NonExistentApproval();\n    error AccountRecoveryFacet__RecoveryPeriodNotOver();\n    error AccountRecoveryFacet__InvalidLockPeriod();\n    error AccountRecoveryFacet__InvalidRecoveryPeriod();\n    error AccountRecoveryFacet__InvalidApprovalValidationPeriod();\n    error AccountRecoveryFacet__InvalidGuardian();\n    error AccountRecoveryFacet__InvalidGuardianSignature();\n    error AccountRecoveryFacet__InvalidOwnerSignature();\n    error AccountRecoveryFacet__CallNotSuccesful();\n    error AccountRecoveryFacet__DuplicateApproval();\n\n    function approveAccountRecovery(bytes calldata recoveryPublicKey) external;\n\n    function revokeAccountRecoveryApproval(\n        bytes calldata recoveryPublicKey\n    ) external;\n\n    function executeRecovery(\n        bytes calldata recoveryPublicKey,\n        address[] calldata guardians,\n        bytes[] calldata signatures\n    ) external;\n\n    function finalizeRecovery() external;\n\n    function approveCancelRecovery(bytes calldata recoveryPublicKey) external;\n\n    function cancelRecovery(\n        bytes calldata recoveryPublicKey,\n        address[] calldata guardians,\n        bytes[] calldata signatures\n    ) external;\n\n    function hardstopRecovery(bytes calldata signature) external;\n\n    function getApprovalRecoveryKeyHash(\n        bytes memory recoveryPublicKey,\n        string memory saltString\n    ) external view returns (bytes32);\n\n    function getRecoveryApprovalCountWithTimeValidity(\n        bytes32 recoveryPublicKeyHash\n    ) external view returns (uint256);\n\n    function isRecoveryApproved(\n        bytes32 recoveryPublicKeyHash,\n        address approver\n    ) external view returns (bool);\n\n    function getRecoveryNonce() external view returns (uint128);\n\n    function getPendingRecovery() external view returns (RecoveryConfig memory);\n}\n"
    },
    "contracts/facets/interfaces/IGuardianFacet.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\n/**\n * @title Guardian Facet Interface\n * @dev Interface of guaridna contract that enables addition/removal of guardians from Barz\n * @author David Yongjun Kim (@Powerstream3604)\n */\ninterface IGuardianFacet {\n    event GuardianAdditionRequested(\n        address indexed guardian,\n        uint256 executeAfter\n    );\n    event GuardianRemovalRequested(\n        address indexed guardian,\n        uint256 executeAfter\n    );\n    event GuardianAdditionCancelled(address indexed guardian);\n    event GuardianRemovalCancelled(address indexed guardian);\n    event GuardianAdded(address indexed guardian);\n    event GuardianRemoved(address indexed guardian);\n\n    error GuardianFacet__GuardianCannotBeSelf();\n    error GuardianFacet__DuplicateGuardian();\n    error GuardianFacet__OwnerCannotBeGuardian();\n    error GuardianFacet__DuplicateGuardianAddition();\n    error GuardianFacet__DuplicateGuardianRemoval();\n    error GuardianFacet__UnknownPendingAddition();\n    error GuardianFacet__PendingAdditionNotOver();\n    error GuardianFacet__UnknownPendingRemoval();\n    error GuardianFacet__PendingRemovalNotOver();\n    error GuardianFacet__PendingAdditionExpired();\n    error GuardianFacet__InvalidAdditionSecurityPeriod();\n    error GuardianFacet__InvalidRemovalSecurityPeriod();\n    error GuardianFacet__InvalidSecurityWindow();\n    error GuardianFacet__NonExistentGuardian();\n    error GuardianFacet__AlreadyExists();\n    error GuardianFacet__InvalidGuardianAddition();\n    error GuardianFacet__InvalidGuardianRemoval();\n    error GuardianFacet__ZeroAddressGuardian();\n\n    function addGuardian(address guardian) external;\n\n    function addGuardians(address[] calldata guardians) external;\n\n    function removeGuardian(address guardian) external;\n\n    function removeGuardians(address[] calldata guardians) external;\n\n    function confirmGuardianAddition(address guardian) external;\n\n    function confirmGuardianAdditions(address[] calldata guardian) external;\n\n    function confirmGuardianRemoval(address guardian) external;\n\n    function confirmGuardianRemovals(address[] calldata guardian) external;\n\n    function cancelGuardianAddition(address guardian) external;\n\n    function cancelGuardianRemoval(address guardian) external;\n\n    function isGuardian(address guardian) external view returns (bool);\n\n    function isAdditionPending(address guardian) external view returns (bool);\n\n    function isRemovalPending(address guardian) external view returns (bool);\n\n    function isGuardianFacetRemovable() external view returns (bool);\n\n    function getAdditionSecurityPeriod() external view returns (uint256);\n\n    function getRemovalSecurityPeriod() external view returns (uint256);\n\n    function getSecurityWindow() external view returns (uint256);\n\n    function getGuardians() external view returns (address[] memory);\n\n    function majorityOfGuardians() external view returns (uint256);\n\n    function guardianCount() external view returns (uint256);\n}\n"
    },
    "contracts/facets/interfaces/ILockFacet.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {Lock} from \"../../libraries/LibAppStorage.sol\";\n\n/**\n * @title Lock Facet Interface\n * @dev Interface of Lock contract that enables full lock/unlock of Barz\n * @author David Yongjun Kim (@Powerstream3604)\n */\ninterface ILockFacet {\n    event Locked(uint64 releaseAfter);\n    event Unlocked();\n\n    error LockFacet__InvalidRecoveryPeriod();\n    error LockFacet__CannotUnlock();\n    error LockFacet__InvalidSignature();\n    error LockFacet__InvalidApprover();\n\n    function lock() external;\n\n    function unlock(address approver, bytes calldata signature) external;\n\n    function getLockPeriod() external view returns (uint256);\n\n    function isLocked() external view returns (bool);\n\n    function getUnlockHash() external view returns (bytes32);\n\n    function lockNonce() external view returns (uint128);\n\n    function getPendingLock() external view returns (Lock memory);\n}\n"
    },
    "contracts/facets/interfaces/IMultiSigFacet.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\n/**\n * @title Multi-sig facet Interface\n * @dev Interface of Multi-signature Facet with custom threshold.\n        Wallet that adds this facet becomes a multi-sig wallet\n * @author David Yongjun Kim (@Powerstream3604)\n */\ninterface IMultiSigFacet {\n    event ThresholdChanged(uint256 threshold);\n    event OwnerAdded(address indexed newOwner);\n    event OwnerRemoved(address indexed prevOwner);\n    event HashApproved(bytes32 hashToApprove, address indexed owner);\n\n    error MultiSigFacet__InvalidThreshold();\n    error MultisigFacet__InvalidOwnerCount();\n    error MultiSigFacet__InvalidRoute();\n    error MultiSigFacet__InsufficientSignerLength();\n    error MultiSigFacet__InvalidInitData();\n    error MultiSigFacet__InvalidOwnerAddress();\n    error MultiSigFacet__InvalidOwnerPair();\n    error MultiSigFacet__InvalidSignatureLength();\n    error MultiSigFacet__InvalidSignatureType();\n    error MultiSigFacet__DuplicateOwner();\n    error MultiSigFacet__OnlyOwner();\n\n    function checkSignatures(\n        bytes32 _dataHash,\n        bytes calldata _signatures,\n        uint256 _threshold\n    ) external view returns (uint256);\n\n    function splitSignatures(\n        bytes calldata _signatures,\n        uint256 _nextOffset\n    )\n        external\n        pure\n        returns (\n            address owner,\n            bytes memory signature,\n            uint256 signatureType,\n            uint256 nextOffset\n        );\n\n    function approveHash(bytes32 hashToApprove) external;\n\n    function addOwner(address newOwner, uint256 threshold) external;\n\n    function removeOwner(\n        address prevOwner,\n        address removedOwner,\n        uint256 threshold\n    ) external;\n\n    function swapOwner(\n        address prevOwner,\n        address oldOwner,\n        address newOwner\n    ) external;\n\n    function changeThreshold(uint256 _threshold) external;\n\n    function isOwner(address owner) external view returns (bool);\n\n    function getThreshold() external view returns (uint256);\n\n    function getOwners() external view returns (address[] memory);\n}\n"
    },
    "contracts/facets/interfaces/IRestrictionsFacet.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\n/**\n * @title Restrictions Facet Interface\n * @dev Interface of Restrictions contract that enables modular restrictions in Barz\n * @author Ruslan Serebriakov (@rsrbk)\n * @author David Yongjun Kim (@Powerstream3604)\n */\ninterface IRestrictionsFacet {\n    event RestrictionAdded(address indexed restriction);\n    event RestrictionRemoved(address indexed restriction);\n\n    error RestrictionsFacet__EmptyRestrictionsList();\n    error RestrictionsFacet__RestrictionNotFound();\n    error RestrictionsFacet__RestrictionAlreadyExists();\n    error RestrictionsFacet__ZeroAddressRestrictions();\n    error RestrictionsFacet__ZeroAddressRestrictionsFacet();\n    error RestrictionsFacet__RemainingRestrictionsCantBeEmpty();\n\n    function initializeRestrictions(\n        address[] memory _restrictions\n    ) external returns (uint256);\n\n    function uninitializeRestrictions() external returns (uint256);\n\n    function getRestrictions() external view returns (address[] memory);\n\n    function addRestriction(address restriction) external;\n\n    function removeRestriction(address restriction) external;\n\n    function verifyRestrictions(\n        address from,\n        address to,\n        uint256 value,\n        bytes calldata _calldata\n    ) external returns (uint256);\n}\n"
    },
    "contracts/facets/interfaces/ISignatureMigrationFacet.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {SignatureMigrationConfig} from \"../../libraries/LibFacetStorage.sol\";\n\n/**\n * @title Signature Migration Facet Interface\n * @dev Interface of Signature Migration contract for migrating user signature scheme to a new scheme user sets\n *      Which could include\n *          - ECDSA on Secp256K1 Curve\n *          - ECDSA on Secp256R1 Curve\n *          - BLS, Schnorr, etc\n * @author David Yongjun Kim (@Powerstream3604)\n */\ninterface ISignatureMigrationFacet {\n    event SignatureSchemeMigration(\n        address indexed prevVerificationFacet,\n        address indexed newVerificationFacet,\n        bytes newOwner,\n        bytes4[] verificationFuncSelectors\n    );\n    event SignatureMigrationApproved(\n        bytes newPublicKey,\n        address indexed newVerificationFacet,\n        bytes4[] verificationFuncSelectors,\n        address indexed guardian,\n        uint128 approvalValidUntil\n    );\n    event SignatureMigrationApprovalRevoked(\n        bytes newPublicKey,\n        address indexed newVerificationFacet,\n        bytes4[] verificationFuncSelectors,\n        address indexed guardian\n    );\n    event SignatureMigrationExecuted(\n        address indexed newVerificationFacet,\n        bytes newOwner,\n        bytes4[] verificationFuncSelectors,\n        uint128 migrateAfter\n    );\n    event SignatureMigrationCanceled(\n        address indexed newVerificationFacet,\n        bytes newOwner,\n        bytes4[] verificationFuncSelectors\n    );\n    event SignatureMigrationCancellationApproved(\n        address indexed newVerificationFacet,\n        bytes newOwner,\n        bytes4[] verificationFuncSelectors\n    );\n\n    error SignatureMigrationFacet__SignerUninitializationFailure();\n    error SignatureMigrationFacet__InvalidRouteWithGuardian();\n    error SignatureMigrationFacet__InvalidKeyType();\n    error SignatureMigrationFacet__InsufficientApprovers();\n    error SignatureMigrationFacet__InvalidApproverSignature();\n    error SignatureMigrationFacet__InvalidGuardian();\n    error SignatureMigrationFacet__NonExistentApprover();\n    error SignatureMigrationFacet__InvalidMigrationPeriod();\n    error SignatureMigrationFacet__NonexistentMigration();\n    error SignatureMigrationFacet__MigrationPeriodNotOver();\n    error SignatureMigrationFacet__InvalidArrayLength();\n    error SignatureMigrationFacet__InvalidApprovalValidationPeriod();\n    error SignatureMigrationFacet__CannotRevokeUnapproved();\n    error SignatureMigrationFacet__LackOfOwnerApproval();\n    error SignatureMigrationFacet__OwnerAlreadyApproved();\n    error SignatureMigrationFacet__NonExistentVerificationFacet();\n    error SignatureMigrationFacet__DuplicateApproval();\n\n    function migrateSignatureScheme(\n        address newVerificationFacet,\n        bytes calldata newPublicKey,\n        bytes4[] calldata newVerificationFuncSelectors\n    ) external;\n\n    function migrateSignatureSchemeWithGuardian(\n        address newVerificationFacet,\n        bytes calldata newPublicKey,\n        bytes4[] calldata newVerificationFuncSelectors,\n        address[] calldata approvers,\n        bytes[] calldata signatures\n    ) external;\n\n    function approveSignatureSchemeMigration(\n        address newVerificationFacet,\n        bytes calldata newPublicKey,\n        bytes4[] calldata newVerificationFuncSelectors\n    ) external;\n\n    function revokeSignatureMigrationApproval(\n        address newVerificationFacet,\n        bytes calldata newPublicKey,\n        bytes4[] calldata newVerificationFuncSelectors\n    ) external;\n\n    function finalizeSignatureMigration() external;\n\n    function approveCancelSignatureMigration(\n        address newVerificationFacet,\n        bytes calldata newPublicKey,\n        bytes4[] calldata newVerificationFuncSelectors\n    ) external;\n\n    function cancelSignatureMigration(\n        address newVerificationFacet,\n        bytes calldata newPublicKey,\n        bytes4[] calldata newVerificationFuncSelectors,\n        address[] calldata guardians,\n        bytes[] calldata signatures\n    ) external;\n\n    function getApprovalMigrationKeyHash(\n        bytes memory recoveryPublicKey,\n        address newVerificationFacet,\n        bytes4[] memory newVerificationFuncSelectors,\n        string memory saltString\n    ) external view returns (bytes32);\n\n    function getMigrationOwnerApprovalWithTimeValidity(\n        bytes32 publicKeyHash\n    ) external view returns (bool);\n\n    function getMigrationApprovalCountWithTimeValidity(\n        bytes32 publicKeyHash\n    ) external view returns (uint256);\n\n    function isMigrationApproved(\n        bytes32 migrationPublicKeyHash,\n        address approver\n    ) external view returns (bool);\n\n    function getMigrationNonce() external view returns (uint128);\n\n    function isMigrationPending() external view returns (bool);\n\n    function getPendingMigration()\n        external\n        view\n        returns (SignatureMigrationConfig memory);\n}\n"
    },
    "contracts/facets/interfaces/IVerificationFacet.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {UserOperation} from \"../../aa-4337/interfaces/UserOperation.sol\";\n\n/**\n * @title Verification Facet Interface\n * @dev Implements logic for user ops signature verification\n * @author David Yongjun Kim (@Powerstream3604)\n * @author Ruslan Serebriakov (@rsrbk)\n */\ninterface IVerificationFacet {\n    event SignerInitialized(bytes);\n    event SignerUninitialized();\n\n    error VerificationFacet__ValidateOwnerSignatureSelectorNotSet();\n    error VerificationFacet__ValidateOwnerSignatureSelectorAlreadySet();\n    error VerificationFacet__InitializationFailure();\n    error VerificationFacet__InvalidFacetMapping();\n\n    function initializeSigner(bytes memory) external returns (uint256);\n\n    function uninitializeSigner() external returns (uint256);\n\n    function validateOwnerSignatureSelector() external view returns (bytes4);\n\n    function owner() external view returns (bytes memory);\n\n    function isValidKeyType(bytes calldata) external view returns (bool);\n\n    function validateOwnerSignature(\n        UserOperation calldata userOp,\n        bytes32 userOpHash\n    ) external view returns (uint256);\n}\n"
    },
    "contracts/facets/LockFacet.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {SignatureChecker} from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport {LibAppStorage, Lock} from \"../libraries/LibAppStorage.sol\";\nimport {LibGuardian} from \"../libraries/LibGuardian.sol\";\nimport {LibFacetStorage} from \"../libraries/LibFacetStorage.sol\";\nimport {Modifiers} from \"./Modifiers.sol\";\nimport {ISecurityManager} from \"../infrastructure/interfaces/ISecurityManager.sol\";\nimport {ILockFacet} from \"./interfaces/ILockFacet.sol\";\n\n/**\n * @title Lock Facet\n * @dev Contract that enables full lock/unlock of Barz\n * @author David Yongjun Kim (@Powerstream3604)\n */\ncontract LockFacet is ILockFacet, Modifiers {\n    ISecurityManager public immutable securityManager;\n\n    /**\n     * @notice This constructor sets the Security Manager address which is an immutable variable.\n     *         Immutable variables do not impact the storage of diamond\n     * @param _securityManager Security Manager contract that holds the security related variables for all wallets\n     */\n    constructor(address _securityManager) {\n        securityManager = ISecurityManager(_securityManager);\n    }\n\n    /**\n     * @notice Locks the account for the lock period. Lock period is defined in the security manager and it's customizable\n     *         This function can only be called when account is unlocked by owner or guardians\n     * @dev This method checks the caller and if the account is currently locked and locks the account after fetching the\n     *      Lock period from the owner.\n     */\n    function lock() external override onlyGuardianOrOwner onlyWhenUnlocked {\n        uint256 unlockTime = block.timestamp + getLockPeriod();\n        ++LibFacetStorage.lockStorage().nonce;\n        LibAppStorage.setLock(unlockTime, LockFacet.lock.selector);\n        emit Locked(uint64(unlockTime));\n    }\n\n    /**\n     * @notice Locks the account when the account is locked. This function can be called by anyone but must provide the approver address and signature.\n     *         The approver should be one of the guardians or owner.\n     * @dev This method takes the approver address and the signature. After validating the address and the signature, it unlocks the account immediately.\n     *      Only one of the guardian or owner is required to lock and unlock the account.\n     * @param _approver Address of approver approving the unlock of Barz account\n     * @param _signature Signature of the approver that signed the msg hash for unlocking the account\n     */\n    function unlock(\n        address _approver,\n        bytes calldata _signature\n    ) external override onlyWhenLocked {\n        if (_approver != address(this) && !LibGuardian.isGuardian(_approver))\n            revert LockFacet__InvalidApprover();\n        if (\n            !SignatureChecker.isValidSignatureNow(\n                _approver,\n                getUnlockHash(),\n                _signature\n            )\n        ) revert LockFacet__InvalidSignature();\n        _unlock();\n    }\n\n    /**\n     * @notice Unlocks the account and increments the lock nonce\n     */\n    function _unlock() private {\n        if (s.locks[INNER_STRUCT].locker != LockFacet.lock.selector)\n            revert LockFacet__CannotUnlock();\n        ++LibFacetStorage.lockStorage().nonce;\n        LibAppStorage.setLock(0, bytes4(0));\n        emit Unlocked();\n    }\n\n    /**\n     * @notice Returns the lock period of current Barz account. Lock period information is held by Security Manager\n     * @return lockPeriod Uint value of lock period in seconds\n     */\n    function getLockPeriod() public view override returns (uint256 lockPeriod) {\n        lockPeriod = securityManager.lockPeriodOf(address(this));\n        if (lockPeriod == 0) revert LockFacet__InvalidRecoveryPeriod();\n    }\n\n    /**\n     * @notice Returns if the account is locked or not\n     * @dev This method fetches the current block timestamp and compares that with release time.\n     *      After checking the timestamp and release time, it returns if the account is still locked or not.\n     * @return isLocked_ Uint value of lock period in seconds\n     */\n    function isLocked() public view override returns (bool isLocked_) {\n        isLocked_ = uint64(block.timestamp) < s.locks[INNER_STRUCT].release;\n    }\n\n    /**\n     * @notice Calculates the unlock hash and returns the unlock hash safe from signature reply attack\n     * @dev This method calculates the unlock hash with EIP-191 prefix, wallet address, chainID, and nonce\n     *      It packs the result and packs them and hashes it.\n     * @return unlockHash Bytes32 unlock hash\n     */\n    function getUnlockHash() public view override returns (bytes32 unlockHash) {\n        unlockHash = keccak256(\n            abi.encodePacked(\n                \"\\x19Ethereum Signed Message:\\n32\",\n                keccak256(\n                    abi.encode(\n                        \"Unlock\",\n                        address(this),\n                        block.chainid,\n                        lockNonce()\n                    )\n                )\n            )\n        );\n    }\n\n    /**\n     * @notice Returns lock nonce of account. Reads nonce from lock storage within facet storage\n     * @return lockNonce_ Uint128 value of lock nonce. This is incremented whenever the account is lock/unlocked\n     */\n    function lockNonce() public view override returns (uint128 lockNonce_) {\n        lockNonce_ = LibFacetStorage.lockStorage().nonce;\n    }\n\n    /**\n     * @notice Returns the overall information of current lock\n     * @return pendingLock Struct value including all information of pending lock\n     */\n    function getPendingLock()\n        public\n        view\n        override\n        returns (Lock memory pendingLock)\n    {\n        pendingLock = s.locks[INNER_STRUCT];\n    }\n}\n"
    },
    "contracts/facets/Modifiers.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {LibGuardian} from \"../libraries/LibGuardian.sol\";\nimport {BarzStorage} from \"../libraries/LibAppStorage.sol\";\nimport {IFacetRegistry} from \"../infrastructure/interfaces/IFacetRegistry.sol\";\nimport {IDiamondCut} from \"../facets/base/interfaces/IDiamondCut.sol\";\n\n/**\n * @title Modifiers\n * @dev Responsible for providing modifiers/util functions to Facet contracts\n * @author David Yongjun Kim (@Powerstream3604)\n */\nabstract contract Modifiers is BarzStorage {\n    uint8 constant INNER_STRUCT = 0;\n\n    error CallerNotGuardian();\n    error CallerNotGuardianOrOwner();\n    error DuplicateApprover();\n    error ZeroApproverLength();\n    error UnregisteredFacetAndSelectors();\n\n    /**\n     * @notice Modifier to only allow guardian to make a call, reverts if any other entity is the caller\n     */\n    modifier onlyGuardian() {\n        if (!LibGuardian.isGuardian(msg.sender)) revert CallerNotGuardian();\n        _;\n    }\n\n    /**\n     * @notice Modifier to only allow guardian or owner to make a call, reverts if any other entity is the caller\n     */\n    modifier onlyGuardianOrOwner() {\n        if (!LibGuardian.isGuardian(msg.sender) && address(this) != msg.sender)\n            revert CallerNotGuardianOrOwner();\n        _;\n    }\n\n    /**\n     * @notice Checks if the approver address is the array is unique with no duplicate\n     * @dev This method loops through the array and checks if a duplicate address exists, it reverts if duplicate address exists\n     * @param approvers Array of address\n     */\n    function _checkApprover(\n        address[] memory approvers\n    ) internal pure returns (bool) {\n        uint256 approverLength = approvers.length;\n        if (0 == approverLength) revert ZeroApproverLength();\n        for (uint256 i; i < approverLength - 1; ) {\n            for (uint256 j = i + 1; j < approverLength; ) {\n                if (approvers[i] == approvers[j]) {\n                    revert DuplicateApprover(); // Found a duplicate\n                }\n                unchecked {\n                    ++j;\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return false; // No duplicates found\n    }\n\n    /**\n     * @notice Checks if the facet getting added or replaced is registered to facet registry\n     * @dev This method loops through the cut and checks if the facet getting added/replaced is registered to facet registry\n     * @param _diamondCut Array of FacetCut, data for diamondCut defined in EIP-2535\n     */\n    function _checkFacetCutValidity(\n        IDiamondCut.FacetCut[] memory _diamondCut\n    ) internal view {\n        uint256 diamondCutLength = _diamondCut.length;\n        for (uint256 i; i < diamondCutLength; ) {\n            if (\n                _diamondCut[i].action == IDiamondCut.FacetCutAction.Add ||\n                _diamondCut[i].action == IDiamondCut.FacetCutAction.Replace\n            ) {\n                if (\n                    !s.facetRegistry.areFacetFunctionSelectorsRegistered(\n                        _diamondCut[i].facetAddress,\n                        _diamondCut[i].functionSelectors\n                    )\n                ) revert UnregisteredFacetAndSelectors();\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}\n"
    },
    "contracts/facets/RestrictionsFacet.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {LibDiamond} from \"../libraries/LibDiamond.sol\";\nimport {LibAppStorage} from \"../libraries/LibAppStorage.sol\";\nimport {LibFacetStorage, RestrictionsStorage} from \"../libraries/LibFacetStorage.sol\";\nimport {IRestriction} from \"../restrictions/IRestriction.sol\";\nimport {IRestrictionsFacet} from \"./interfaces/IRestrictionsFacet.sol\";\n\n/**\n * @title Restrictions facet\n * @dev Responsible for storing and verifying different kinds of restrictions, for example:\n *         - Whitelist / Blacklist\n *         - Daily limits\n *         - Trading time restrictions\n * @author Ruslan Serebriakov (@rsrbk)\n */\ncontract RestrictionsFacet is IRestrictionsFacet {\n    /**\n     * @notice This constructor ensures that this contract can only be used as singleton for Proxy contracts\n     */\n    constructor() {\n        LibAppStorage.enforceRestrictionsInitialize();\n    }\n\n    /**\n     * @notice Intialize restrictions of Barz. Restrictions facet call restriction contracts for restriction validation\n     *         before each call\n     * @param _restrictions The initial array of restrictions.\n     * @return initSuccess Int value showing if the initialization of restriction is successful\n     */\n    function initializeRestrictions(\n        address[] calldata _restrictions\n    ) public override returns (uint256 initSuccess) {\n        LibDiamond.enforceIsSelf();\n        LibAppStorage.enforceRestrictionsInitialize();\n\n        uint256 restrictionsLength = _restrictions.length;\n        if (restrictionsLength == 0) {\n            // You can't initialize RestrictionsFacet with an empty list of restrictions\n            revert RestrictionsFacet__EmptyRestrictionsList();\n        }\n        for (uint256 i; i < restrictionsLength; ) {\n            if (_restrictions[i] == address(0))\n                revert RestrictionsFacet__ZeroAddressRestrictions();\n            unchecked {\n                ++i;\n            }\n        }\n\n        LibFacetStorage.restrictionsStorage().restrictions = _restrictions;\n        _updateRestrictionsMap(_restrictions, true);\n        initSuccess = 1;\n    }\n\n    /**\n     * @notice Unitialize restrictions of Barz\n     * @return uninitSuccess Int value showing if the initialization of restriction is successful\n     */\n    function uninitializeRestrictions()\n        external\n        override\n        returns (uint256 uninitSuccess)\n    {\n        LibDiamond.enforceIsSelf();\n        LibAppStorage.setRestrictionsUninitialized();\n        RestrictionsStorage storage restrictionsStorage = LibFacetStorage\n            .restrictionsStorage();\n        _updateRestrictionsMap(restrictionsStorage.restrictions, false);\n        restrictionsStorage.restrictions = new address[](0);\n        uninitSuccess = 1;\n    }\n\n    /**\n     * @notice Returns the list of Restrictions contract address\n     * @return restrictions Addresses of IRestriction which are currently active\n     */\n    function getRestrictions()\n        public\n        view\n        override\n        returns (address[] memory restrictions)\n    {\n        RestrictionsStorage storage restrictionsStorage = LibFacetStorage\n            .restrictionsStorage();\n        restrictions = restrictionsStorage.restrictions;\n    }\n\n    /**\n     * @notice Adds restrictions to Barz with validation on the restriction contract address.\n     *         This method is only callable by the owner(self).\n     * @param _restriction The address of the restriction to be added.\n     */\n    function addRestriction(address _restriction) external override {\n        LibDiamond.enforceIsSelf();\n        if (LibDiamond.restrictionsFacet() == address(0))\n            revert RestrictionsFacet__ZeroAddressRestrictionsFacet();\n        RestrictionsStorage storage restrictionsStorage = LibFacetStorage\n            .restrictionsStorage();\n        if (_restriction == address(0))\n            revert RestrictionsFacet__ZeroAddressRestrictions();\n        if (restrictionsStorage.exists[_restriction])\n            revert RestrictionsFacet__RestrictionAlreadyExists();\n\n        restrictionsStorage.restrictions.push(_restriction);\n        restrictionsStorage.exists[_restriction] = true;\n\n        emit RestrictionAdded(_restriction);\n    }\n\n    /**\n     * @notice Remove restrictions from Barz if it existed. This method is only callable by the owner(self).\n     * @param _restriction The address of the restriction to be removed.\n     */\n    function removeRestriction(address _restriction) external override {\n        LibDiamond.enforceIsSelf();\n        RestrictionsStorage storage restrictionsStorage = LibFacetStorage\n            .restrictionsStorage();\n\n        if (!restrictionsStorage.exists[_restriction])\n            revert RestrictionsFacet__RestrictionNotFound();\n\n        address[] storage restrictions = restrictionsStorage.restrictions;\n\n        uint256 indexToDelete = restrictions.length;\n        uint256 restrictionsLen = restrictions.length;\n        for (uint256 i; i < restrictionsLen; ) {\n            if (restrictions[i] == _restriction) {\n                indexToDelete = i;\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (indexToDelete == 0 && restrictionsLen == 1) {\n            revert RestrictionsFacet__RemainingRestrictionsCantBeEmpty();\n        } else if (indexToDelete == restrictionsLen) {\n            revert RestrictionsFacet__RestrictionNotFound();\n        } else {\n            restrictions[indexToDelete] = restrictions[restrictionsLen - 1];\n            restrictions.pop();\n        }\n\n        restrictionsStorage.exists[_restriction] = false;\n        emit RestrictionRemoved(_restriction);\n    }\n\n    /**\n     * @notice Sets the restrictions address value mapping to true or false when adding/removing restriction contracts\n     * @param _restrictions List of restriction contracts address\n     * @param _newValue Bool value to flag to the list of restrictions contracts\n     */\n    function _updateRestrictionsMap(\n        address[] memory _restrictions,\n        bool _newValue\n    ) internal {\n        RestrictionsStorage storage restrictionsStorage = LibFacetStorage\n            .restrictionsStorage();\n\n        uint restrictionsLen = _restrictions.length;\n        for (uint256 i; i < restrictionsLen; ) {\n            restrictionsStorage.exists[_restrictions[i]] = _newValue;\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Iterates over all restrictions and verifies each of them with the transaction parameters.\n     * @param _from The address of the sender, that will be signing the transaction.\n     * @param _to The receiving address.\n     * @param _value Amount of ETH to transfer from sender to recipient.\n     * @param _calldata Optional field to include arbitrary data.\n     * @return 0 if all the checks passed, 1 otherwise.\n     */\n    function verifyRestrictions(\n        address _from,\n        address _to,\n        uint256 _value,\n        bytes calldata _calldata\n    ) external returns (uint256) {\n        RestrictionsStorage storage restrictionsStorage = LibFacetStorage\n            .restrictionsStorage();\n\n        uint restrictionsLen = restrictionsStorage.restrictions.length;\n        for (uint256 i; i < restrictionsLen; ) {\n            IRestriction restriction = IRestriction(\n                restrictionsStorage.restrictions[i]\n            );\n            bool checkPassed = restriction.check(_from, _to, _value, _calldata);\n            if (!checkPassed) {\n                return 1;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        return 0;\n    }\n}\n"
    },
    "contracts/facets/SignatureMigrationFacet.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {SignatureChecker} from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport {LibAppStorage} from \"../libraries/LibAppStorage.sol\";\nimport {LibFacetStorage, SignatureMigrationStorage, SignatureMigrationConfig, SignatureMigrationApprovalConfig, ApprovalConfig} from \"../libraries/LibFacetStorage.sol\";\nimport {LibDiamond} from \"../libraries/LibDiamond.sol\";\nimport {LibGuardian} from \"../libraries/LibGuardian.sol\";\nimport {LibLoupe} from \"../libraries/LibLoupe.sol\";\nimport {Modifiers} from \"./Modifiers.sol\";\nimport {ISecurityManager} from \"../infrastructure/interfaces/ISecurityManager.sol\";\nimport {IDiamondCut} from \"./base/interfaces/IDiamondCut.sol\";\nimport {IVerificationFacet} from \"./interfaces/IVerificationFacet.sol\";\nimport {ISignatureMigrationFacet} from \"./interfaces/ISignatureMigrationFacet.sol\";\n\n/**\n * @title Signature Migration Facet\n * @dev Responsible for migrating user signature scheme to a new scheme user sets\n *      Which could include\n *          - ECDSA on Secp256K1 Curve\n *          - ECDSA on Secp256R1 Curve\n *          - BLS, Schnorr, etc\n * @author David Yongjun Kim (@Powerstream3604)\n */\ncontract SignatureMigrationFacet is ISignatureMigrationFacet, Modifiers {\n    /**\n     * @notice This modifier verifies if the public key format matches with the new verification facet\n     * @param _publicKey Bytes of public key to be validated for the new verification facet\n     * @param _newVerificationFacet Address of new verification facet\n     */\n    modifier validateKeyType(\n        bytes memory _publicKey,\n        address _newVerificationFacet\n    ) {\n        if (\n            !IVerificationFacet(_newVerificationFacet).isValidKeyType(\n                _publicKey\n            )\n        ) revert SignatureMigrationFacet__InvalidKeyType();\n        _;\n    }\n\n    ISecurityManager public immutable securityManager;\n\n    /**\n     * @notice This constructor sets the Security Manager address which is an immutable variable.\n     *         Immutable variables do not impact the storage of diamond\n     * @param _securityManager Security Manager contract that holds the security related variables for all wallets\n     */\n    constructor(address _securityManager) {\n        securityManager = ISecurityManager(_securityManager);\n    }\n\n    // IMPORTANT NOTE: In the client side when they call this function, the func selectors should be sorted in ascending order\n    // to prevent different hash with same items in the array\n    /**\n     * @notice Moves the state of migration to a pending state. When pending state is over after pending period time,\n     *         Migration can be finalized. This function can only be called by self and when the account is unlocked.\n     * @dev This method checks if the caller is self and if guardians exists. It migrates signature request to a pending state\n     * @param _newVerificationFacet Verification facet that will replace the existing verification facet\n     * @param _newPublicKey Public key that will be used for the new verification facet that replaces the previous one\n     * @param _newVerificationFuncSelectors Function Selectors of new verification facet that will be added to the diamond\n     */\n    function migrateSignatureScheme(\n        address _newVerificationFacet,\n        bytes calldata _newPublicKey,\n        bytes4[] calldata _newVerificationFuncSelectors\n    )\n        public\n        override\n        onlyWhenUnlocked\n        validateKeyType(_newPublicKey, _newVerificationFacet)\n    {\n        // Only self contract can call this function\n        LibDiamond.enforceIsSelf();\n        // Should revert if guardian exist\n        if (0 != LibGuardian.guardianCount())\n            revert SignatureMigrationFacet__InvalidRouteWithGuardian();\n        {\n            _checkMigrationCutValidity(\n                _newVerificationFacet,\n                _newVerificationFuncSelectors\n            );\n        }\n        _migrateSignatureScheme(\n            _newVerificationFacet,\n            _newPublicKey,\n            _newVerificationFuncSelectors\n        );\n    }\n\n    // NOTE: Migration requires a pending period & confirmation from owner to prevent a\n    // single call changing the ownership of the wallet\n    /**\n     * @notice Migrate signature scheme when guardians exists. Verifies the signature of guardians and moves migration to pending state.\n     *       Which can then be finalized when pending period is over. Owner's approval is mandatory for migration to happen\n     * @param _newVerificationFacet Verification facet that will replace the existing verification facet\n     * @param _newPublicKey Public key that will be used for the new verification facet that replaces the previous one\n     * @param _newVerificationFuncSelectors Function Selectors of new verification facet that will be added to the diamond\n     * @param _approvers List of approvers. This could include owner\n     */\n    function migrateSignatureSchemeWithGuardian(\n        address _newVerificationFacet,\n        bytes calldata _newPublicKey,\n        bytes4[] calldata _newVerificationFuncSelectors,\n        address[] calldata _approvers,\n        bytes[] calldata _signatures\n    )\n        public\n        override\n        onlyWhenUnlocked\n        validateKeyType(_newPublicKey, _newVerificationFacet)\n    {\n        // Should revert if does not guardian exist\n        if (0 == LibGuardian.guardianCount())\n            revert SignatureMigrationFacet__InvalidRouteWithGuardian();\n        uint256 approversLength = _approvers.length;\n        if (approversLength != _signatures.length)\n            revert SignatureMigrationFacet__InvalidArrayLength();\n\n        {\n            _checkMigrationCutValidity(\n                _newVerificationFacet,\n                _newVerificationFuncSelectors\n            );\n        }\n        bytes32 migrationPublicKeyHash = getApprovalMigrationKeyHash(\n            _newPublicKey,\n            _newVerificationFacet,\n            _newVerificationFuncSelectors,\n            \"MigrateSignature\"\n        );\n\n        _checkApprover(_approvers);\n        _checkDuplicateOnChainApprover(migrationPublicKeyHash, _approvers);\n\n        bool onChainOwnerApproval = getMigrationOwnerApprovalWithTimeValidity(\n            migrationPublicKeyHash\n        );\n        uint256 threshold = onChainOwnerApproval ? 0 : 1;\n\n        if (\n            approversLength +\n                getMigrationApprovalCountWithTimeValidity(\n                    migrationPublicKeyHash\n                ) <\n            LibGuardian.majorityOfGuardians() + threshold\n        ) revert SignatureMigrationFacet__InsufficientApprovers();\n        {\n            // To prevent Stack too deep\n            bool ownerApproved;\n            for (uint256 i; i < approversLength; ) {\n                if (\n                    !LibGuardian.isGuardian(_approvers[i]) &&\n                    address(this) != _approvers[i]\n                ) revert SignatureMigrationFacet__InvalidGuardian();\n                if (_approvers[i] == address(this)) {\n                    if (onChainOwnerApproval)\n                        revert SignatureMigrationFacet__OwnerAlreadyApproved();\n                    ownerApproved = true;\n                }\n                if (\n                    !SignatureChecker.isValidSignatureNow(\n                        _approvers[i],\n                        migrationPublicKeyHash,\n                        _signatures[i]\n                    )\n                ) revert SignatureMigrationFacet__InvalidApproverSignature();\n                unchecked {\n                    ++i;\n                }\n            }\n\n            if (!ownerApproved && !onChainOwnerApproval)\n                revert SignatureMigrationFacet__LackOfOwnerApproval();\n        }\n        _migrateSignatureScheme(\n            _newVerificationFacet,\n            _newPublicKey,\n            _newVerificationFuncSelectors\n        );\n    }\n\n    /**\n     * @notice Internal function that moves signature mgiration to a pending state.\n     * @dev This method increments migration nonce and sets the migration in the migration config. Emits events for migration execution\n     * @param _newVerificationFacet Verification facet that will replace the existing verification facet\n     * @param _newPublicKey Public key that will be used for the new verification facet that replaces the previous one\n     * @param _newVerificationFuncSelectors Function Selectors of new verification facet that will be added to the diamond\n     */\n    function _migrateSignatureScheme(\n        address _newVerificationFacet,\n        bytes memory _newPublicKey,\n        bytes4[] memory _newVerificationFuncSelectors\n    ) internal {\n        SignatureMigrationStorage storage ms = LibFacetStorage\n            .migrationStorage();\n\n        ++ms.nonce;\n        uint64 migrateAfter = uint64(block.timestamp + getMigrationPeriod());\n\n        ms.migrationConfigs[INNER_STRUCT] = SignatureMigrationConfig(\n            _newPublicKey,\n            _newVerificationFacet,\n            _newVerificationFuncSelectors,\n            migrateAfter\n        );\n\n        emit SignatureMigrationExecuted(\n            _newVerificationFacet,\n            _newPublicKey,\n            _newVerificationFuncSelectors,\n            migrateAfter\n        );\n    }\n\n    /**\n     * @notice Approves signature scheme migration on-chain. This can be called by owner or guardian only when the account is unlocked.\n     *         When the threshold of the migration approval passed and owner approval is granted, it automatically moves migration to a pending state\n     * @param _newVerificationFacet Verification facet that will replace the existing verification facet\n     * @param _newPublicKey Public key that will be used for the new verification facet that replaces the previous one\n     * @param _newVerificationFuncSelectors Function Selectors of new verification facet that will be added to the diamond\n     */\n    function approveSignatureSchemeMigration(\n        address _newVerificationFacet,\n        bytes calldata _newPublicKey,\n        bytes4[] calldata _newVerificationFuncSelectors\n    )\n        public\n        override\n        onlyGuardianOrOwner\n        onlyWhenUnlocked\n        validateKeyType(_newPublicKey, _newVerificationFacet)\n    {\n        {\n            _checkMigrationCutValidity(\n                _newVerificationFacet,\n                _newVerificationFuncSelectors\n            );\n        }\n\n        SignatureMigrationApprovalConfig storage ms = LibFacetStorage\n            .migrationStorage()\n            .migrationApprovalConfigs[INNER_STRUCT];\n        bytes32 migrationPublicKeyHash = getApprovalMigrationKeyHash(\n            _newPublicKey,\n            _newVerificationFacet,\n            _newVerificationFuncSelectors,\n            \"MigrateSignature\"\n        );\n        uint64 approvalValidUntil = uint64(\n            block.timestamp + getApprovalValidationPeriod()\n        );\n        ms.isMigrationApproved[migrationPublicKeyHash][\n            msg.sender\n        ] = ApprovalConfig(true, approvalValidUntil);\n        emit SignatureMigrationApproved(\n            _newPublicKey,\n            _newVerificationFacet,\n            _newVerificationFuncSelectors,\n            msg.sender,\n            approvalValidUntil\n        );\n        if (\n            getMigrationApprovalCountWithTimeValidity(migrationPublicKeyHash) >=\n            LibGuardian.majorityOfGuardians() &&\n            getMigrationOwnerApprovalWithTimeValidity(migrationPublicKeyHash)\n        )\n            _migrateSignatureScheme(\n                _newVerificationFacet,\n                _newPublicKey,\n                _newVerificationFuncSelectors\n            );\n    }\n\n    /**\n     * @notice Revokes the approval of signature migration done on-chain. Emits revoke event when revoked.\n     * @param _newVerificationFacet Verification facet that will replace the existing verification facet\n     * @param _newPublicKey Public key that will be used for the new verification facet that replaces the previous one\n     * @param _newVerificationFuncSelectors Function Selectors of new verification facet that will be added to the diamond\n     */\n    function revokeSignatureMigrationApproval(\n        address _newVerificationFacet,\n        bytes calldata _newPublicKey,\n        bytes4[] calldata _newVerificationFuncSelectors\n    )\n        external\n        override\n        onlyGuardianOrOwner\n        onlyWhenUnlocked\n        validateKeyType(_newPublicKey, _newVerificationFacet)\n    {\n        SignatureMigrationApprovalConfig storage ms = LibFacetStorage\n            .migrationStorage()\n            .migrationApprovalConfigs[INNER_STRUCT];\n        bytes32 migrationPublicKeyHash = getApprovalMigrationKeyHash(\n            _newPublicKey,\n            _newVerificationFacet,\n            _newVerificationFuncSelectors,\n            \"MigrateSignature\"\n        );\n        if (!isMigrationApproved(migrationPublicKeyHash, msg.sender))\n            revert SignatureMigrationFacet__CannotRevokeUnapproved();\n\n        ms.isMigrationApproved[migrationPublicKeyHash][\n            msg.sender\n        ] = ApprovalConfig(false, 0);\n        emit SignatureMigrationApprovalRevoked(\n            _newPublicKey,\n            _newVerificationFacet,\n            _newVerificationFuncSelectors,\n            msg.sender\n        );\n    }\n\n    /**\n     * @notice Finalizes the pending signature scheme migration. This function can only be called by owner.\n     *         It removes the facets of the previous verification facet and adds the new verification facet.\n     *         After finalizing migration, it emits migration event which shows the change of the verification facet\n     */\n    function finalizeSignatureMigration() external override {\n        // NOTE: Only owner can call this function\n        LibDiamond.enforceIsSelf();\n\n        SignatureMigrationStorage storage ms = LibFacetStorage\n            .migrationStorage();\n\n        if (!isMigrationPending())\n            revert SignatureMigrationFacet__NonexistentMigration();\n\n        if (\n            uint64(block.timestamp) <=\n            ms.migrationConfigs[INNER_STRUCT].migrateAfter\n        ) revert SignatureMigrationFacet__MigrationPeriodNotOver();\n        address newVerificationFacet = ms\n            .migrationConfigs[INNER_STRUCT]\n            .migrationVerificationFacet;\n        bytes4[] memory newVerificationFuncSelectors = ms\n            .migrationConfigs[INNER_STRUCT]\n            .migrationSelectors;\n        bytes memory newPublicKey = ms\n            .migrationConfigs[INNER_STRUCT]\n            .migrationPublicKey;\n\n        address prevVerificationFacet = LibLoupe.facetAddress(\n            s.validateOwnerSignatureSelector\n        );\n        if (prevVerificationFacet == address(0))\n            revert SignatureMigrationFacet__NonExistentVerificationFacet();\n\n        IDiamondCut.FacetCut[] memory UninitCut;\n        IDiamondCut.FacetCut[] memory InitCut;\n        {\n            bytes4[] memory prevVerificationFuncSelectors = LibLoupe\n                .facetFunctionSelectors(prevVerificationFacet);\n\n            UninitCut = new IDiamondCut.FacetCut[](1);\n            InitCut = new IDiamondCut.FacetCut[](1);\n            UninitCut[0] = IDiamondCut.FacetCut({\n                facetAddress: address(0),\n                action: IDiamondCut.FacetCutAction.Remove,\n                functionSelectors: prevVerificationFuncSelectors\n            });\n            InitCut[0] = IDiamondCut.FacetCut({\n                facetAddress: newVerificationFacet,\n                action: IDiamondCut.FacetCutAction.Add,\n                functionSelectors: newVerificationFuncSelectors\n            });\n            {\n                IDiamondCut.FacetCut[]\n                    memory facetCuts = new IDiamondCut.FacetCut[](2);\n                facetCuts[0] = UninitCut[0];\n                facetCuts[1] = InitCut[0];\n                _checkFacetCutValidity(facetCuts);\n            }\n            LibAppStorage.initiateSignerMigration();\n            address verificationFacet = address(\n                bytes20(\n                    LibDiamond.diamondStorage().facets[\n                        s.validateOwnerSignatureSelector\n                    ]\n                )\n            );\n            bytes memory uninitCall = abi.encodeWithSignature(\n                \"uninitializeSigner()\"\n            );\n            (bool success, bytes memory result) = verificationFacet\n                .delegatecall(uninitCall);\n            require(success, \"MigrationFacet: uninitialize not successful\");\n            uint256 validationData = uint256(bytes32(result));\n            if (validationData == 0)\n                revert SignatureMigrationFacet__SignerUninitializationFailure();\n\n            LibDiamond.diamondCut(UninitCut, address(0), \"\");\n        }\n        {\n            bytes memory initCall = abi.encodeWithSignature(\n                \"initializeSigner(bytes)\",\n                newPublicKey\n            );\n\n            // Every Verification Facet should comply with initializeSigner(bytes)\n            // to be compatible with the Barz contract(for initialization)\n            LibDiamond.diamondCut(InitCut, newVerificationFacet, initCall);\n            LibAppStorage.finalizeSignerMigration();\n            emit SignatureSchemeMigration(\n                prevVerificationFacet,\n                newVerificationFacet,\n                newPublicKey,\n                newVerificationFuncSelectors\n            );\n        }\n    }\n\n    /**\n     * @notice Approve cancellation of signature migration. If cancellation approval passes guardian threshold with owner approval\n     *         it automatically cancels the migration.\n     * @dev This method checks if the caller is one of guardian or owner and sets true for the cancellation hash in the approval config.\n     *      It internally calls _cancelSignatureMigration for canceling the migration\n     * @param _newVerificationFacet Verification facet that will replace the existing verification facet\n     * @param _newPublicKey Public key that will be used for the new verification facet that replaces the previous one\n     * @param _newVerificationFuncSelectors Function Selectors of new verification facet that will be added to the diamond\n     */\n    function approveCancelSignatureMigration(\n        address _newVerificationFacet,\n        bytes calldata _newPublicKey,\n        bytes4[] calldata _newVerificationFuncSelectors\n    )\n        external\n        override\n        onlyGuardianOrOwner\n        onlyWhenUnlocked\n        validateKeyType(_newPublicKey, _newVerificationFacet)\n    {\n        SignatureMigrationApprovalConfig storage ms = LibFacetStorage\n            .migrationStorage()\n            .migrationApprovalConfigs[INNER_STRUCT];\n        bytes32 migrationPublicKeyHash = getApprovalMigrationKeyHash(\n            _newPublicKey,\n            _newVerificationFacet,\n            _newVerificationFuncSelectors,\n            \"CancelSignatureMigration\"\n        );\n        uint64 approvalValidUntil = uint64(\n            block.timestamp + getApprovalValidationPeriod()\n        );\n        ms.isMigrationApproved[migrationPublicKeyHash][\n            msg.sender\n        ] = ApprovalConfig(true, approvalValidUntil);\n        emit SignatureMigrationCancellationApproved(\n            _newVerificationFacet,\n            _newPublicKey,\n            _newVerificationFuncSelectors\n        );\n        if (\n            getMigrationApprovalCountWithTimeValidity(migrationPublicKeyHash) >=\n            LibGuardian.majorityOfGuardians() &&\n            getMigrationOwnerApprovalWithTimeValidity(migrationPublicKeyHash)\n        )\n            _cancelSignatureMigration(\n                _newVerificationFacet,\n                _newPublicKey,\n                _newVerificationFuncSelectors\n            );\n    }\n\n    /**\n     * @notice Verifies the signature of guardians/owner and cancels the signature migration.\n     * @param _newVerificationFacet Verification facet that will replace the existing verification facet\n     * @param _newPublicKey Public key that will be used for the new verification facet that replaces the previous one\n     * @param _newVerificationFuncSelectors Function Selectors of new verification facet that will be added to the diamond\n     * @param _approvers List of approvers. This could include owner\n     */\n    function cancelSignatureMigration(\n        address _newVerificationFacet,\n        bytes calldata _newPublicKey,\n        bytes4[] calldata _newVerificationFuncSelectors,\n        address[] calldata _approvers,\n        bytes[] calldata _signatures\n    )\n        external\n        override\n        validateKeyType(_newPublicKey, _newVerificationFacet)\n        onlyWhenUnlocked\n    {\n        uint256 approversLength = _approvers.length;\n        if (approversLength != _signatures.length)\n            revert SignatureMigrationFacet__InvalidArrayLength();\n\n        bytes32 migrationPublicKeyHash = getApprovalMigrationKeyHash(\n            _newPublicKey,\n            _newVerificationFacet,\n            _newVerificationFuncSelectors,\n            \"CancelSignatureMigration\"\n        );\n\n        _checkApprover(_approvers);\n        _checkDuplicateOnChainApprover(migrationPublicKeyHash, _approvers);\n\n        bool onChainOwnerApproval = getMigrationOwnerApprovalWithTimeValidity(\n            migrationPublicKeyHash\n        );\n        uint256 threshold = onChainOwnerApproval ? 0 : 1;\n        if (\n            approversLength +\n                getMigrationApprovalCountWithTimeValidity(\n                    migrationPublicKeyHash\n                ) <\n            LibGuardian.majorityOfGuardians() + threshold\n        ) revert SignatureMigrationFacet__InsufficientApprovers();\n        {\n            // To prevent stack too deep\n            bool ownerApproved;\n            for (uint256 i; i < approversLength; ) {\n                if (\n                    !LibGuardian.isGuardian(_approvers[i]) &&\n                    address(this) != _approvers[i]\n                ) revert SignatureMigrationFacet__NonExistentApprover();\n                if (_approvers[i] == address(this)) {\n                    if (onChainOwnerApproval)\n                        revert SignatureMigrationFacet__OwnerAlreadyApproved();\n                    ownerApproved = true;\n                }\n                if (\n                    !SignatureChecker.isValidSignatureNow(\n                        _approvers[i],\n                        migrationPublicKeyHash,\n                        _signatures[i]\n                    )\n                ) revert SignatureMigrationFacet__InvalidApproverSignature();\n                unchecked {\n                    ++i;\n                }\n            }\n            if (!ownerApproved && !onChainOwnerApproval)\n                revert SignatureMigrationFacet__LackOfOwnerApproval();\n        }\n        _cancelSignatureMigration(\n            _newVerificationFacet,\n            _newPublicKey,\n            _newVerificationFuncSelectors\n        );\n    }\n\n    /**\n     * @notice Internal function that cancels signature migration.\n     * @dev This method increments migration nonce and deletes the migration from the migration config. Emits events for migration cancellation\n     * @param _newVerificationFacet Verification facet that will replace the existing verification facet\n     * @param _newPublicKey Public key that will be used for the new verification facet that replaces the previous one\n     * @param _newVerificationFuncSelectors Function Selectors of new verification facet that will be added to the diamond\n     */\n    function _cancelSignatureMigration(\n        address _newVerificationFacet,\n        bytes memory _newPublicKey,\n        bytes4[] memory _newVerificationFuncSelectors\n    ) internal {\n        if (!isMigrationPending())\n            revert SignatureMigrationFacet__NonexistentMigration();\n        SignatureMigrationStorage storage ms = LibFacetStorage\n            .migrationStorage();\n        ++ms.nonce;\n        delete ms.migrationConfigs[INNER_STRUCT];\n        emit SignatureMigrationCanceled(\n            _newVerificationFacet,\n            _newPublicKey,\n            _newVerificationFuncSelectors\n        );\n    }\n\n    /**\n     * @notice Checks if the facets to be added from new verification facet is registered to facet registry\n     * @param _newVerificationFacet Verification facet that will replace the existing verification facet\n     * @param _newVerificationFuncSelectors Function Selectors of new verification facet that will be added to the diamond\n     */\n    function _checkMigrationCutValidity(\n        address _newVerificationFacet,\n        bytes4[] memory _newVerificationFuncSelectors\n    ) internal view {\n        IDiamondCut.FacetCut[] memory facetCuts = new IDiamondCut.FacetCut[](1);\n        facetCuts[0] = IDiamondCut.FacetCut({\n            facetAddress: _newVerificationFacet,\n            action: IDiamondCut.FacetCutAction.Add,\n            functionSelectors: _newVerificationFuncSelectors\n        });\n        _checkFacetCutValidity(facetCuts);\n    }\n\n    /**\n     * @notice Returns if the migration is pending of not\n     * @dev This method fetches the migration storage and checks if the migrate after is above 0 value\n     * @return isPending Bool value that shows if the migration is pending\n     */\n    function isMigrationPending()\n        public\n        view\n        override\n        returns (bool isPending)\n    {\n        SignatureMigrationStorage storage rs = LibFacetStorage\n            .migrationStorage();\n        isPending = rs.migrationConfigs[INNER_STRUCT].migrateAfter > 0;\n    }\n\n    /**\n     * @notice Returns the migration hash. This function ensures that this hash is safe from replay attack by including\n     *         public key, verification facet, function selectors, salt, address, chainId, and nonce.\n     * @param _newPublicKey Public key that will be used for the new verification facet that replaces the previous one\n     * @param _newVerificationFacet Verification facet that will replace the existing verification facet\n     * @param _newVerificationFuncSelectors Function Selectors of new verification facet that will be added to the diamond\n     * @param _saltString Salt value for generating the migration hash\n     * @return migrationKeyHash Bytes32 string of the migration key hash\n     */\n    function getApprovalMigrationKeyHash(\n        bytes memory _newPublicKey,\n        address _newVerificationFacet,\n        bytes4[] memory _newVerificationFuncSelectors,\n        string memory _saltString\n    ) public view override returns (bytes32 migrationKeyHash) {\n        migrationKeyHash = keccak256(\n            abi.encodePacked(\n                \"\\x19Ethereum Signed Message:\\n32\",\n                keccak256(\n                    abi.encode(\n                        _newPublicKey,\n                        _newVerificationFacet,\n                        keccak256(abi.encode(_newVerificationFuncSelectors)),\n                        _saltString,\n                        address(this),\n                        block.chainid,\n                        LibFacetStorage.migrationStorage().nonce\n                    )\n                )\n            )\n        );\n    }\n\n    /**\n     * @notice Checks if the owner approved the hash for migration\n     * @param _migrationPublicKeyHash Hash of the public key and configuration for migration\n     * @return isApprovedByOwner Bool value of showing if the owner approved it or not\n     */\n    function getMigrationOwnerApprovalWithTimeValidity(\n        bytes32 _migrationPublicKeyHash\n    ) public view override returns (bool isApprovedByOwner) {\n        isApprovedByOwner = isMigrationApproved(\n            _migrationPublicKeyHash,\n            address(this)\n        );\n    }\n\n    /**\n     * @notice Checks how many of the guardians approved the migration hash\n     * @param _migrationPublicKeyHash Hash of the public key and configuration for migration\n     * @return approvalCount Number of approvals\n     */\n    function getMigrationApprovalCountWithTimeValidity(\n        bytes32 _migrationPublicKeyHash\n    ) public view override returns (uint256 approvalCount) {\n        address[] memory guardians = LibGuardian.getGuardians();\n        uint256 guardiansLength = guardians.length;\n        for (uint256 i; i < guardiansLength; ) {\n            if (isMigrationApproved(_migrationPublicKeyHash, guardians[i])) {\n                unchecked {\n                    ++approvalCount;\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return approvalCount;\n    }\n\n    /**\n     * @notice Checks if the migration is approved by the given approver\n     * @param _migrationPublicKeyHash Hash of the public key and configuration for migration\n     * @param _approver Address of approver\n     * @return isApproved Bool value if migration hash is approved\n     */\n    function isMigrationApproved(\n        bytes32 _migrationPublicKeyHash,\n        address _approver\n    ) public view override returns (bool isApproved) {\n        SignatureMigrationApprovalConfig storage ms = LibFacetStorage\n            .migrationStorage()\n            .migrationApprovalConfigs[INNER_STRUCT];\n        isApproved = (ms\n        .isMigrationApproved[_migrationPublicKeyHash][_approver].isApproved &&\n            block.timestamp <\n            ms\n            .isMigrationApproved[_migrationPublicKeyHash][_approver]\n                .validUntil);\n    }\n\n    /**\n     * @notice Checks if their is duplicate approver is included in off-chain approval verification and on-chain approval\n     *         Approvers who approved on-chain should not be included in the off-chain approval\n     * @param _migrationPublicKeyHash Hash of migration information\n     * @param _approvers List of approver addresses\n     */\n    function _checkDuplicateOnChainApprover(\n        bytes32 _migrationPublicKeyHash,\n        address[] memory _approvers\n    ) public view {\n        address[] memory guardians = LibGuardian.getGuardians();\n        uint256 guardianLength = guardians.length;\n        uint256 approversLength = _approvers.length;\n        for (uint256 i; i < guardianLength; ) {\n            if (isMigrationApproved(_migrationPublicKeyHash, guardians[i])) {\n                for (uint256 j; j < approversLength; ) {\n                    if (_approvers[j] == guardians[i])\n                        revert SignatureMigrationFacet__DuplicateApproval();\n                    unchecked {\n                        ++j;\n                    }\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Returns the migration period of this wallet\n     * @dev This method fetches the migration period from the security manager\n     * @return migrationPeriod Migration period of Barz contract fetched from security manager\n     */\n    function getMigrationPeriod()\n        internal\n        view\n        returns (uint128 migrationPeriod)\n    {\n        migrationPeriod = securityManager.migrationPeriodOf(address(this));\n        if (migrationPeriod == 0)\n            revert SignatureMigrationFacet__InvalidMigrationPeriod();\n    }\n\n    /**\n     * @notice Returns the validation period of this wallet\n     * @dev This method fetches the validation period from the security manager\n     * @return approvalValidationPeriod Validation period of Barz contract fetched from security manager\n     */\n    function getApprovalValidationPeriod()\n        internal\n        view\n        returns (uint256 approvalValidationPeriod)\n    {\n        approvalValidationPeriod = securityManager.approvalValidationPeriodOf(\n            address(this)\n        );\n        if (approvalValidationPeriod == 0)\n            revert SignatureMigrationFacet__InvalidApprovalValidationPeriod();\n    }\n\n    /**\n     * @notice Returns the migration nonce of this wallet\n     * @dev This method fetches the nonce from migration storage\n     * @return migrationNonce Nonce of migration to protect from reply attacks\n     */\n    function getMigrationNonce()\n        public\n        view\n        override\n        returns (uint128 migrationNonce)\n    {\n        migrationNonce = LibFacetStorage.migrationStorage().nonce;\n    }\n\n    /**\n     * @notice Returns the migration configuration of this wallet\n     * @dev This method fetches the migration config from the migration storage\n     * @return pendingMigrationConfig Migration config currently pending for signature migration\n     */\n    function getPendingMigration()\n        external\n        view\n        override\n        returns (SignatureMigrationConfig memory pendingMigrationConfig)\n    {\n        pendingMigrationConfig = LibFacetStorage\n            .migrationStorage()\n            .migrationConfigs[INNER_STRUCT];\n    }\n}\n"
    },
    "contracts/facets/TokenReceiverFacet.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {IERC777Recipient} from \"@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol\";\nimport {IERC1155Receiver} from \"../interfaces/ERC/IERC1155Receiver.sol\";\nimport {IERC677Receiver} from \"../interfaces/ERC/IERC677Receiver.sol\";\n\n/**\n * @title TokenReceiver Facet\n * @dev Contract that enables receiving ERC721/ERC1155/ERC777/ERC677 Tokens with safe transfer\n * @author David Yongjun Kim (@Powerstream3604)\n */\ncontract TokenReceiverFacet is\n    IERC721Receiver,\n    IERC1155Receiver,\n    IERC777Recipient,\n    IERC677Receiver\n{\n    /**\n     * @notice Handles ERC721 Token callback.\n     *  return Standardized onERC721Received return value.\n     */\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        return IERC721Receiver.onERC721Received.selector;\n    }\n\n    /**\n     * @notice Handles ERC1155 Token callback.\n     * return Standardized onERC1155Received return value.\n     */\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        return IERC1155Receiver.onERC1155Received.selector;\n    }\n\n    /**\n     * @notice Handles ERC1155 Token batch callback.\n     * return Standardized onERC1155BatchReceived return value.\n     */\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        return IERC1155Receiver.onERC1155BatchReceived.selector;\n    }\n\n    /**\n     * @notice Handles ERC777 Token callback.\n     * Does not return value, empty implementation.\n     */\n    function tokensReceived(\n        address,\n        address,\n        address,\n        uint256,\n        bytes calldata,\n        bytes calldata\n    ) external pure override {}\n\n    /**\n     * @notice Handles ERC677 Token callback.\n     * return true.\n     */\n    function onTokenTransfer(\n        address,\n        uint256,\n        bytes calldata\n    ) external pure override returns (bool) {\n        return true;\n    }\n}\n"
    },
    "contracts/facets/verification/MultiSigFacet.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {SignatureChecker} from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport {UserOperation} from \"../../aa-4337/interfaces/UserOperation.sol\";\nimport {LibDiamond} from \"../../libraries/LibDiamond.sol\";\nimport {LibLoupe} from \"../../libraries/LibLoupe.sol\";\nimport {LibAppStorage} from \"../../libraries/LibAppStorage.sol\";\nimport {LibMultiSigStorage, MultiSigStorage} from \"../../libraries/LibMultiSigStorage.sol\";\nimport {IERC1271} from \"../../interfaces/ERC/IERC1271.sol\";\nimport {IVerificationFacet} from \"../interfaces/IVerificationFacet.sol\";\nimport {IMultiSigFacet} from \"../interfaces/IMultiSigFacet.sol\";\n\n/**\n * @title Multi-sig facet\n * @dev Multi-signature Facet with custom threshold.\n *      Wallet that adds this facet becomes a multi-sig wallet.\n *      Reference signature_format.md documentation for Multi-sig facet details\n * @author David Yongjun Kim (@Powerstream3604)\n */\ncontract MultiSigFacet is IMultiSigFacet, IVerificationFacet, IERC1271 {\n    using ECDSA for bytes32;\n\n    address public immutable self;\n\n    address internal constant SENTINEL_OWNERS = address(0x1);\n    uint256 internal constant ADDRESS = 20;\n    uint256 internal constant SIG_TYPE = 1;\n    uint256 internal constant SIG_LEN = 4;\n    uint256 internal constant THRESHOLD = 4;\n    uint256 internal constant INVALID_SIG = 1;\n    uint256 internal constant VALID_SIG = 0;\n\n    /**\n     * @notice This constructor ensures that this contract can only be used as singleton for Proxy contracts\n     */\n    constructor() {\n        LibAppStorage.enforceSignerInitialize();\n        self = address(this);\n    }\n\n    /**\n     * @notice Initializes the signer in Multisig Facet Storage. This can only be called when the account is uninitialized or during signature migration.\n     * @dev This method checks if the signer has already been initialized. If already initialized, it reverts.\n     *      It checks if the public key is in the right format and initializes signer storage in k1 storage.\n     * @param _owners Bytes of owner public key\n     * @return initSuccess Uint value representing the success of init operation\n     */\n    function initializeSigner(\n        bytes calldata _owners\n    ) public override returns (uint256 initSuccess) {\n        LibAppStorage.enforceSignerInitialize();\n\n        if (!isValidKeyType(_owners)) revert MultiSigFacet__InvalidInitData();\n\n        MultiSigStorage storage ms = LibMultiSigStorage.multisigStorage();\n\n        uint256 threshold = uint256(uint32(bytes4(_owners)));\n        uint256 ownerCount = (_owners.length - THRESHOLD) / ADDRESS;\n\n        if (threshold == 0) revert MultiSigFacet__InvalidThreshold();\n        if (ownerCount == 0) revert MultisigFacet__InvalidOwnerCount();\n\n        address currentOwner = SENTINEL_OWNERS;\n        uint256 ptr = THRESHOLD;\n        address owner_;\n        for (uint256 i; i < ownerCount; ) {\n            owner_ = address(bytes20(_owners[ptr:ptr + ADDRESS]));\n            ptr += ADDRESS;\n            if (\n                owner_ == address(0) ||\n                owner_ == SENTINEL_OWNERS ||\n                owner_ == address(this) ||\n                owner_ == currentOwner\n            ) revert MultiSigFacet__InvalidOwnerAddress();\n            if (ms.owners[owner_] != address(0))\n                revert MultiSigFacet__DuplicateOwner();\n\n            ms.owners[currentOwner] = owner_;\n            currentOwner = owner_;\n\n            unchecked {\n                ++i;\n            }\n        }\n        ms.owners[currentOwner] = SENTINEL_OWNERS;\n        ms.ownerCount = ownerCount;\n        ms.threshold = threshold;\n\n        bytes4 validateSelector = validateOwnerSignatureSelector();\n\n        if (LibAppStorage.getValidateOwnerSignatureSelector() != bytes4(0))\n            revert VerificationFacet__ValidateOwnerSignatureSelectorAlreadySet();\n        if (LibLoupe.facetAddress(validateSelector) != self)\n            revert VerificationFacet__InvalidFacetMapping();\n\n        // initialize verification function selector\n        LibAppStorage.setValidateOwnerSignatureSelector(validateSelector);\n\n        initSuccess = 1;\n\n        emit SignerInitialized(_owners);\n    }\n\n    /**\n     * @notice Uninitialize signer in K1 Facet Storage. This can only be called when the account is undergoing signature migration\n     *         and has already been initialized.\n     * @dev This method checks if the signature migration is undergoing, signer is initialized and sets the signer to zero value.\n     * @return uninitSuccess Uint value representing the success of uninit operation\n     */\n    function uninitializeSigner()\n        external\n        override\n        returns (uint256 uninitSuccess)\n    {\n        LibAppStorage.enforceSignerMigration();\n        LibAppStorage.setSignerUninitialized();\n\n        MultiSigStorage storage ms = LibMultiSigStorage.multisigStorage();\n        ++ms.counter;\n        address[] memory ownerlist = getOwners();\n        uint256 ownerlistLength = ownerlist.length;\n        for (uint256 i; i < ownerlistLength; ) {\n            ms.owners[ownerlist[i]] = address(0);\n            unchecked {\n                ++i;\n            }\n        }\n        ms.owners[SENTINEL_OWNERS] = address(0);\n\n        if (LibAppStorage.getValidateOwnerSignatureSelector() == bytes4(0))\n            revert VerificationFacet__ValidateOwnerSignatureSelectorNotSet();\n        LibAppStorage.setValidateOwnerSignatureSelector(bytes4(0));\n\n        uninitSuccess = 1;\n\n        emit SignerUninitialized();\n    }\n\n    /**\n     * @notice Validates if the user operation is signed by the owner.\n     * @dev This method validates if the user operation is signed by the owner. It internally calls checkSignatures with\n     *      user operation hash and signature together with the threshold.\n     * @param userOp UserOperation including all information for execution\n     * @param userOpHash Hash of UserOperation given from EntryPoint. This hash is used for signature validation\n     * @return validationData Uint value representing whether the validation is successful. 0 for success, 1 for failure\n     */\n    function validateOwnerSignature(\n        UserOperation calldata userOp,\n        bytes32 userOpHash\n    ) public view override returns (uint256 validationData) {\n        // Data 1 is invalid, Data 0 is valid\n        validationData = checkSignatures(\n            userOpHash,\n            userOp.signature,\n            LibMultiSigStorage.multisigStorage().threshold\n        );\n    }\n\n    /**\n     * @notice Returns the selector of function to validate the signature of UserOperation\n     * @return ownerSignatureValidatorSelector Bytes4 selector of function signature to validate account owner's UserOperation signature\n     */\n    function validateOwnerSignatureSelector()\n        public\n        pure\n        override\n        returns (bytes4 ownerSignatureValidatorSelector)\n    {\n        return this.validateOwnerSignature.selector;\n        // The signature name could change according to the facet but the param format(UserOp, UserOpHash) should not change\n    }\n\n    /**\n     * @notice Returns the owner of the account\n     * @return signer Bytes of owner address\n     */\n    function owner() public view override returns (bytes memory) {\n        MultiSigStorage storage ms = LibMultiSigStorage.multisigStorage();\n\n        uint totalLength = ms.ownerCount * ADDRESS;\n        bytes memory result = new bytes(totalLength);\n\n        // populate return array\n        uint256 index;\n        address currentOwner = ms.owners[SENTINEL_OWNERS];\n        while (currentOwner != SENTINEL_OWNERS) {\n            assembly {\n                mstore(\n                    add(result, add(32, mul(index, ADDRESS))),\n                    shl(96, currentOwner)\n                )\n            }\n            currentOwner = ms.owners[currentOwner];\n            index++;\n        }\n\n        return result;\n    }\n\n    /**\n     * @notice Validates if the format of public key is valid for this verification facet\n     * @dev For this Secp256k1Verification Facet, the public key should comply with the format in the signature_format.md doc\n     * @param _publicKey Bytes of public key for format check\n     * @return isValid Boolean variable representing if the format of public key is valid\n     */\n    function isValidKeyType(\n        bytes memory _publicKey\n    ) public pure override returns (bool isValid) {\n        uint256 publicKeyLength = _publicKey.length;\n        if (\n            publicKeyLength < ADDRESS + THRESHOLD ||\n            (publicKeyLength - THRESHOLD) % ADDRESS != 0\n        ) return false;\n\n        uint256 threshold = uint256(uint32(bytes4(_publicKey)));\n        uint256 ownerCount = (publicKeyLength - THRESHOLD) / ADDRESS;\n\n        isValid = !(ownerCount < threshold || threshold == 0);\n    }\n\n    /**\n     * @notice Validates if the signature is valid. Function to be compatible with EIP-1271\n     * @dev This method verifies the signature if the owner indeed signed the hash. Returns magic value if true\n     * @param _hash Hash value the owner signed\n     * @param _signature Signature that signed the above hash\n     * @return magicValue Bytes4 value representing the success/failure of validation\n     */\n    function isValidSignature(\n        bytes32 _hash,\n        bytes calldata _signature\n    ) public view override returns (bytes4 magicValue) {\n        magicValue = (checkSignatures(\n            _hash,\n            _signature,\n            LibMultiSigStorage.multisigStorage().threshold\n        ) == VALID_SIG)\n            ? this.isValidSignature.selector\n            : bytes4(0xffffffff);\n    }\n\n    /**\n     * @notice Validates the format of the signature and verifies if the signature is signed by the expected key.\n     *         Reference signature_format.md doc for details about signature format and signature types\n     * @param _dataHash Bytes value of data hash signed by the owners\n     * @param _signatures Bytes value of signature which should comply with signature format\n     * @param _threshold Uint256 value of current Multi-sig Barz's threshold\n     */\n    function checkSignatures(\n        bytes32 _dataHash,\n        bytes calldata _signatures,\n        uint256 _threshold\n    ) public view returns (uint256) {\n        MultiSigStorage storage ms = LibMultiSigStorage.multisigStorage();\n\n        address lastOwner = address(0);\n        address currentOwner;\n        bytes memory signature;\n        uint256 signatureType;\n        uint256 nextOffset;\n        uint256 i;\n        for (i; i < _threshold; ) {\n            (\n                currentOwner,\n                signature,\n                signatureType,\n                nextOffset\n            ) = splitSignatures(_signatures, nextOffset);\n            if (nextOffset == 0 && i + 1 < _threshold) return INVALID_SIG;\n            if (signatureType == 1) {\n                // If signatureType is 1 then it is default dataHash signed.\n                // This also includes the contract signature\n                if (\n                    !SignatureChecker.isValidSignatureNow(\n                        currentOwner,\n                        _dataHash,\n                        signature\n                    )\n                ) return INVALID_SIG;\n            } else if (signatureType == 2) {\n                // If signatureType is 2 then it is an approved hash\n                if (ms.approvedHashes[ms.counter][currentOwner][_dataHash] == 0)\n                    return INVALID_SIG;\n            } else if (signatureType == 3) {\n                // If signatureType is 3 then it is a signed message hash\n                // This also includes the contract signature\n                bytes32 msgHash = _dataHash.toEthSignedMessageHash();\n                if (\n                    !SignatureChecker.isValidSignatureNow(\n                        currentOwner,\n                        msgHash,\n                        signature\n                    )\n                ) return INVALID_SIG;\n            } else revert MultiSigFacet__InvalidRoute();\n            if (\n                currentOwner <= lastOwner ||\n                ms.owners[currentOwner] == address(0) ||\n                currentOwner == SENTINEL_OWNERS\n            ) return INVALID_SIG;\n            lastOwner = currentOwner;\n\n            unchecked {\n                ++i;\n            }\n        }\n        return VALID_SIG;\n    }\n\n    /**\n     * @notice Split signatures into each individual signatures. Should comply with signature format to be split\n     * @param _signatures Bytes value of signature\n     * @param _nextOffset Uint256 value of next offset to start splitting the signature\n     */\n    function splitSignatures(\n        bytes calldata _signatures,\n        uint256 _nextOffset\n    )\n        public\n        pure\n        returns (\n            address owner_,\n            bytes memory signature,\n            uint256 signatureType,\n            uint256 nextOffset\n        )\n    {\n        uint256 signaturesLength = _signatures.length;\n\n        if (signaturesLength <= _nextOffset + ADDRESS + SIG_LEN)\n            revert MultiSigFacet__InsufficientSignerLength();\n\n        owner_ = address(\n            bytes20(_signatures[_nextOffset:_nextOffset + ADDRESS])\n        );\n\n        signatureType = uint256(\n            uint8(\n                bytes1(\n                    _signatures[_nextOffset + ADDRESS:_nextOffset +\n                        ADDRESS +\n                        SIG_TYPE]\n                )\n            )\n        );\n\n        if (signatureType > 3 || signatureType == 0)\n            revert MultiSigFacet__InvalidSignatureType();\n        uint256 offSet = _nextOffset + ADDRESS + SIG_TYPE;\n        uint256 siglen = uint256(\n            uint32(bytes4(_signatures[offSet:offSet + SIG_LEN]))\n        );\n        if (offSet + siglen > signaturesLength)\n            revert MultiSigFacet__InvalidSignatureLength();\n\n        offSet += SIG_LEN;\n        if (offSet + siglen == signaturesLength) nextOffset = 0;\n        else nextOffset = offSet + siglen;\n\n        signature = _signatures[offSet:offSet + siglen];\n    }\n\n    /**\n     * @notice Approves the hash of userOperation on-chain. This can only be called by owners.\n     * @param _hashToApprove Bytes value of UserOperation hash to approve\n     */\n    function approveHash(bytes32 _hashToApprove) external {\n        MultiSigStorage storage ms = LibMultiSigStorage.multisigStorage();\n\n        if (ms.owners[msg.sender] == address(0))\n            revert MultiSigFacet__OnlyOwner();\n\n        ms.approvedHashes[ms.counter][msg.sender][_hashToApprove] = 1;\n        emit HashApproved(_hashToApprove, msg.sender);\n    }\n\n    /**\n     * @notice Add owner to Barz. Update thresold if threshold is given different from current threshold\n     * @dev This can only be done via a Self call.\n     * @param _newOwner Address of new owner to be added\n     * @param _threshold Uint256 value of threshold\n     */\n    function addOwner(address _newOwner, uint256 _threshold) external {\n        LibDiamond.enforceIsSelf();\n\n        MultiSigStorage storage ms = LibMultiSigStorage.multisigStorage();\n\n        if (\n            _newOwner == address(0) ||\n            _newOwner == SENTINEL_OWNERS ||\n            _newOwner == address(this)\n        ) revert MultiSigFacet__InvalidOwnerAddress();\n        if (ms.owners[_newOwner] != address(0))\n            revert MultiSigFacet__DuplicateOwner();\n\n        ms.owners[_newOwner] = ms.owners[SENTINEL_OWNERS];\n        ms.owners[SENTINEL_OWNERS] = _newOwner;\n        ++ms.ownerCount;\n        emit OwnerAdded(_newOwner);\n\n        if (ms.threshold != _threshold) changeThreshold(_threshold);\n    }\n\n    /**\n     * @notice Remove owner from Barz. Update thresold if threshold is given different from current threshold\n     * @dev This can only be done via a Self call.\n     * @param _prevOwner Address of owner located right behind the removed owner address in the linked list\n     * @param _removedOwner Address of owner to be removed\n     * @param _threshold Uint256 value of threshold\n     */\n    function removeOwner(\n        address _prevOwner,\n        address _removedOwner,\n        uint256 _threshold\n    ) external {\n        LibDiamond.enforceIsSelf();\n\n        MultiSigStorage storage ms = LibMultiSigStorage.multisigStorage();\n\n        if (ms.ownerCount - 1 < _threshold)\n            revert MultiSigFacet__InvalidThreshold();\n        if (_removedOwner == address(0) || _removedOwner == SENTINEL_OWNERS)\n            revert MultiSigFacet__InvalidOwnerAddress();\n        if (ms.owners[_prevOwner] != _removedOwner)\n            revert MultiSigFacet__InvalidOwnerPair();\n\n        ms.owners[_prevOwner] = ms.owners[_removedOwner];\n        ms.owners[_removedOwner] = address(0);\n        --ms.ownerCount;\n        emit OwnerRemoved(_removedOwner);\n\n        if (ms.threshold != _threshold) changeThreshold(_threshold);\n    }\n\n    /**\n     * @notice Swap owner in Barz.\n     * @dev This can only be done via a Self call.\n     * @param _prevOwner Address of owner located right behind the removed owner address in the linked list\n     * @param _oldOwner Address of owner to be removed\n     * @param _newOwner Address of owner to be added\n     */\n    function swapOwner(\n        address _prevOwner,\n        address _oldOwner,\n        address _newOwner\n    ) public {\n        LibDiamond.enforceIsSelf();\n\n        MultiSigStorage storage ms = LibMultiSigStorage.multisigStorage();\n\n        if (\n            _newOwner == address(0) ||\n            _newOwner == SENTINEL_OWNERS ||\n            _newOwner == address(this)\n        ) revert MultiSigFacet__InvalidOwnerAddress();\n        if (ms.owners[_newOwner] != address(0))\n            revert MultiSigFacet__DuplicateOwner();\n        if (_oldOwner == address(0) || _oldOwner == SENTINEL_OWNERS)\n            revert MultiSigFacet__InvalidOwnerAddress();\n        if (ms.owners[_prevOwner] != _oldOwner)\n            revert MultiSigFacet__InvalidOwnerPair();\n\n        ms.owners[_newOwner] = ms.owners[_oldOwner];\n        ms.owners[_prevOwner] = _newOwner;\n        ms.owners[_oldOwner] = address(0);\n        emit OwnerRemoved(_oldOwner);\n        emit OwnerAdded(_newOwner);\n    }\n\n    /**\n     * @notice Changes the threshold of the Barz to `_threshold`.\n     * @dev This can only be done via a Self call.\n     * @param _threshold New threshold\n     */\n    function changeThreshold(uint256 _threshold) public {\n        LibDiamond.enforceIsSelf();\n\n        MultiSigStorage storage ms = LibMultiSigStorage.multisigStorage();\n\n        if (_threshold > ms.ownerCount || _threshold == 0)\n            revert MultiSigFacet__InvalidThreshold();\n\n        ms.threshold = _threshold;\n        emit ThresholdChanged(_threshold);\n    }\n\n    /**\n     * @notice Checks if the given address is owner\n     * @param _owner Address to be checked if it's owner\n     * @return isOwner_ Bool value showing if it's owner address\n     */\n    function isOwner(address _owner) public view returns (bool isOwner_) {\n        isOwner_ = (_owner != SENTINEL_OWNERS &&\n            LibMultiSigStorage.multisigStorage().owners[_owner] != address(0));\n    }\n\n    /**\n     * @notice Returns the threshold of Barz\n     * @return threshold Threshold of the Barz account\n     */\n    function getThreshold() public view returns (uint256 threshold) {\n        threshold = LibMultiSigStorage.multisigStorage().threshold;\n    }\n\n    /**\n     * @notice Returns the list of owner addresses\n     * @return owners List of owners\n     */\n    function getOwners() public view returns (address[] memory owners) {\n        MultiSigStorage storage ms = LibMultiSigStorage.multisigStorage();\n        owners = new address[](ms.ownerCount);\n\n        uint256 index;\n        address currentOwner = ms.owners[SENTINEL_OWNERS];\n        while (currentOwner != SENTINEL_OWNERS) {\n            owners[index] = currentOwner;\n            currentOwner = ms.owners[currentOwner];\n            index++;\n        }\n    }\n\n    /**\n     * @notice Returns the previous owner in the linked list\n     * @param _owner Address of owner\n     * @return prevOwner Address of previous owner\n     */\n    function getPrevOwner(\n        address _owner\n    ) public view returns (address prevOwner) {\n        MultiSigStorage storage ms = LibMultiSigStorage.multisigStorage();\n\n        address currentOwner = ms.owners[SENTINEL_OWNERS];\n        if (currentOwner == _owner) return SENTINEL_OWNERS;\n        while (currentOwner != SENTINEL_OWNERS) {\n            if (ms.owners[currentOwner] == _owner) return currentOwner;\n\n            currentOwner = ms.owners[currentOwner];\n        }\n        return address(0);\n    }\n\n    /**\n     * @notice Returns of the owner is approved by given owner address\n     * @param _owner Address of owner\n     * @param _hash Hash of UserOperation\n     * @return isApproved Bool value showing if the hash is approved by owner\n     */\n    function isApprovedHash(\n        address _owner,\n        bytes32 _hash\n    ) public view returns (bool isApproved) {\n        MultiSigStorage storage ms = LibMultiSigStorage.multisigStorage();\n        isApproved = (ms.approvedHashes[ms.counter][_owner][_hash] == 1);\n    }\n}\n"
    },
    "contracts/facets/verification/secp256k1/Secp256k1VerificationFacet.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {UserOperation} from \"../../../aa-4337/interfaces/UserOperation.sol\";\nimport {LibAppStorage} from \"../../../libraries/LibAppStorage.sol\";\nimport {LibFacetStorage, Secp256k1VerificationStorage} from \"../../../libraries/LibFacetStorage.sol\";\nimport {LibLoupe} from \"../../../libraries/LibLoupe.sol\";\nimport {IERC1271} from \"../../../interfaces/ERC/IERC1271.sol\";\nimport {IVerificationFacet} from \"../../interfaces/IVerificationFacet.sol\";\n\n/**\n * @title Secp256k1 verification facet\n * @dev Default Ethereum's elliptic curve\n * @author David Yongjun Kim (@Powerstream3604)\n * @author Ruslan Serebriakov (@rsrbk)\n */\ncontract Secp256k1VerificationFacet is IVerificationFacet, IERC1271 {\n    using ECDSA for bytes32;\n    error Secp256k1VerificationFacet__InvalidSignerLength();\n    address public immutable self;\n\n    /**\n     * @notice This constructor ensures that this contract can only be used as singleton for Proxy contracts\n     */\n    constructor() {\n        LibAppStorage.enforceSignerInitialize();\n        self = address(this);\n    }\n\n    /**\n     * @notice Initializes the signer in K1 Facet Storage. This can only be called when the account is uninitialized or during signature migration.\n     * @dev This method checks if the signer has already been initialized. If already initialized, it reverts.\n     *      It checks if the public key is in the light format and initializes signer storage in k1 storage.\n     * @param _publicKey Bytes of owner public key\n     * @return initSuccess Uint value representing the success of init operation\n     */\n    function initializeSigner(\n        bytes calldata _publicKey\n    ) public override returns (uint256 initSuccess) {\n        LibAppStorage.enforceSignerInitialize();\n        if (!isValidKeyType(_publicKey))\n            revert Secp256k1VerificationFacet__InvalidSignerLength();\n\n        Secp256k1VerificationStorage storage k1Storage = LibFacetStorage\n            .k1Storage();\n        k1Storage.signer = address(uint160(uint256(keccak256(_publicKey[1:]))));\n\n        bytes4 validateSelector = validateOwnerSignatureSelector();\n\n        if (LibAppStorage.getValidateOwnerSignatureSelector() != bytes4(0))\n            revert VerificationFacet__ValidateOwnerSignatureSelectorAlreadySet();\n        if (LibLoupe.facetAddress(validateSelector) != self)\n            revert VerificationFacet__InvalidFacetMapping();\n\n        // initialize verification function selector\n        LibAppStorage.setValidateOwnerSignatureSelector(validateSelector);\n\n        initSuccess = 1;\n\n        emit SignerInitialized(_publicKey);\n    }\n\n    /**\n     * @notice Uninitialize signer in K1 Facet Storage. This can only be called when the account is undergoing signature migration\n     *         and has already been initialized.\n     * @dev This method checks if the signature migration is undergoing, signer is initialized and sets the signer to zero value.\n     * @return uninitSuccess Uint value representing the success of uninit operation\n     */\n    function uninitializeSigner()\n        external\n        override\n        returns (uint256 uninitSuccess)\n    {\n        LibAppStorage.enforceSignerMigration();\n        LibAppStorage.setSignerUninitialized();\n        Secp256k1VerificationStorage storage k1Storage = LibFacetStorage\n            .k1Storage();\n        k1Storage.signer = address(0);\n\n        if (LibAppStorage.getValidateOwnerSignatureSelector() == bytes4(0))\n            revert VerificationFacet__ValidateOwnerSignatureSelectorNotSet();\n        LibAppStorage.setValidateOwnerSignatureSelector(bytes4(0));\n\n        uninitSuccess = 1;\n\n        emit SignerUninitialized();\n    }\n\n    /**\n     * @notice Validates if the user operation is signed by the owner.\n     * @dev This method validates if the user operation is signed by the owner. It internally calls validateSignature with\n     *      signer public key.\n     * @param userOp UserOperation including all information for execution\n     * @param userOpHash Hash of UserOperation given from EntryPoint. This hash is used for signature validation\n     * @return validationData Uint value representing whether the validation is successful. 0 for success, 1 for failure\n     */\n    function validateOwnerSignature(\n        UserOperation calldata userOp,\n        bytes32 userOpHash\n    ) public view override returns (uint256 validationData) {\n        Secp256k1VerificationStorage storage k1Storage = LibFacetStorage\n            .k1Storage();\n        validationData = validateSignature(\n            userOp,\n            userOpHash,\n            k1Storage.signer\n        );\n    }\n\n    /**\n     * @notice Validates if the signature of UserOperation is signed by the given signer\n     * @dev This method uses OpenZeppelin library to validate if the signature of UserOperation is signed by the signer address\n     * @param userOp UserOperation including all information for execution\n     * @param userOpHash Hash of UserOperation given from EntryPoint. This hash is used for signature validation\n     * @param signer Address of signer who signed the contract, to be validated\n     * @return isValid Uint value representing whether the validation is successful. 0 for success, 1 for failure\n     */\n    function validateSignature(\n        UserOperation calldata userOp,\n        bytes32 userOpHash,\n        address signer\n    ) public pure returns (uint256 isValid) {\n        bytes32 hash = userOpHash.toEthSignedMessageHash();\n        isValid = (signer != hash.recover(userOp.signature)) ? 1 : 0;\n    }\n\n    /**\n     * @notice Returns the selector of function to validate the signature of UserOperation\n     * @return ownerSignatureValidatorSelector Bytes4 selector of function signature to validate account owner's UserOperation signature\n     */\n    function validateOwnerSignatureSelector()\n        public\n        pure\n        override\n        returns (bytes4 ownerSignatureValidatorSelector)\n    {\n        ownerSignatureValidatorSelector = this.validateOwnerSignature.selector;\n        // NOTE: The signature name could change according to the facet but the param format(UserOp, UserOpHash) should not change\n    }\n\n    /**\n     * @notice Returns the owner of the account\n     * @return signer Bytes of owner address\n     */\n    function owner() public view override returns (bytes memory signer) {\n        Secp256k1VerificationStorage storage k1Storage = LibFacetStorage\n            .k1Storage();\n        signer = abi.encodePacked(k1Storage.signer);\n    }\n\n    /**\n     * @notice Validates if the format of public key is valid for this verification facet\n     * @dev For this Secp256k1Verification Facet, the public key length should be 65 in an uncompressed public key format\n     * @param _publicKey Bytes of public key for format check\n     * @return isValid Boolean variable representing if the format of public key is valid\n     */\n    function isValidKeyType(\n        bytes memory _publicKey\n    ) public pure override returns (bool isValid) {\n        isValid = (_publicKey.length == 65 && _publicKey[0] == 0x04);\n    }\n\n    /**\n     * @notice Validates if the signature is valid. Function to be compatible with EIP-1271\n     * @dev This method verifies the signature if the owner indeed signed the hash. Returns magic value if true\n     * @param _hash Hash value the owner signed\n     * @param _signature Signature that signed the above hash\n     * @return magicValue Bytes4 value representing the success/failure of validation\n     */\n    function isValidSignature(\n        bytes32 _hash,\n        bytes memory _signature\n    ) public view override returns (bytes4 magicValue) {\n        magicValue = (_hash.recover(_signature) ==\n            LibFacetStorage.k1Storage().signer)\n            ? this.isValidSignature.selector\n            : bytes4(0xffffffff);\n    }\n}\n"
    },
    "contracts/facets/verification/secp256r1/Secp256r1VerificationFacet.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {UserOperation} from \"../../../aa-4337/interfaces/UserOperation.sol\";\nimport {LibAppStorage} from \"../../../libraries/LibAppStorage.sol\";\nimport {LibLoupe} from \"../../../libraries/LibLoupe.sol\";\nimport {LibFacetStorage, Secp256r1VerificationStorage} from \"../../../libraries/LibFacetStorage.sol\";\nimport {Base64} from \"./utils/Base64.sol\";\nimport {LibSecp256r1} from \"./utils/LibSecp256r1.sol\";\nimport {IERC1271} from \"../../../interfaces/ERC/IERC1271.sol\";\nimport {IVerificationFacet} from \"../../interfaces/IVerificationFacet.sol\";\n\n/**\n * @title Secp256r1 verification facet\n * @dev Primarily used to verify user ops signed with passkeys\n * @author Ruslan Serebriakov (@rsrbk)\n * @author David Yongjun Kim (@Powerstream3604)\n */\ncontract Secp256r1VerificationFacet is IVerificationFacet, IERC1271 {\n    error Secp256r1VerificationFacet__InvalidSignerLength();\n    address public immutable self;\n\n    /**\n     * @notice This constructor ensures that this contract can only be used as singleton for Proxy contracts\n     */\n    constructor() {\n        LibAppStorage.enforceSignerInitialize();\n        self = address(this);\n    }\n\n    /**\n     * @notice Initializes the signer in R1 Facet Storage. This can only be called when the account is uninitialized or during signature migration.\n     * @dev This method checks if the signer has already been initialized. If already initialized, it reverts.\n     *      It checks if the public key is in the light format and initializes signer storage in k1 storage.\n     * @param _publicKey Bytes of owner public key\n     * @return initSuccess Uint value representing the success of init operation\n     */\n    function initializeSigner(\n        bytes calldata _publicKey\n    ) public override returns (uint256 initSuccess) {\n        LibAppStorage.enforceSignerInitialize();\n\n        if (!isValidKeyType(_publicKey))\n            revert Secp256r1VerificationFacet__InvalidSignerLength();\n\n        bytes memory publicKeyCoordinates = _publicKey[1:];\n        uint256[2] memory q;\n        assembly {\n            // Copy the bytes from the input data into the uint256 array\n            mstore(q, mload(add(publicKeyCoordinates, 32)))\n            mstore(add(q, 32), mload(add(publicKeyCoordinates, 64)))\n        }\n        Secp256r1VerificationStorage storage r1Storage = LibFacetStorage\n            .r1Storage();\n        r1Storage.q = q;\n\n        bytes4 validateSelector = validateOwnerSignatureSelector();\n\n        if (LibAppStorage.getValidateOwnerSignatureSelector() != bytes4(0))\n            revert VerificationFacet__ValidateOwnerSignatureSelectorAlreadySet();\n        if (LibLoupe.facetAddress(validateSelector) != self)\n            revert VerificationFacet__InvalidFacetMapping();\n\n        // initialize verification function selector\n        LibAppStorage.setValidateOwnerSignatureSelector(validateSelector);\n\n        initSuccess = 1;\n\n        emit SignerInitialized(_publicKey);\n    }\n\n    /**\n     * @notice Uninitialize signer in R1 Facet Storage. This can only be called when the account is undergoing signature migration\n     *         and has already been initialized.\n     * @dev This method checks if the signature migration is undergoing, signer is initialized and sets the signer to zero value.\n     * @return uninitSuccess Uint value representing the success of uninit operation\n     */\n    function uninitializeSigner()\n        external\n        override\n        returns (uint256 uninitSuccess)\n    {\n        LibAppStorage.enforceSignerMigration();\n        LibAppStorage.setSignerUninitialized();\n        Secp256r1VerificationStorage storage r1Storage = LibFacetStorage\n            .r1Storage();\n        r1Storage.q = [0, 0];\n\n        if (LibAppStorage.getValidateOwnerSignatureSelector() == bytes4(0))\n            revert VerificationFacet__ValidateOwnerSignatureSelectorNotSet();\n        LibAppStorage.setValidateOwnerSignatureSelector(bytes4(0));\n\n        uninitSuccess = 1;\n\n        emit SignerUninitialized();\n    }\n\n    /**\n     * @notice Validates if the user operation is signed by the owner.\n     * @dev This method validates if the user operation is signed by the owner. It internally calls validateSignature with\n     *      signer public key.\n     * @param userOp UserOperation including all information for execution\n     * @param userOpHash Hash of UserOperation given from EntryPoint. This hash is used for signature validation\n     * @return validationData Uint value representing whether the validation is successful. 0 for success, 1 for failure\n     */\n    function validateOwnerSignature(\n        UserOperation calldata userOp,\n        bytes32 userOpHash\n    ) public view override returns (uint256 validationData) {\n        Secp256r1VerificationStorage storage r1Storage = LibFacetStorage\n            .r1Storage();\n        validationData = validateSignature(userOp, userOpHash, r1Storage.q);\n    }\n\n    /**\n     * @notice Validates if the signature of UserOperation is signed by the given signer\n     * @dev This method uses OpenZeppelin library to validate if the signature of UserOperation is signed by the signer address\n     * @param userOp UserOperation including all information for execution\n     * @param userOpHash Hash of UserOperation given from EntryPoint. This hash is used for signature validation\n     * @param q Public Key of signer who signed the contract, to be validated\n     * @return isValid Uint value representing whether the validation is successful. 0 for success, 1 for failure\n     */\n    function validateSignature(\n        UserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256[2] memory q\n    ) public view returns (uint256 isValid) {\n        isValid = (_validateSignature(q, userOpHash, userOp.signature)) ? 0 : 1;\n    }\n\n    /**\n     * @notice Returns the selector of function to validate the signature of UserOperation\n     * @return ownerSignatureValidatorSelector Bytes4 selector of function signature to validate account owner's UserOperation signature\n     */\n    function validateOwnerSignatureSelector()\n        public\n        pure\n        override\n        returns (bytes4 ownerSignatureValidatorSelector)\n    {\n        return this.validateOwnerSignature.selector; // validateOwnerSignature(UserOperation calldata userOp,bytes32 userOpHash)\n        // The signature name could change according to the facet but the param format(UserOp, UserOpHash) should not change\n    }\n\n    /**\n     * @notice Returns the owner of the account\n     * @return signer Bytes of owner address\n     */\n    function owner() public view override returns (bytes memory signer) {\n        Secp256r1VerificationStorage storage r1Storage = LibFacetStorage\n            .r1Storage();\n        signer = abi.encodePacked(r1Storage.q);\n    }\n\n    /**\n     * @notice Validates if the format of public key is valid for this verification facet\n     * @dev For this Secp256k1Verification Facet, the public key should in an uncompressed public key format\n     * @param _publicKey Bytes of public key for format check\n     * @return isValid Boolean variable representing if the format of public key is valid\n     */\n    function isValidKeyType(\n        bytes memory _publicKey\n    ) public pure override returns (bool isValid) {\n        isValid = (_publicKey.length == 65 && _publicKey[0] == 0x04);\n    }\n\n    /**\n     * @notice Validates if the signature is valid. Function to be compatible with EIP-1271\n     * @dev This method verifies the signature if the owner indeed signed the hash. Returns magic value if true\n     * @param _hash Hash value the owner signed\n     * @param _signature Signature that signed the above hash\n     * @return magicValue Bytes4 value representing the success/failure of validation\n     */\n    function isValidSignature(\n        bytes32 _hash,\n        bytes memory _signature\n    ) public view override returns (bytes4 magicValue) {\n        magicValue = _validateSignature(\n            LibFacetStorage.r1Storage().q,\n            _hash,\n            _signature\n        )\n            ? this.isValidSignature.selector\n            : bytes4(0xffffffff);\n    }\n\n    function _validateSignature(\n        uint256[2] memory q,\n        bytes32 _hash,\n        bytes memory _signature\n    ) internal view returns (bool) {\n        (\n            uint256 rValue,\n            uint256 sValue,\n            bytes memory authenticatorData,\n            string memory clientDataJSONPre,\n            string memory clientDataJSONPost\n        ) = abi.decode(_signature, (uint256, uint256, bytes, string, string));\n        bytes32 clientHash;\n        {\n            string memory opHashBase64 = Base64.encode(bytes.concat(_hash));\n            string memory clientDataJSON = string.concat(\n                clientDataJSONPre,\n                opHashBase64,\n                clientDataJSONPost\n            );\n            clientHash = sha256(bytes(clientDataJSON));\n        }\n        bytes32 sigHash = sha256(bytes.concat(authenticatorData, clientHash));\n        return LibSecp256r1.Verify(q, rValue, sValue, uint256(sigHash));\n    }\n}\n"
    },
    "contracts/facets/verification/secp256r1/utils/Base64.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\n/**\n * @dev Provides a set of functions to operate with Base64 strings.\n *  modified for base64url https://datatracker.ietf.org/doc/html/rfc4648#section-5\n * _Available since v4.5._\n */\nlibrary Base64 {\n    /**\n     * @dev Base64 Encoding/Decoding Table\n     */\n    string internal constant _TABLE =\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\";\n\n    /**\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\n     */\n    function encode(bytes memory data) internal pure returns (string memory) {\n        /**\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\n         */\n        if (data.length == 0) return \"\";\n\n        // Loads the table into memory\n        string memory table = _TABLE;\n\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\n        // and split into 4 numbers of 6 bits.\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\n        // - `data.length + 2`  -> Round up\n        // - `/ 3`              -> Number of 3-bytes chunks\n        // - `4 *`              -> 4 characters for each chunk\n        uint256 newlength = (data.length * 8) / 6;\n        if (data.length % 6 > 0) {\n            newlength++;\n        }\n        string memory result = new string(newlength);\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Prepare the lookup table (skip the first \"length\" byte)\n            let tablePtr := add(table, 1)\n\n            // Prepare result pointer, jump over length\n            let resultPtr := add(result, 32)\n\n            // Run over the input, 3 bytes at a time\n            for {\n                let dataPtr := data\n                let endPtr := add(data, mload(data))\n            } lt(dataPtr, endPtr) {\n\n            } {\n                // Advance 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // To write each character, shift the 3 bytes (18 bits) chunk\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\n                // and apply logical AND with 0x3F which is the number of\n                // the previous character in the ASCII table prior to the Base64 Table\n                // The result is then added to the table to get the character to write,\n                // and finally write it in the result pointer but with a left shift\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\n\n                mstore8(\n                    resultPtr,\n                    mload(add(tablePtr, and(shr(18, input), 0x3F)))\n                )\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(\n                    resultPtr,\n                    mload(add(tablePtr, and(shr(12, input), 0x3F)))\n                )\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(\n                    resultPtr,\n                    mload(add(tablePtr, and(shr(6, input), 0x3F)))\n                )\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/facets/verification/secp256r1/utils/LibSecp256r1.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.21;\n\n// Heavily inspired from\n// https://github.com/maxrobot/elliptic-solidity/blob/master/contracts/Secp256r1.sol\n// https://github.com/tdrerup/elliptic-curve-solidity/blob/master/contracts/curves/EllipticCurve.sol\n// modified to use precompile 0x05 modexp\n// and modified jacobian double\n// optimisations to avoid to an from from affine and jacobian coordinates\n\n// Additional Elliptic curve Public key / Signature validation added by\n// David Yonjun Kim (@Powerstream3604)\n\nstruct JPoint {\n    uint256 x;\n    uint256 y;\n    uint256 z;\n}\n\nlibrary LibSecp256r1 {\n    uint256 constant gx =\n        0x6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296;\n    uint256 constant gy =\n        0x4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5;\n    uint256 public constant pp =\n        0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF;\n\n    uint256 public constant nn =\n        0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551;\n    uint256 constant a =\n        0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC;\n    uint256 constant b =\n        0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B;\n    uint256 constant MOST_SIGNIFICANT =\n        0xc000000000000000000000000000000000000000000000000000000000000000;\n\n    /*\n     * Verify\n     * @description - verifies that a public key has signed a given message\n     * @param Q - public key coordinates X & Y\n     * @param R - signature half R\n     * @param S - signature half S\n     * @param input - hashed message\n     */\n    function Verify(\n        uint256[2] memory q,\n        uint r,\n        uint s,\n        uint e\n    ) internal view returns (bool) {\n        if (q[0] > pp - 1 || q[1] > pp - 1) {\n            return false;\n        }\n        if (r == 0 || s == 0 || r >= nn || s >= nn) {\n            return false;\n        }\n        if (\n            mulmod(q[1], q[1], pp) !=\n            addmod(\n                addmod(\n                    mulmod(q[0], mulmod(q[0], q[0], pp), pp),\n                    mulmod(a, q[0], pp),\n                    pp\n                ),\n                b,\n                pp\n            )\n        ) {\n            return false;\n        }\n\n        JPoint[16] memory points = _preComputeJacobianPoints(q);\n        return VerifyWithPrecompute(points, r, s, e);\n    }\n\n    function VerifyWithPrecompute(\n        JPoint[16] memory points,\n        uint r,\n        uint s,\n        uint e\n    ) internal view returns (bool) {\n        if (r == 0 || s == 0 || r >= nn || s >= nn) {\n            return false;\n        }\n\n        uint w = _primemod(s, nn);\n\n        uint u1 = mulmod(e, w, nn);\n        uint u2 = mulmod(r, w, nn);\n\n        uint x;\n        uint y;\n\n        (x, y) = ShamirMultJacobian(points, u1, u2);\n        return (x == r);\n    }\n\n    /*\n     * Strauss Shamir trick for EC multiplication\n     * https://stackoverflow.com/questions/50993471/ec-scalar-multiplication-with-strauss-shamir-method\n     * we optimise on this a bit to do with 2 bits at a time rather than a single bit\n     * the individual points for a single pass are precomputed\n     * overall this reduces the number of additions while keeping the same number of doublings\n     */\n    function ShamirMultJacobian(\n        JPoint[16] memory points,\n        uint u1,\n        uint u2\n    ) internal view returns (uint, uint) {\n        uint x = 0;\n        uint y = 0;\n        uint z = 0;\n        uint bits = 128;\n        uint index = 0;\n\n        while (bits > 0) {\n            if (z > 0) {\n                (x, y, z) = _modifiedJacobianDouble(x, y, z);\n                (x, y, z) = _modifiedJacobianDouble(x, y, z);\n            }\n            index =\n                ((u1 & MOST_SIGNIFICANT) >> 252) |\n                ((u2 & MOST_SIGNIFICANT) >> 254);\n            if (index > 0) {\n                (x, y, z) = _jAdd(\n                    x,\n                    y,\n                    z,\n                    points[index].x,\n                    points[index].y,\n                    points[index].z\n                );\n            }\n            u1 <<= 2;\n            u2 <<= 2;\n            bits--;\n        }\n        (x, y) = _affineFromJacobian(x, y, z);\n        return (x, y);\n    }\n\n    function _preComputeJacobianPoints(\n        uint256[2] memory q\n    ) internal pure returns (JPoint[16] memory points) {\n        points[0] = JPoint(0, 0, 0);\n        points[1] = JPoint(q[0], q[1], 1); // u2\n        points[2] = _jPointDouble(points[1]);\n        points[3] = _jPointAdd(points[1], points[2]);\n\n        points[4] = JPoint(gx, gy, 1); // u1Points[1]\n        points[5] = _jPointAdd(points[4], points[1]);\n        points[6] = _jPointAdd(points[4], points[2]);\n        points[7] = _jPointAdd(points[4], points[3]);\n\n        points[8] = _jPointDouble(points[4]); // u1Points[2]\n        points[9] = _jPointAdd(points[8], points[1]);\n        points[10] = _jPointAdd(points[8], points[2]);\n        points[11] = _jPointAdd(points[8], points[3]);\n\n        points[12] = _jPointAdd(points[4], points[8]); // u1Points[3]\n        points[13] = _jPointAdd(points[12], points[1]);\n        points[14] = _jPointAdd(points[12], points[2]);\n        points[15] = _jPointAdd(points[12], points[3]);\n    }\n\n    function _jPointAdd(\n        JPoint memory p1,\n        JPoint memory p2\n    ) internal pure returns (JPoint memory) {\n        uint x;\n        uint y;\n        uint z;\n        (x, y, z) = _jAdd(p1.x, p1.y, p1.z, p2.x, p2.y, p2.z);\n        return JPoint(x, y, z);\n    }\n\n    function _jPointDouble(\n        JPoint memory p\n    ) internal pure returns (JPoint memory) {\n        uint x;\n        uint y;\n        uint z;\n        (x, y, z) = _modifiedJacobianDouble(p.x, p.y, p.z);\n        return JPoint(x, y, z);\n    }\n\n    /* _affineFromJacobian\n     * @desription returns affine coordinates from a jacobian input follows\n     * golang elliptic/crypto library\n     */\n    function _affineFromJacobian(\n        uint x,\n        uint y,\n        uint z\n    ) internal view returns (uint ax, uint ay) {\n        if (z == 0) {\n            return (0, 0);\n        }\n\n        uint zinv = _primemod(z, pp);\n        uint zinvsq = mulmod(zinv, zinv, pp);\n\n        ax = mulmod(x, zinvsq, pp);\n        ay = mulmod(y, mulmod(zinvsq, zinv, pp), pp);\n    }\n\n    /*\n     * _jAdd\n     * @description performs Jacobian addition as defined below:\n     * http://www.hyperelliptic.org/EFD/g1p/data/shortw/jacobian/addition/add-2007-bl\n     */\n    function _jAdd(\n        uint p1,\n        uint p2,\n        uint p3,\n        uint q1,\n        uint q2,\n        uint q3\n    ) internal pure returns (uint r1, uint r2, uint r3) {\n        if (p3 == 0) {\n            r1 = q1;\n            r2 = q2;\n            r3 = q3;\n\n            return (r1, r2, r3);\n        } else if (q3 == 0) {\n            r1 = p1;\n            r2 = p2;\n            r3 = p3;\n\n            return (r1, r2, r3);\n        }\n\n        assembly {\n            let\n                pd\n            := 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\n            let z1z1 := mulmod(p3, p3, pd) // Z1Z1 = Z1^2\n            let z2z2 := mulmod(q3, q3, pd) // Z2Z2 = Z2^2\n\n            let u1 := mulmod(p1, z2z2, pd) // U1 = X1*Z2Z2\n            let u2 := mulmod(q1, z1z1, pd) // U2 = X2*Z1Z1\n\n            let s1 := mulmod(p2, mulmod(z2z2, q3, pd), pd) // S1 = Y1*Z2*Z2Z2\n            let s2 := mulmod(q2, mulmod(z1z1, p3, pd), pd) // S2 = Y2*Z1*Z1Z1\n\n            let p3q3 := addmod(p3, q3, pd)\n\n            if lt(u2, u1) {\n                u2 := add(pd, u2) // u2 = u2+pd\n            }\n            let h := sub(u2, u1) // H = U2-U1\n\n            let i := mulmod(0x02, h, pd)\n            i := mulmod(i, i, pd) // I = (2*H)^2\n\n            let j := mulmod(h, i, pd) // J = H*I\n            if lt(s2, s1) {\n                s2 := add(pd, s2) // u2 = u2+pd\n            }\n            let rr := mulmod(0x02, sub(s2, s1), pd) // r = 2*(S2-S1)\n            r1 := mulmod(rr, rr, pd) // X3 = R^2\n\n            let v := mulmod(u1, i, pd) // V = U1*I\n            let j2v := addmod(j, mulmod(0x02, v, pd), pd)\n            if lt(r1, j2v) {\n                r1 := add(pd, r1) // X3 = X3+pd\n            }\n            r1 := sub(r1, j2v)\n\n            // Y3 = r*(V-X3)-2*S1*J\n            let s12j := mulmod(mulmod(0x02, s1, pd), j, pd)\n\n            if lt(v, r1) {\n                v := add(pd, v)\n            }\n            r2 := mulmod(rr, sub(v, r1), pd)\n\n            if lt(r2, s12j) {\n                r2 := add(pd, r2)\n            }\n            r2 := sub(r2, s12j)\n\n            // Z3 = ((Z1+Z2)^2-Z1Z1-Z2Z2)*H\n            z1z1 := addmod(z1z1, z2z2, pd)\n            j2v := mulmod(p3q3, p3q3, pd)\n            if lt(j2v, z1z1) {\n                j2v := add(pd, j2v)\n            }\n            r3 := mulmod(sub(j2v, z1z1), h, pd)\n        }\n        return (r1, r2, r3);\n    }\n\n    // Point doubling on the modified jacobian coordinates\n    // http://point-at-infinity.org/ecc/Prime_Curve_Modified_Jacobian_Coordinates.html\n    function _modifiedJacobianDouble(\n        uint x,\n        uint y,\n        uint z\n    ) internal pure returns (uint x3, uint y3, uint z3) {\n        if (y == 0) return (0, 0, 0);\n        assembly {\n            let\n                pd\n            := 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\n            let z2 := mulmod(z, z, pd)\n            let az4 := mulmod(\n                0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC,\n                mulmod(z2, z2, pd),\n                pd\n            )\n            let y2 := mulmod(y, y, pd)\n            let s := mulmod(0x04, mulmod(x, y2, pd), pd)\n            let u := mulmod(0x08, mulmod(y2, y2, pd), pd)\n            let m := addmod(mulmod(0x03, mulmod(x, x, pd), pd), az4, pd)\n            let twos := mulmod(0x02, s, pd)\n            let m2 := mulmod(m, m, pd)\n            if lt(m2, twos) {\n                m2 := add(pd, m2)\n            }\n            x3 := sub(m2, twos)\n            if lt(s, x3) {\n                s := add(pd, s)\n            }\n            y3 := mulmod(m, sub(s, x3), pd)\n            if lt(y3, u) {\n                y3 := add(pd, y3)\n            }\n            y3 := sub(y3, u)\n            z3 := mulmod(0x02, mulmod(y, z, pd), pd)\n        }\n    }\n\n    // Fermats little theorem https://en.wikipedia.org/wiki/Fermat%27s_little_theorem\n    // a^(p-1) = 1 mod p\n    // a^(-1)  a^(p-2) (mod p)\n    // we then use the precompile bigModExp to compute a^(-1)\n    function _primemod(uint value, uint p) internal view returns (uint ret) {\n        ret = modexp(value, p - 2, p);\n        return ret;\n    }\n\n    // Wrapper for built-in BigNumber_modexp (contract 0x5) as described here. https://github.com/ethereum/EIPs/pull/198\n    function modexp(\n        uint _base,\n        uint _exp,\n        uint _mod\n    ) internal view returns (uint ret) {\n        // bigModExp(_base, _exp, _mod);\n        assembly {\n            if gt(_base, _mod) {\n                _base := mod(_base, _mod)\n            }\n            // Free memory pointer is always stored at 0x40\n            let freemem := mload(0x40)\n\n            mstore(freemem, 0x20)\n            mstore(add(freemem, 0x20), 0x20)\n            mstore(add(freemem, 0x40), 0x20)\n\n            mstore(add(freemem, 0x60), _base)\n            mstore(add(freemem, 0x80), _exp)\n            mstore(add(freemem, 0xa0), _mod)\n\n            let success := staticcall(14000, 0x5, freemem, 0xc0, freemem, 0x20)\n            switch success\n            case 0 {\n                revert(0x0, 0x0)\n            }\n            default {\n                ret := mload(freemem)\n            }\n        }\n    }\n}\n"
    },
    "contracts/infrastructure/DefaultFallbackHandler.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {IERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport {IERC777Recipient} from \"@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol\";\nimport {BaseAccount} from \"../aa-4337/core/BaseAccount.sol\";\nimport {DefaultLibDiamond} from \"../libraries/DefaultLibDiamond.sol\";\nimport {IDiamondCut} from \"../facets/base/interfaces/IDiamondCut.sol\";\nimport {IAccountFacet} from \"../facets/interfaces/IAccountFacet.sol\";\nimport {IStorageLoupe} from \"../facets/base/interfaces/IStorageLoupe.sol\";\nimport {IDiamondLoupe} from \"../facets/base/interfaces/IDiamondLoupe.sol\";\nimport {IERC677Receiver} from \"../interfaces/ERC/IERC677Receiver.sol\";\nimport {IERC165} from \"../interfaces/ERC/IERC165.sol\";\n\n/**\n * @title DefaultFallbackHandler\n * @dev A default fallback handler for Barz\n * @author David Yongjun Kim (@Powerstream3604)\n */\ncontract DefaultFallbackHandler is IDiamondLoupe {\n    /**\n     * @notice Sets the middleware diamond for Barz wallet as a fallback handler\n     * @dev This contract is also a diamond that holds the default facets to reduce gas cost for wallet activation.\n     *      Within the constructor this conducts diamond cut to initially setup the diamond. This is a non-upgradeable contract\n     * @param _diamondCutFacet Address if diamond cut facet\n     * @param _accountFacet Address account facet\n     * @param _tokenReceiverFacet Address of token receiver facet\n     * @param _diamondLoupeFacet Address of diamond loupe facet\n     */\n    constructor(\n        address _diamondCutFacet,\n        address _accountFacet,\n        address _tokenReceiverFacet,\n        address _diamondLoupeFacet\n    ) payable {\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](4);\n        bytes4[] memory functionSelectors = new bytes4[](1);\n        functionSelectors[0] = IDiamondCut.diamondCut.selector;\n\n        bytes4[] memory accountFunctionSelectors = new bytes4[](5);\n        accountFunctionSelectors[0] = IAccountFacet.execute.selector;\n        accountFunctionSelectors[1] = IAccountFacet.executeBatch.selector;\n        accountFunctionSelectors[2] = BaseAccount.validateUserOp.selector;\n        accountFunctionSelectors[3] = BaseAccount.getNonce.selector;\n        accountFunctionSelectors[4] = BaseAccount.entryPoint.selector;\n\n        bytes4[] memory receiverFacetSelectors = new bytes4[](5);\n        receiverFacetSelectors[0] = IERC721Receiver.onERC721Received.selector;\n        receiverFacetSelectors[1] = IERC1155Receiver.onERC1155Received.selector;\n        receiverFacetSelectors[2] = IERC1155Receiver\n            .onERC1155BatchReceived\n            .selector;\n        receiverFacetSelectors[3] = IERC777Recipient.tokensReceived.selector;\n        receiverFacetSelectors[4] = IERC677Receiver.onTokenTransfer.selector;\n\n        bytes4[] memory loupeFacetSelectors = new bytes4[](9);\n        loupeFacetSelectors[0] = IDiamondLoupe.facets.selector;\n        loupeFacetSelectors[1] = IDiamondLoupe.facetFunctionSelectors.selector;\n        loupeFacetSelectors[2] = IDiamondLoupe.facetAddresses.selector;\n        loupeFacetSelectors[3] = IDiamondLoupe.facetAddress.selector;\n        loupeFacetSelectors[4] = IERC165.supportsInterface.selector;\n        loupeFacetSelectors[5] = IStorageLoupe.facetsFromStorage.selector;\n        loupeFacetSelectors[6] = IStorageLoupe\n            .facetFunctionSelectorsFromStorage\n            .selector;\n        loupeFacetSelectors[7] = IStorageLoupe\n            .facetAddressesFromStorage\n            .selector;\n        loupeFacetSelectors[8] = IStorageLoupe.facetAddressFromStorage.selector;\n\n        {\n            cut[0] = IDiamondCut.FacetCut({\n                facetAddress: _diamondCutFacet,\n                action: IDiamondCut.FacetCutAction.Add,\n                functionSelectors: functionSelectors\n            });\n            cut[1] = IDiamondCut.FacetCut({\n                facetAddress: _accountFacet,\n                action: IDiamondCut.FacetCutAction.Add,\n                functionSelectors: accountFunctionSelectors\n            });\n            cut[2] = IDiamondCut.FacetCut({\n                facetAddress: _tokenReceiverFacet,\n                action: IDiamondCut.FacetCutAction.Add,\n                functionSelectors: receiverFacetSelectors\n            });\n            cut[3] = IDiamondCut.FacetCut({\n                facetAddress: _diamondLoupeFacet,\n                action: IDiamondCut.FacetCutAction.Add,\n                functionSelectors: loupeFacetSelectors\n            });\n\n            DefaultLibDiamond.diamondCut(cut, address(0), \"\");\n        }\n    }\n\n    /**\n     * @notice Returns the facet information of call facets registered to this diamond.\n     * @return facets_ The facet struct array including all facet information\n     */\n    function facets() external view override returns (Facet[] memory facets_) {\n        DefaultLibDiamond.DiamondStorage storage ds = DefaultLibDiamond\n            .diamondStorage();\n        uint256 numFacets = ds.facetAddresses.length;\n        facets_ = new Facet[](numFacets);\n        for (uint256 i; i < numFacets; ) {\n            address facetAddress_ = ds.facetAddresses[i];\n            facets_[i].facetAddress = facetAddress_;\n            facets_[i].functionSelectors = ds\n                .facetFunctionSelectors[facetAddress_]\n                .functionSelectors;\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Gets all the function selectors provided by a facet.\n     * @param _facet The facet address.\n     * @return facetFunctionSelectors_\n     */\n    function facetFunctionSelectors(\n        address _facet\n    ) external view override returns (bytes4[] memory facetFunctionSelectors_) {\n        facetFunctionSelectors_ = DefaultLibDiamond\n            .diamondStorage()\n            .facetFunctionSelectors[_facet]\n            .functionSelectors;\n    }\n\n    /**\n     * @notice Get all the facet addresses used by a diamond.\n     * @return facetAddresses_\n     */\n    function facetAddresses()\n        external\n        view\n        override\n        returns (address[] memory facetAddresses_)\n    {\n        facetAddresses_ = DefaultLibDiamond.diamondStorage().facetAddresses;\n    }\n\n    /** @notice Gets the facet that supports the given selector.\n     * @dev If facet is not found return address(0).\n     * @param _functionSelector The function selector.\n     * @return facetAddress_ The facet address.\n     */\n    function facetAddress(\n        bytes4 _functionSelector\n    ) external view override returns (address facetAddress_) {\n        facetAddress_ = DefaultLibDiamond\n            .diamondStorage()\n            .selectorToFacetAndPosition[_functionSelector]\n            .facetAddress;\n    }\n}\n"
    },
    "contracts/infrastructure/FacetRegistry.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {Ownable2Step} from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport {IFacetRegistry} from \"./interfaces/IFacetRegistry.sol\";\n\n/**\n * @title Facet Registry\n * @dev Contract to keep track of facets & function selectors addable to user wallets\n * @author David Yongjun Kim (@Powerstream3604)\n */\ncontract FacetRegistry is IFacetRegistry, Ownable2Step {\n    mapping(address => FacetRegistryConfig) private facets;\n\n    /**\n     * @notice Transfers the ownership of the contract to the given owner\n     * @param _owner Address of owner who has access to initialize the default security variables for security manager\n     */\n    constructor(address _owner) {\n        transferOwnership(_owner);\n        _transferOwnership(_owner);\n    }\n\n    /**\n     * @dev Registers a facet and it's function selectors to registry\n     * @param _facet address of facet\n     * @param _facetSelectors list of function selectors of the facet\n     */\n    function registerFacetFunctionSelectors(\n        address _facet,\n        bytes4[] calldata _facetSelectors\n    ) external override onlyOwner {\n        FacetRegistryConfig storage facetConfig = facets[_facet];\n        uint256 facetSelectorsLength = _facetSelectors.length;\n        for (uint256 i; i < facetSelectorsLength; ) {\n            if (facetConfig.info[_facetSelectors[i]].exists)\n                revert FacetRegistry__FacetSelectorAlreadyRegistered();\n\n            facetConfig.info[_facetSelectors[i]].exists = true;\n            facetConfig.info[_facetSelectors[i]].index = uint128(\n                facetConfig.selectors.length\n            );\n            facetConfig.selectors.push(_facetSelectors[i]);\n            unchecked {\n                ++i;\n            }\n        }\n        emit FacetFunctionSelectorsRegistered(_facet, _facetSelectors);\n    }\n\n    /**\n     * @dev Removes a registered facet and it's corresponding selectors from registry\n     * @param _facet address of facet\n     * @param _facetSelectors list of function selectors of the facet\n     */\n    function removeFacetFunctionSelectors(\n        address _facet,\n        bytes4[] calldata _facetSelectors\n    ) external override onlyOwner {\n        FacetRegistryConfig storage facetConfig = facets[_facet];\n        uint256 facetSelectorsLength = _facetSelectors.length;\n        for (uint256 i; i < facetSelectorsLength; ) {\n            if (!facetConfig.info[_facetSelectors[i]].exists)\n                revert FacetRegistry__UnregisteredFacetSelector();\n\n            bytes4 lastSelector = facetConfig.selectors[\n                facetConfig.selectors.length - 1\n            ];\n            if (_facetSelectors[i] != lastSelector) {\n                uint128 targetIndex = facetConfig\n                    .info[_facetSelectors[i]]\n                    .index;\n                facetConfig.selectors[targetIndex] = lastSelector;\n                facetConfig.info[lastSelector].index = targetIndex;\n            }\n            facetConfig.selectors.pop();\n            delete facetConfig.info[_facetSelectors[i]];\n\n            unchecked {\n                ++i;\n            }\n        }\n        emit FacetFunctionSelectorsRemoved(_facet, _facetSelectors);\n    }\n\n    /**\n     * @dev Checks if a facet and it's selectors given is registered to facet registry\n     * @param _facet Address of facet\n     * @param _facetSelectors List of function selectors of the facet\n     */\n    function areFacetFunctionSelectorsRegistered(\n        address _facet,\n        bytes4[] calldata _facetSelectors\n    ) external view override returns (bool) {\n        FacetRegistryConfig storage facetConfig = facets[_facet];\n        uint256 facetSelectorsLength = _facetSelectors.length;\n        if (facetSelectorsLength == 0) return false;\n        for (uint256 i; i < facetSelectorsLength; ) {\n            if (!facetConfig.info[_facetSelectors[i]].exists) return false;\n            unchecked {\n                ++i;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Checks if a facet and it's selector given is registered to facet registry\n     * @param _facet Address of facet\n     * @param _facetSelector List of function selectors of the facet\n     * @return isRegistered Bool value showing if the selector is registered\n     */\n    function isFacetFunctionSelectorRegistered(\n        address _facet,\n        bytes4 _facetSelector\n    ) external view override returns (bool isRegistered) {\n        FacetRegistryConfig storage facetConfig = facets[_facet];\n        isRegistered = facetConfig.info[_facetSelector].exists;\n    }\n\n    /**\n     * @dev Get the registered selectors of facet from registry\n     * @param _facet Address of facet\n     * @return selectors Selectors registered to facet\n     */\n    function getFacetFunctionSelectors(\n        address _facet\n    ) external view override returns (bytes4[] memory selectors) {\n        FacetRegistryConfig storage facetConfig = facets[_facet];\n        selectors = facetConfig.selectors;\n    }\n}\n"
    },
    "contracts/infrastructure/interfaces/IFacetRegistry.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\n/**\n * @title Facet Registry Interface\n * @dev Interface for Facet Registry contract to keep track of facets & function selectors addable to user wallets\n * @author David Yongjun Kim (@Powerstream3604)\n */\ninterface IFacetRegistry {\n    struct FacetRegistryConfig {\n        bytes4[] selectors;\n        mapping(bytes4 => FacetInfo) info;\n    }\n    struct FacetInfo {\n        bool exists;\n        uint128 index;\n    }\n\n    event FacetFunctionSelectorsRegistered(\n        address facet,\n        bytes4[] facetSelectors\n    );\n    event FacetFunctionSelectorsRemoved(address facet, bytes4[] facetSelectors);\n\n    error FacetRegistry__FacetSelectorAlreadyRegistered();\n    error FacetRegistry__UnregisteredFacetSelector();\n\n    function registerFacetFunctionSelectors(\n        address facet,\n        bytes4[] calldata facetSelectors\n    ) external;\n\n    function removeFacetFunctionSelectors(\n        address facet,\n        bytes4[] calldata facetSelectors\n    ) external;\n\n    function areFacetFunctionSelectorsRegistered(\n        address facet,\n        bytes4[] calldata facetSelectors\n    ) external view returns (bool);\n\n    function isFacetFunctionSelectorRegistered(\n        address facet,\n        bytes4 facetSelector\n    ) external view returns (bool);\n\n    function getFacetFunctionSelectors(\n        address facet\n    ) external view returns (bytes4[] memory);\n}\n"
    },
    "contracts/infrastructure/interfaces/ISecurityManager.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\n/**\n * @title Facet Registry Interface\n * @dev Infrastructure contract to manage security parameters of users\n * @author David Yongjun Kim (@Powerstream3604)\n * @author Ruslan Serebriakov (@rsrbk)\n */\ninterface ISecurityManager {\n    error SecurityManager__OutOfBoundary();\n    error SecurityManager__CallerNotWallet();\n    error SecurityManager__AlreadyIntialized();\n\n    function initializeAdditionSecurityPeriod(\n        uint128 defaultAdditionSecurityPeriod,\n        uint128 minAdditionSecurityPeriod,\n        uint128 maxAdditionSecurityPeriod\n    ) external;\n\n    function initializeRemovalSecurityPeriod(\n        uint128 defaultRemovalSecurityPeriod,\n        uint128 minRemovalSecurityPeriod,\n        uint128 maxRemovalSecurityPeriod\n    ) external;\n\n    function initializeApprovalValidationPeriod(\n        uint128 defaultApprovalValidationPeriod,\n        uint128 minApprovalValidationPeriod,\n        uint128 maxApprovalValidationPeriod\n    ) external;\n\n    function initializeMigrationPeriod(\n        uint128 defaultMigrationPeriod,\n        uint128 minMigrationPeriod,\n        uint128 maxMigrationPeriod\n    ) external;\n\n    function initializeLockPeriod(\n        uint128 defaultLockPeriod,\n        uint128 minLockPeriod,\n        uint128 maxLockPeriod\n    ) external;\n\n    function initializeRecoveryPeriod(\n        uint128 defaultRecoveryPeriod,\n        uint128 minRecoveryPeriod,\n        uint128 maxRecoveryPeriod\n    ) external;\n\n    function initializeSecurityWindow(\n        uint128 defaultSecurityWindow,\n        uint128 minSecurityWindow,\n        uint128 maxSecurityWindow\n    ) external;\n\n    function setAdditionSecurityPeriod(\n        address wallet,\n        uint128 additionSecurityPeriod\n    ) external;\n\n    function setRemovalSecurityPeriod(\n        address wallet,\n        uint128 removalSecurityPeriod\n    ) external;\n\n    function setSecurityWindow(address wallet, uint128 securityWindow) external;\n\n    function setRecoveryPeriod(address wallet, uint128 recoveryPeriod) external;\n\n    function setLockPeriod(address wallet, uint128 lockPeriod) external;\n\n    function setApprovalValidationPeriod(\n        address wallet,\n        uint128 approvalValidationPeriod\n    ) external;\n\n    function setMigrationPeriod(\n        address wallet,\n        uint128 migrationPeriod\n    ) external;\n\n    function additionSecurityPeriodOf(\n        address wallet\n    ) external view returns (uint128);\n\n    function removalSecurityPeriodOf(\n        address wallet\n    ) external view returns (uint128);\n\n    function securityWindowOf(address wallet) external view returns (uint128);\n\n    function recoveryPeriodOf(address wallet) external view returns (uint128);\n\n    function lockPeriodOf(address wallet) external view returns (uint128);\n\n    function migrationPeriodOf(address wallet) external view returns (uint128);\n\n    function approvalValidationPeriodOf(\n        address wallet\n    ) external view returns (uint128);\n}\n"
    },
    "contracts/infrastructure/RemoteStorage.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {IDiamondLoupe} from \"../facets/base/interfaces/IDiamondLoupe.sol\";\nimport {IGuardianFacet} from \"../facets/interfaces/IGuardianFacet.sol\";\n\n/**\n * @title Remote Storage\n * @dev Remote storage allows you to associate addresses with an array of addresses on a standalone smart contract.\n * This could be useful when you don't want to use the local diamond storage for some purpose.\n * @author Ruslan Serebriakov (@rsrbk)\n * @author David Yongjun Kim (@Powerstream3604)\n */\nabstract contract RemoteStorage {\n    struct StorageConfig {\n        address[] addresses;\n        mapping(address => Info) info;\n    }\n\n    struct Info {\n        bool exists;\n        uint128 index;\n    }\n\n    mapping(address => StorageConfig) internal configs;\n\n    event Added(address _address);\n    event Removed(address _address);\n\n    error RemoteStorage__CallerNotOwner();\n    error RemoteStorage__CallerNotGuardianOrOwner();\n    error RemoteStorage__AlreadyExists();\n    error RemoteStorage__NotFound();\n    error RemoteStorage__CallerNotGuardian();\n\n    bytes4 constant IS_GUARDIAN_SELECTOR =\n        bytes4(keccak256(\"isGuardian(address)\"));\n    bytes4 constant GUARDIAN_COUNT = bytes4(keccak256(\"guardianCount()\"));\n\n    /**\n     * @notice Modifier to only allow the self to call. Reverts otherwise\n     */\n    modifier onlyWallet(address _wallet) {\n        if (msg.sender != _wallet) revert RemoteStorage__CallerNotOwner();\n        _;\n    }\n\n    /**\n     * @notice Enfore the callet to be wallet of guardian of the wallet\n     * @param _wallet Address of wallet\n     */\n    function enforceGuardianOrWallet(address _wallet) internal view {\n        if (msg.sender == _wallet) return;\n        address facetAddress = IDiamondLoupe(_wallet).facetAddress(\n            IS_GUARDIAN_SELECTOR\n        );\n        if (facetAddress != address(0))\n            if (IGuardianFacet(_wallet).isGuardian(msg.sender)) return;\n        revert RemoteStorage__CallerNotGuardianOrOwner();\n    }\n\n    /**\n     * @notice Enforce the caller to be wallet IF guardians doesn't exists and only guardian when guardians exists\n     * @param _wallet Target wallet address to be handled by infrastructure contracts\n     */\n    function enforceWalletOrGuardianIfExists(address _wallet) internal view {\n        address facetAddress;\n        if (msg.sender == _wallet) {\n            facetAddress = IDiamondLoupe(_wallet).facetAddress(GUARDIAN_COUNT);\n            if (facetAddress == address(0)) return;\n            uint256 guardianCount = IGuardianFacet(_wallet).guardianCount();\n            if (guardianCount != 0) revert RemoteStorage__CallerNotGuardian();\n            return;\n        }\n        facetAddress = IDiamondLoupe(_wallet).facetAddress(\n            IS_GUARDIAN_SELECTOR\n        );\n        if (facetAddress != address(0))\n            if (IGuardianFacet(_wallet).isGuardian(msg.sender)) return;\n\n        revert RemoteStorage__CallerNotGuardianOrOwner();\n    }\n\n    /**\n     * @notice Add address to storage and reverts if the address already exists.\n     *         This is an internal function callable from contracts that inherit this abstract contract\n     * @param _wallet Address of wallet to add the address\n     * @param _address Address to be added to wallet\n     */\n    function addAddress(address _wallet, address _address) internal {\n        StorageConfig storage config = configs[_wallet];\n        if (config.info[_address].exists) revert RemoteStorage__AlreadyExists();\n\n        config.info[_address].exists = true;\n        config.info[_address].index = uint128(config.addresses.length);\n        config.addresses.push(_address);\n\n        emit Added(_address);\n    }\n\n    /**\n     * @notice Remove address from storage and reverts if the address already exists.\n     *         This is an internal function callable from contracts that inherit this abstract contract\n     * @param _wallet Address of wallet to remove the address\n     * @param _address Address to be removed from wallet\n     */\n    function removeAddress(address _wallet, address _address) internal {\n        StorageConfig storage config = configs[_wallet];\n        if (!config.info[_address].exists) revert RemoteStorage__NotFound();\n\n        address lastAddress = config.addresses[config.addresses.length - 1];\n        if (_address != lastAddress) {\n            uint128 targetIndex = config.info[_address].index;\n            config.addresses[targetIndex] = lastAddress;\n            config.info[lastAddress].index = targetIndex;\n        }\n        config.addresses.pop();\n        delete config.info[_address];\n\n        emit Removed(_address);\n    }\n\n    /**\n     * @notice Returns the address added to the given wallet\n     * @param _wallet Address of wallet to fetch the addresses added to it\n     * @return addresses List of addresses added to the wallet\n     */\n    function getAddresses(\n        address _wallet\n    ) internal view returns (address[] memory addresses) {\n        StorageConfig storage config = configs[_wallet];\n        addresses = new address[](config.addresses.length);\n        uint addressesLen = config.addresses.length;\n        for (uint256 i; i < addressesLen; ) {\n            addresses[i] = config.addresses[i];\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Returns bool value checking if the address exists in the given wallet address\n     * @param _wallet Wallet address to check\n     * @param _address Address to fetch if the address if added to given wallet\n     * @return exists_ Bool value showing if the address exists in wallet\n     */\n    function exists(\n        address _wallet,\n        address _address\n    ) internal view returns (bool exists_) {\n        exists_ = configs[_wallet].info[_address].exists;\n    }\n\n    /**\n     * @notice Returns the number of addresses added to the wallet\n     * @param _wallet Address of wallet to check\n     * @return count_ Number of addresses added to wallet\n     */\n    function count(address _wallet) internal view returns (uint256 count_) {\n        count_ = configs[_wallet].addresses.length;\n    }\n}\n"
    },
    "contracts/infrastructure/SecurityManager.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {Ownable2Step} from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport {ISecurityManager} from \"./interfaces/ISecurityManager.sol\";\n\n/**\n * @title Security Manager\n * @dev Infrastructure contract to manage security parameters of users\n * @author David Yongjun Kim (@Powerstream3604)\n */\ncontract SecurityManager is ISecurityManager, Ownable2Step {\n    uint128 public minAdditionSecurityPeriod;\n    uint128 public maxAdditionSecurityPeriod;\n    uint128 private defaultAdditionSecurityPeriod;\n\n    uint128 public minRemovalSecurityPeriod;\n    uint128 public maxRemovalSecurityPeriod;\n    uint128 private defaultRemovalSecurityPeriod;\n\n    uint128 public minSecurityWindow;\n    uint128 public maxSecurityWindow;\n    uint128 private defaultSecurityWindow;\n\n    uint128 public minRecoveryPeriod;\n    uint128 public maxRecoveryPeriod;\n    uint128 private defaultRecoveryPeriod;\n\n    uint128 public minLockPeriod;\n    uint128 public maxLockPeriod;\n    uint128 private defaultLockPeriod;\n\n    uint128 public minApprovalValidationPeriod;\n    uint128 public maxApprovalValidationPeriod;\n    uint128 private defaultApprovalValidationPeriod;\n\n    uint128 public minMigrationPeriod;\n    uint128 public maxMigrationPeriod;\n    uint128 private defaultMigrationPeriod;\n\n    bool public _isAdditionSecurityPeriodInitialized;\n    bool public _isRemovalSecurityPeriodInitialized;\n    bool public _isSecurityWindowInitialized;\n    bool public _isRecoveryPeriodInitialized;\n    bool public _isLockPeriodInitialized;\n    bool public _isApprovalValidationPeriodInitialized;\n    bool public _isMigrationPeriodInitialized;\n\n    mapping(address => CustomSecurityConfig) securityConfigs;\n\n    struct CustomSecurityConfig {\n        uint128 additionSecurityPeriod;\n        uint128 removalSecurityPeriod;\n        uint128 securityWindow;\n        uint128 recoveryPeriod;\n        uint128 lockPeriod;\n        uint128 approvalValidationPeriod;\n        uint128 migrationPeriod;\n    }\n\n    /**\n     * @notice Modifier to only allow wallet itself to make a call to wallet\n     */\n    modifier onlyWallet(address _wallet) {\n        if (msg.sender != _wallet) revert SecurityManager__CallerNotWallet();\n        _;\n    }\n\n    /**\n     * @notice Modifier to revert if the variable is already initialized\n     */\n    modifier initializer(bool _isInitialized) {\n        if (_isInitialized) revert SecurityManager__AlreadyIntialized();\n        _;\n    }\n\n    /**\n     * @notice Transfers the ownership of the contract to the given owner\n     * @param _owner Address of owner who has access to initialize the default security variables for security manager\n     */\n    constructor(address _owner) {\n        transferOwnership(_owner);\n        _transferOwnership(_owner);\n    }\n\n    /**\n     * @notice Sets the initial default/min/max addition security period for all Barz contracts that use this as Security Manager\n     *         This function can only be called by the owner of the SecurityManager\n     *         Default value should be bigger than the min and smaller than the max\n     * @param _defaultAdditionSecurityPeriod Default Addition Security Period for all Barz contracts\n     * @param _minAdditionSecurityPeriod Minimum Addition Security Period for all Barz contracts\n     * @param _maxAdditionSecurityPeriod Maximum Addition Security Period for all Barz contracts\n     */\n    function initializeAdditionSecurityPeriod(\n        uint128 _defaultAdditionSecurityPeriod,\n        uint128 _minAdditionSecurityPeriod,\n        uint128 _maxAdditionSecurityPeriod\n    )\n        external\n        override\n        onlyOwner\n        initializer(_isAdditionSecurityPeriodInitialized)\n    {\n        _isAdditionSecurityPeriodInitialized = true;\n\n        _validatePeriodBoundaries(\n            _defaultAdditionSecurityPeriod,\n            _minAdditionSecurityPeriod,\n            _maxAdditionSecurityPeriod\n        );\n        defaultAdditionSecurityPeriod = _defaultAdditionSecurityPeriod;\n        minAdditionSecurityPeriod = _minAdditionSecurityPeriod;\n        maxAdditionSecurityPeriod = _maxAdditionSecurityPeriod;\n    }\n\n    /**\n     * @notice Sets the initial default/min/max removal security period for all Barz contracts that use this as Security Manager\n     *         This function can only be called by the owner of the SecurityManager\n     *         Default value should be bigger than the min and smaller than the max\n     * @param _defaultRemovalSecurityPeriod Default Removal Security Period for all Barz contracts\n     * @param _minRemovalSecurityPeriod Minimum Removal Security Period for all Barz contracts\n     * @param _maxRemovalSecurityPeriod Maximum Removal Security Period for all Barz contracts\n     */\n    function initializeRemovalSecurityPeriod(\n        uint128 _defaultRemovalSecurityPeriod,\n        uint128 _minRemovalSecurityPeriod,\n        uint128 _maxRemovalSecurityPeriod\n    )\n        external\n        override\n        onlyOwner\n        initializer(_isRemovalSecurityPeriodInitialized)\n    {\n        _isRemovalSecurityPeriodInitialized = true;\n\n        _validatePeriodBoundaries(\n            _defaultRemovalSecurityPeriod,\n            _minRemovalSecurityPeriod,\n            _maxRemovalSecurityPeriod\n        );\n        defaultRemovalSecurityPeriod = _defaultRemovalSecurityPeriod;\n        minRemovalSecurityPeriod = _minRemovalSecurityPeriod;\n        maxRemovalSecurityPeriod = _maxRemovalSecurityPeriod;\n    }\n\n    /**\n     * @notice Sets the initial default/min/maxd security window for all Barz contracts that use this as Security Manager\n     *         This function can only be called by the owner of the SecurityManager\n     *         Default value should be bigger than the min and smaller than the max\n     * @param _defaultSecurityWindow Default Security Window for all Barz contracts\n     * @param _minSecurityWindow Minimum Security Window for all Barz contracts\n     * @param _maxSecurityWindow Maximum Security Window for all Barz contracts\n     */\n    function initializeSecurityWindow(\n        uint128 _defaultSecurityWindow,\n        uint128 _minSecurityWindow,\n        uint128 _maxSecurityWindow\n    ) external override onlyOwner initializer(_isSecurityWindowInitialized) {\n        _isSecurityWindowInitialized = true;\n\n        _validatePeriodBoundaries(\n            _defaultSecurityWindow,\n            _minSecurityWindow,\n            _maxSecurityWindow\n        );\n        defaultSecurityWindow = _defaultSecurityWindow;\n        minSecurityWindow = _minSecurityWindow;\n        maxSecurityWindow = _maxSecurityWindow;\n    }\n\n    /**\n     * @notice Sets the initial default/min/max recovery period for all Barz contracts that use this as Security Manager\n     *         This function can only be called by the owner of the SecurityManager\n     *         Default value should be bigger than the min and smaller than the max\n     * @param _defaultRecoveryPeriod Default Recovery Period for all Barz contracts\n     * @param _minRecoveryPeriod Minimum Recovery Period for all Barz contracts\n     * @param _maxRecoveryPeriod Maximum Recovery Period for all Barz contracts\n     */\n    function initializeRecoveryPeriod(\n        uint128 _defaultRecoveryPeriod,\n        uint128 _minRecoveryPeriod,\n        uint128 _maxRecoveryPeriod\n    ) external override onlyOwner initializer(_isRecoveryPeriodInitialized) {\n        _isRecoveryPeriodInitialized = true;\n\n        _validatePeriodBoundaries(\n            _defaultRecoveryPeriod,\n            _minRecoveryPeriod,\n            _maxRecoveryPeriod\n        );\n        defaultRecoveryPeriod = _defaultRecoveryPeriod;\n        minRecoveryPeriod = _minRecoveryPeriod;\n        maxRecoveryPeriod = _maxRecoveryPeriod;\n    }\n\n    /**\n     * @notice Sets the initial default/min/max lock period for all Barz contracts that use this as Security Manager\n     *         This function can only be called by the owner of the SecurityManager\n     *         Default value should be bigger than the min and smaller than the max\n     * @param _defaultLockPeriod Default Lock Period for all Barz contracts\n     * @param _minLockPeriod Minimum Lock Period for all Barz contracts\n     * @param _maxLockPeriod Maximum Lock Period for all Barz contracts\n     */\n    function initializeLockPeriod(\n        uint128 _defaultLockPeriod,\n        uint128 _minLockPeriod,\n        uint128 _maxLockPeriod\n    ) external override onlyOwner initializer(_isLockPeriodInitialized) {\n        _isLockPeriodInitialized = true;\n\n        _validatePeriodBoundaries(\n            _defaultLockPeriod,\n            _minLockPeriod,\n            _maxLockPeriod\n        );\n        defaultLockPeriod = _defaultLockPeriod;\n        minLockPeriod = _minLockPeriod;\n        maxLockPeriod = _maxLockPeriod;\n    }\n\n    /**\n     * @notice Sets the initial default/min/max approval validation period for all Barz contracts that use this as Security Manager\n     *         This function can only be called by the owner of the SecurityManager\n     *         Default value should be bigger than the min and smaller than the max\n     * @param _defaultApprovalValidationPeriod Default Approval Validation Period for all Barz contracts\n     * @param _minApprovalValidationPeriod Minimum Approval Validation Period for all Barz contracts\n     * @param _maxApprovalValidationPeriod Maximum Approval Validation Period for all Barz contracts\n     */\n    function initializeApprovalValidationPeriod(\n        uint128 _defaultApprovalValidationPeriod,\n        uint128 _minApprovalValidationPeriod,\n        uint128 _maxApprovalValidationPeriod\n    )\n        external\n        override\n        onlyOwner\n        initializer(_isApprovalValidationPeriodInitialized)\n    {\n        _isApprovalValidationPeriodInitialized = true;\n\n        _validatePeriodBoundaries(\n            _defaultApprovalValidationPeriod,\n            _minApprovalValidationPeriod,\n            _maxApprovalValidationPeriod\n        );\n        defaultApprovalValidationPeriod = _defaultApprovalValidationPeriod;\n        minApprovalValidationPeriod = _minApprovalValidationPeriod;\n        maxApprovalValidationPeriod = _maxApprovalValidationPeriod;\n    }\n\n    /**\n     * @notice Sets the initial default/min/max migration period for all Barz contracts that use this as Security Manager\n     *         This function can only be called by the owner of the SecurityManager\n     *         Default value should be bigger than the min and smaller than the max\n     * @param _defaultMigrationPeriod Default Migration Period for all Barz contracts\n     * @param _minMigrationPeriod Minimum Migration Period for all Barz contracts\n     * @param _maxMigrationPeriod Maximum Migration Period for all Barz contracts\n     */\n    function initializeMigrationPeriod(\n        uint128 _defaultMigrationPeriod,\n        uint128 _minMigrationPeriod,\n        uint128 _maxMigrationPeriod\n    ) external override onlyOwner initializer(_isMigrationPeriodInitialized) {\n        _isMigrationPeriodInitialized = true;\n\n        _validatePeriodBoundaries(\n            _defaultMigrationPeriod,\n            _minMigrationPeriod,\n            _maxMigrationPeriod\n        );\n        defaultMigrationPeriod = _defaultMigrationPeriod;\n        minMigrationPeriod = _minMigrationPeriod;\n        maxMigrationPeriod = _maxMigrationPeriod;\n    }\n\n    /**\n     * @notice Wallet owner sets the addition security period for the wallet. Only the owner of wallet can call this function.\n     *         The addition security period should be within the boundry of min and max value set by the owner\n     * @param _wallet Address of wallet\n     * @param _additionSecurityPeriod Custom Addition Security Period for the wallet\n     */\n    function setAdditionSecurityPeriod(\n        address _wallet,\n        uint128 _additionSecurityPeriod\n    ) external override onlyWallet(_wallet) {\n        _validatePeriodBoundaries(\n            _additionSecurityPeriod,\n            minAdditionSecurityPeriod,\n            maxAdditionSecurityPeriod\n        );\n        securityConfigs[_wallet]\n            .additionSecurityPeriod = _additionSecurityPeriod;\n    }\n\n    /**\n     * @notice Wallet owner sets the removal security period for the wallet. Only the owner of wallet can call this function.\n     *         The removal security period should be within the boundry of min and max value set by the owner\n     * @param _wallet Address of wallet\n     * @param _removalSecurityPeriod Custom Removal Security Period for the wallet\n     */\n    function setRemovalSecurityPeriod(\n        address _wallet,\n        uint128 _removalSecurityPeriod\n    ) external override onlyWallet(_wallet) {\n        _validatePeriodBoundaries(\n            _removalSecurityPeriod,\n            minRemovalSecurityPeriod,\n            maxRemovalSecurityPeriod\n        );\n        securityConfigs[_wallet].removalSecurityPeriod = _removalSecurityPeriod;\n    }\n\n    /**\n     * @notice Wallet owner sets the security window for the wallet. Only the owner of wallet can call this function.\n     *         The security window should be within the boundry of min and max value set by the owner\n     * @param _wallet Address of wallet\n     * @param _securityWindow Custom Security Window for the wallet\n     */\n    function setSecurityWindow(\n        address _wallet,\n        uint128 _securityWindow\n    ) external override onlyWallet(_wallet) {\n        _validatePeriodBoundaries(\n            _securityWindow,\n            minSecurityWindow,\n            maxSecurityWindow\n        );\n        securityConfigs[_wallet].securityWindow = _securityWindow;\n    }\n\n    /**\n     * @notice Wallet owner sets the recovery period for the wallet. Only the owner of wallet can call this function.\n     *         The recovery period should be within the boundry of min and max value set by the owner\n     * @param _wallet Address of wallet\n     * @param _recoveryPeriod Custom recovery period for the wallet\n     */\n    function setRecoveryPeriod(\n        address _wallet,\n        uint128 _recoveryPeriod\n    ) external override onlyWallet(_wallet) {\n        _validatePeriodBoundaries(\n            _recoveryPeriod,\n            minRecoveryPeriod,\n            maxRecoveryPeriod\n        );\n        securityConfigs[_wallet].recoveryPeriod = _recoveryPeriod;\n    }\n\n    /**\n     * @notice Wallet owner sets the lock period for the wallet. Only the owner of wallet can call this function.\n     *         The lock period should be within the boundry of min and max value set by the owner\n     * @param _wallet Address of wallet\n     * @param _lockPeriod Custom Lock period for the wallet\n     */\n    function setLockPeriod(\n        address _wallet,\n        uint128 _lockPeriod\n    ) external override onlyWallet(_wallet) {\n        _validatePeriodBoundaries(_lockPeriod, minLockPeriod, maxLockPeriod);\n        securityConfigs[_wallet].lockPeriod = _lockPeriod;\n    }\n\n    /**\n     * @notice Wallet owner sets the approval validation period for the wallet. Only the owner of wallet can call this function.\n     *         The approval validation period should be within the boundry of min and max value set by the owner\n     * @param _wallet Address of wallet\n     * @param _approvalValidationPeriod Custom approval validation period for the wallet\n     */\n    function setApprovalValidationPeriod(\n        address _wallet,\n        uint128 _approvalValidationPeriod\n    ) external override onlyWallet(_wallet) {\n        _validatePeriodBoundaries(\n            _approvalValidationPeriod,\n            minApprovalValidationPeriod,\n            maxApprovalValidationPeriod\n        );\n        securityConfigs[_wallet]\n            .approvalValidationPeriod = _approvalValidationPeriod;\n    }\n\n    /**\n     * @notice Wallet owner sets the migration period for the wallet. Only the owner of wallet can call this function.\n     *         The migration period should be within the boundry of min and max value set by the owner\n     * @param _wallet Address of wallet\n     * @param _migrationPeriod Custom migration period for the wallet\n     */\n\n    function setMigrationPeriod(\n        address _wallet,\n        uint128 _migrationPeriod\n    ) external override onlyWallet(_wallet) {\n        _validatePeriodBoundaries(\n            _migrationPeriod,\n            minMigrationPeriod,\n            maxMigrationPeriod\n        );\n        securityConfigs[_wallet].migrationPeriod = _migrationPeriod;\n    }\n\n    /**\n     * @notice Returns the addition security period. Returns default value when custom addition security period is not set\n     * @param _wallet Address of wallet\n     * @return additionSecurityPeriod Addition Security Period of the given Barz account or wallet\n     */\n    function additionSecurityPeriodOf(\n        address _wallet\n    )\n        public\n        view\n        override\n        onlyWallet(_wallet)\n        returns (uint128 additionSecurityPeriod)\n    {\n        additionSecurityPeriod = securityConfigs[_wallet]\n            .additionSecurityPeriod;\n        additionSecurityPeriod = (additionSecurityPeriod == 0)\n            ? defaultAdditionSecurityPeriod\n            : additionSecurityPeriod;\n    }\n\n    /**\n     * @notice Returns the removal security period. Returns default value when custom removal security period is not set\n     * @param _wallet Address of wallet\n     * @return removalSecurityPeriod Removal Security Period of the given Barz account or wallet\n     */\n    function removalSecurityPeriodOf(\n        address _wallet\n    )\n        public\n        view\n        override\n        onlyWallet(_wallet)\n        returns (uint128 removalSecurityPeriod)\n    {\n        removalSecurityPeriod = securityConfigs[_wallet].removalSecurityPeriod;\n        removalSecurityPeriod = (removalSecurityPeriod == 0)\n            ? defaultRemovalSecurityPeriod\n            : removalSecurityPeriod;\n    }\n\n    /**\n     * @notice Returns the security window. Returns default value when custom security window is not set\n     * @param _wallet Address of wallet\n     * @return securityWindow Security window of the given Barz account or wallet\n     */\n    function securityWindowOf(\n        address _wallet\n    )\n        public\n        view\n        override\n        onlyWallet(_wallet)\n        returns (uint128 securityWindow)\n    {\n        securityWindow = securityConfigs[_wallet].securityWindow;\n        securityWindow = (securityWindow == 0)\n            ? defaultSecurityWindow\n            : securityWindow;\n    }\n\n    /**\n     * @notice Returns the recovery period. Returns default value when custom recovery period is not set\n     * @param _wallet Address of wallet\n     * @return recoveryPeriod Recovery Period of the given Barz account or wallet\n     */\n    function recoveryPeriodOf(\n        address _wallet\n    )\n        public\n        view\n        override\n        onlyWallet(_wallet)\n        returns (uint128 recoveryPeriod)\n    {\n        recoveryPeriod = securityConfigs[_wallet].recoveryPeriod;\n        recoveryPeriod = (recoveryPeriod == 0)\n            ? defaultRecoveryPeriod\n            : recoveryPeriod;\n    }\n\n    /**\n     * @notice Returns the lock period. Returns default value when custom lock period is not set\n     * @param _wallet Address of wallet\n     * @return lockPeriod Lock Period of the given Barz account or wallet\n     */\n    function lockPeriodOf(\n        address _wallet\n    ) public view override onlyWallet(_wallet) returns (uint128 lockPeriod) {\n        lockPeriod = securityConfigs[_wallet].lockPeriod;\n        lockPeriod = (lockPeriod == 0) ? defaultLockPeriod : lockPeriod;\n    }\n\n    /**\n     * @notice Returns the approval validation period. Returns default value when custom approval validation period is not set\n     * @param _wallet Address of wallet\n     * @return approvalValidationPeriod Approval Validation Period of the given Barz account or wallet\n     */\n    function approvalValidationPeriodOf(\n        address _wallet\n    )\n        public\n        view\n        override\n        onlyWallet(_wallet)\n        returns (uint128 approvalValidationPeriod)\n    {\n        approvalValidationPeriod = securityConfigs[_wallet]\n            .approvalValidationPeriod;\n        approvalValidationPeriod = (approvalValidationPeriod == 0)\n            ? defaultApprovalValidationPeriod\n            : approvalValidationPeriod;\n    }\n\n    /**\n     * @notice Returns the migration period. Returns default value when custom migration period is not set\n     * @param _wallet Address of wallet\n     * @return migrationPeriod Migration Period of the given Barz account or wallet\n     */\n    function migrationPeriodOf(\n        address _wallet\n    )\n        public\n        view\n        override\n        onlyWallet(_wallet)\n        returns (uint128 migrationPeriod)\n    {\n        migrationPeriod = securityConfigs[_wallet].migrationPeriod;\n        migrationPeriod = (migrationPeriod == 0)\n            ? defaultMigrationPeriod\n            : migrationPeriod;\n    }\n\n    /**\n     * @notice Validates if the period is smaller than the max period or bigger than the min period\n     * @param _period Period to be checked\n     * @param _minPeriod Minimum period\n     * @param _maxPeriod Maximum period\n     */\n    function _validatePeriodBoundaries(\n        uint128 _period,\n        uint128 _minPeriod,\n        uint128 _maxPeriod\n    ) internal pure {\n        if (_period >= _maxPeriod || _period <= _minPeriod)\n            revert SecurityManager__OutOfBoundary();\n    }\n}\n"
    },
    "contracts/infrastructure/WhitelistStorage.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {RemoteStorage} from \"./RemoteStorage.sol\";\n\n/**\n * @title Whitelist storage\n * @dev Maps addresses to the corresponsing array of whitelisted addresses for each of them.\n * @author Ruslan Serebriakov (@rsrbk)\n */\ncontract WhitelistStorage is RemoteStorage {\n    /**\n     * @dev Add the address to the whitelist storage\n     * @param _wallet User wallet\n     * @param _address Address to be whitelisted\n     */\n    function whitelistAddress(address _wallet, address _address) external {\n        enforceWalletOrGuardianIfExists(_wallet);\n        addAddress(_wallet, _address);\n    }\n\n    /**\n     * @dev Removes the address from the whitelist storage\n     * @param _wallet User wallet\n     * @param _address Address to be removed from the whitelist\n     */\n    function blacklistAddress(address _wallet, address _address) external {\n        enforceGuardianOrWallet(_wallet);\n        removeAddress(_wallet, _address);\n    }\n\n    /**\n     * @dev Returns whether the address exists in the whitelist storage, associated with the wallet\n     * @param _wallet User wallet\n     * @param _address Address to be whitelisted\n     */\n    function isWhitelisted(\n        address _wallet,\n        address _address\n    ) external view returns (bool) {\n        return exists(_wallet, _address);\n    }\n\n    /**\n     * @dev Returns all whitelisted addresses associated with the wallet\n     * @param _wallet User wallet\n     */\n    function getWhitelistedAddresses(\n        address _wallet\n    ) external view returns (address[] memory) {\n        return getAddresses(_wallet);\n    }\n}\n"
    },
    "contracts/interfaces/ERC/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity 0.8.21;\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "contracts/interfaces/ERC/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\ninterface IERC1271 {\n    function isValidSignature(\n        bytes32 hash,\n        bytes memory signature\n    ) external view returns (bytes4);\n}\n"
    },
    "contracts/interfaces/ERC/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceId The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/ERC/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\n/// @title ERC-173 Contract Ownership Standard\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\n/* is ERC165 */\ninterface IERC173 {\n    /// @dev This emits when ownership of a contract changes.\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /// @notice Get the address of the owner\n    /// @return owner_ The address of the owner.\n    function owner() external view returns (address owner_);\n\n    /// @notice Set the address of the new owner of the contract\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\n    /// @param _newOwner The address of the new owner of the contract\n    function transferOwnership(address _newOwner) external;\n}\n"
    },
    "contracts/interfaces/ERC/IERC677Receiver.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\ninterface IERC677Receiver {\n    function onTokenTransfer(\n        address sender,\n        uint value,\n        bytes calldata data\n    ) external pure returns (bool);\n}\n"
    },
    "contracts/interfaces/ERC/Tokens/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 value\n    );\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(\n        address indexed account,\n        address indexed operator,\n        bool approved\n    );\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(\n        address account,\n        uint256 id\n    ) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(\n        address account,\n        address operator\n    ) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/interfaces/ERC/Tokens/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(\n        address owner,\n        address spender\n    ) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(\n        address spender,\n        uint256 addedValue\n    ) external returns (bool);\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(\n        address spender,\n        uint256 subtractedValue\n    ) external returns (bool);\n}\n"
    },
    "contracts/interfaces/ERC/Tokens/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed approved,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(\n        uint256 tokenId\n    ) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IBarz.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\n/**\n * @title Barz Interface\n * @dev Interface of Barz\n * @author David Yongjun Kim (@Powerstream3604)\n */\ninterface IBarz {\n    error Barz__InitializationFailure();\n}\n"
    },
    "contracts/interfaces/IBarzFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {Barz} from \"../Barz.sol\";\n\n/**\n * @title Barz Factory Interface\n * @dev Interface of contract to easily deploy Barz to a pre-computed address with a single call\n * @author David Yongjun Kim (@Powerstream3604)\n */\ninterface IBarzFactory {\n    function createAccount(\n        address verificationFacet,\n        bytes calldata owner,\n        uint256 salt\n    ) external returns (Barz);\n\n    function getAddress(\n        address verificationFacet,\n        bytes calldata owner,\n        uint256 salt\n    ) external view returns (address);\n\n    function getBytecode(\n        address accountFacet,\n        address verificationFacet,\n        address entryPoint,\n        address facetRegistry,\n        address defaultFallback,\n        bytes memory ownerPublicKey\n    ) external pure returns (bytes memory);\n\n    function getCreationCode() external pure returns (bytes memory);\n}\n"
    },
    "contracts/libraries/DefaultLibDiamond.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {IDiamondCut} from \"../facets/base/interfaces/IDiamondCut.sol\";\n\nerror InitializationFunctionReverted(\n    address _initializationContractAddress,\n    bytes _calldata\n);\n\nlibrary DefaultLibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION =\n        keccak256(\"trustwallet.barz.diamond.storage\");\n\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n    }\n\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\n    }\n\n    struct DiamondStorage {\n        // maps function selector to the facet address and\n        // the position of the selector in the facetFunctionSelectors.selectors array\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n        // maps facet addresses to function selectors\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n        // facet addresses\n        address[] facetAddresses;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n    }\n\n    function diamondStorage()\n        internal\n        pure\n        returns (DiamondStorage storage ds)\n    {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event DiamondCut(\n        IDiamondCut.FacetCut[] _diamondCut,\n        address _init,\n        bytes _calldata\n    );\n\n    // Internal function version of diamondCut\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        for (\n            uint256 facetIndex;\n            facetIndex < _diamondCut.length;\n            facetIndex++\n        ) {\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(\n                    _diamondCut[facetIndex].facetAddress,\n                    _diamondCut[facetIndex].functionSelectors\n                );\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(\n                    _diamondCut[facetIndex].facetAddress,\n                    _diamondCut[facetIndex].functionSelectors\n                );\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(\n                    _diamondCut[facetIndex].facetAddress,\n                    _diamondCut[facetIndex].functionSelectors\n                );\n            } else {\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        uint256 funcSelectorsLength = _functionSelectors.length;\n        require(\n            funcSelectorsLength > 0,\n            \"LibDiamondCut: No selectors in facet to cut\"\n        );\n        DiamondStorage storage ds = diamondStorage();\n        require(\n            _facetAddress != address(0),\n            \"LibDiamondCut: Add facet can't be address(0)\"\n        );\n        uint96 selectorPosition = uint96(\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.length\n        );\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (\n            uint256 selectorIndex;\n            selectorIndex < funcSelectorsLength;\n            selectorIndex++\n        ) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds\n                .selectorToFacetAndPosition[selector]\n                .facetAddress;\n            require(\n                oldFacetAddress == address(0),\n                \"LibDiamondCut: Can't add function that already exists\"\n            );\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function replaceFunctions(\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        uint256 funcSelectorsLength = _functionSelectors.length;\n        require(\n            funcSelectorsLength > 0,\n            \"LibDiamondCut: No selectors in facet to cut\"\n        );\n        DiamondStorage storage ds = diamondStorage();\n        require(\n            _facetAddress != address(0),\n            \"LibDiamondCut: Replace facet can't be address(0)\"\n        );\n        uint96 selectorPosition = uint96(\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.length\n        );\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (\n            uint256 selectorIndex;\n            selectorIndex < funcSelectorsLength;\n            selectorIndex++\n        ) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds\n                .selectorToFacetAndPosition[selector]\n                .facetAddress;\n            require(\n                oldFacetAddress != _facetAddress,\n                \"LibDiamondCut: Can't replace function with same facet\"\n            );\n            removeFunction(ds, oldFacetAddress, selector);\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function removeFunctions(\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        uint256 funcSelectorsLength = _functionSelectors.length;\n        require(\n            funcSelectorsLength > 0,\n            \"LibDiamondCut: No selectors in facet to cut\"\n        );\n        DiamondStorage storage ds = diamondStorage();\n        // if function does not exist then do nothing and return\n        require(\n            _facetAddress == address(0),\n            \"LibDiamondCut: Remove facet address must be address(0)\"\n        );\n        for (\n            uint256 selectorIndex;\n            selectorIndex < funcSelectorsLength;\n            selectorIndex++\n        ) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds\n                .selectorToFacetAndPosition[selector]\n                .facetAddress;\n            removeFunction(ds, oldFacetAddress, selector);\n        }\n    }\n\n    function addFacet(\n        DiamondStorage storage ds,\n        address _facetAddress\n    ) internal {\n        enforceHasContractCode(\n            _facetAddress,\n            \"LibDiamondCut: New facet has no code\"\n        );\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds\n            .facetAddresses\n            .length;\n        ds.facetAddresses.push(_facetAddress);\n    }\n\n    function addFunction(\n        DiamondStorage storage ds,\n        bytes4 _selector,\n        uint96 _selectorPosition,\n        address _facetAddress\n    ) internal {\n        ds\n            .selectorToFacetAndPosition[_selector]\n            .functionSelectorPosition = _selectorPosition;\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(\n            _selector\n        );\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    function removeFunction(\n        DiamondStorage storage ds,\n        address _facetAddress,\n        bytes4 _selector\n    ) internal {\n        require(\n            _facetAddress != address(0),\n            \"LibDiamondCut: Can't remove function that doesn't exist\"\n        );\n        // an immutable function is a function defined directly in a diamond\n        require(\n            _facetAddress != address(this),\n            \"LibDiamondCut: Can't remove immutable function\"\n        );\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = ds\n            .selectorToFacetAndPosition[_selector]\n            .functionSelectorPosition;\n        uint256 lastSelectorPosition = ds\n            .facetFunctionSelectors[_facetAddress]\n            .functionSelectors\n            .length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = ds\n                .facetFunctionSelectors[_facetAddress]\n                .functionSelectors[lastSelectorPosition];\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[\n                selectorPosition\n            ] = lastSelector;\n            ds\n                .selectorToFacetAndPosition[lastSelector]\n                .functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete ds.selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n            uint256 facetAddressPosition = ds\n                .facetFunctionSelectors[_facetAddress]\n                .facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = ds.facetAddresses[\n                    lastFacetAddressPosition\n                ];\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n                ds\n                    .facetFunctionSelectors[lastFacetAddress]\n                    .facetAddressPosition = facetAddressPosition;\n            }\n            ds.facetAddresses.pop();\n            delete ds\n                .facetFunctionSelectors[_facetAddress]\n                .facetAddressPosition;\n        }\n    }\n\n    function initializeDiamondCut(\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        if (_init == address(0)) {\n            return;\n        }\n        enforceHasContractCode(\n            _init,\n            \"LibDiamondCut: _init address has no code\"\n        );\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\n        if (!success) {\n            if (error.length > 0) {\n                // bubble up error\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(error)\n                    revert(add(32, error), returndata_size)\n                }\n            } else {\n                revert InitializationFunctionReverted(_init, _calldata);\n            }\n        }\n    }\n\n    function enforceHasContractCode(\n        address _contract,\n        string memory _errorMessage\n    ) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    },
    "contracts/libraries/LibAppStorage.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {IEntryPoint} from \"../aa-4337/interfaces/IEntryPoint.sol\";\nimport {IFacetRegistry} from \"../infrastructure/interfaces/IFacetRegistry.sol\";\n\n/*\n * @title App Storage\n * @dev App storage for Barz contract to prevent storage collision\n * @author David Yongjun Kim (@Powerstream3604)\n * @author Ruslan Serebriakov (@rsrbk)\n */\n\nstruct Lock {\n    uint64 release;\n    bytes4 locker;\n}\n\nstruct InitializersStorage {\n    // NOTE: initialized is a variable to make sure the initialization is only done once.\n    uint8 signerInitialized;\n    uint8 accountInitialized;\n    uint8 restrictionsInitialized;\n}\n\nstruct AppStorage {\n    mapping(uint256 => InitializersStorage) initStorage;\n    uint8 signerMigration;\n    bytes4 validateOwnerSignatureSelector;\n    IEntryPoint entryPoint;\n    IFacetRegistry facetRegistry;\n    mapping(uint256 => Lock) locks;\n}\n\nlibrary LibAppStorage {\n    error LibAppStorage__AccountAlreadyUninitialized();\n    error LibAppStorage__AccountMustBeUninitialized();\n    error LibAppStorage__SignerAlreadyUninitialized();\n    error LibAppStorage__SignerMustBeUninitialized();\n\n    function appStorage() internal pure returns (AppStorage storage ds) {\n        assembly {\n            ds.slot := 0\n        }\n    }\n\n    function setSignerUninitialized() internal {\n        AppStorage storage s = appStorage();\n        if (1 != s.initStorage[0].signerInitialized) {\n            revert LibAppStorage__SignerAlreadyUninitialized();\n        }\n        s.initStorage[0].signerInitialized = 0;\n    }\n\n    function getValidateOwnerSignatureSelector()\n        internal\n        view\n        returns (bytes4 selector)\n    {\n        selector = appStorage().validateOwnerSignatureSelector;\n    }\n\n    function setValidateOwnerSignatureSelector(\n        bytes4 _validateOwnerSignatureSelector\n    ) internal {\n        appStorage()\n            .validateOwnerSignatureSelector = _validateOwnerSignatureSelector;\n    }\n\n    function enforceSignerInitialize() internal {\n        AppStorage storage s = appStorage();\n        if (0 != s.initStorage[0].signerInitialized) {\n            revert LibAppStorage__SignerMustBeUninitialized();\n        }\n        s.initStorage[0].signerInitialized = 1;\n    }\n\n    function enforceAccountInitialize() internal {\n        AppStorage storage s = appStorage();\n        if (0 != s.initStorage[0].accountInitialized) {\n            revert LibAppStorage__AccountMustBeUninitialized();\n        }\n        s.initStorage[0].accountInitialized = 1;\n    }\n\n    function initiateSignerMigration() internal {\n        appStorage().signerMigration = 1;\n    }\n\n    function enforceSignerMigration() internal view {\n        if (1 != appStorage().signerMigration) {\n            revert LibAppStorage__AccountMustBeUninitialized();\n        }\n    }\n\n    function finalizeSignerMigration() internal {\n        appStorage().signerMigration = 0;\n    }\n\n    function setLock(uint256 _releaseAfter, bytes4 _locker) internal {\n        appStorage().locks[0] = Lock(SafeCast.toUint64(_releaseAfter), _locker);\n    }\n\n    function enforceRestrictionsInitialize() internal {\n        AppStorage storage s = appStorage();\n        if (0 != s.initStorage[0].restrictionsInitialized)\n            revert LibAppStorage__SignerMustBeUninitialized();\n        s.initStorage[0].restrictionsInitialized = 1;\n    }\n\n    function setRestrictionsUninitialized() internal {\n        AppStorage storage s = appStorage();\n        if (1 != s.initStorage[0].restrictionsInitialized)\n            revert LibAppStorage__AccountAlreadyUninitialized();\n        s.initStorage[0].restrictionsInitialized = 0;\n    }\n}\n\ncontract BarzStorage {\n    AppStorage internal s;\n    modifier onlyWhenUnlocked() {\n        require(\n            uint64(block.timestamp) >= s.locks[0].release,\n            \"Account Locked\"\n        );\n        _;\n    }\n    modifier onlyWhenLocked() {\n        require(\n            uint64(block.timestamp) < s.locks[0].release,\n            \"Account Unlocked\"\n        );\n        _;\n    }\n}\n"
    },
    "contracts/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {IDiamondCut} from \"../facets/base/interfaces/IDiamondCut.sol\";\nimport {IDiamondLoupe} from \"../facets/base/interfaces/IDiamondLoupe.sol\";\n\nerror InitializationFunctionReverted(\n    address _initializationContractAddress,\n    bytes _calldata\n);\n\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION =\n        keccak256(\"trustwallet.barz.diamond.storage\");\n\n    struct DiamondStorage {\n        // maps function selectors to the facets that execute the functions.\n        // and maps the selectors to their position in the selectorSlots array.\n        // func selector => address facet, selector position\n        mapping(bytes4 => bytes32) facets;\n        // array of slots of function selectors.\n        // each slot holds 8 function selectors.\n        mapping(uint256 => bytes32) selectorSlots;\n        // The number of function selectors in selectorSlots\n        uint16 selectorCount;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // Default Fallback Handler of the barz.\n        IDiamondLoupe defaultFallbackHandler;\n    }\n\n    function diamondStorage()\n        internal\n        pure\n        returns (DiamondStorage storage ds)\n    {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    function enforceIsSelf() internal view {\n        require(msg.sender == address(this), \"LibDiamond: Caller not self\");\n    }\n\n    event DiamondCut(\n        IDiamondCut.FacetCut[] _diamondCut,\n        address _init,\n        bytes _calldata\n    );\n\n    bytes32 constant CLEAR_ADDRESS_MASK =\n        bytes32(uint256(0xffffffffffffffffffffffff));\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\n\n    // Internal function version of diamondCut\n    // This code is almost the same as the external diamondCut,\n    // except it is using 'Facet[] memory _diamondCut' instead of\n    // 'Facet[] calldata _diamondCut'.\n    // The code is duplicated to prevent copying calldata to memory which\n    // causes an error for a two dimensional array.\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        DiamondStorage storage ds = diamondStorage();\n        uint256 originalSelectorCount = ds.selectorCount;\n        uint256 selectorCount = originalSelectorCount;\n        bytes32 selectorSlot;\n        // Check if last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\"\n        if (selectorCount & 7 > 0) {\n            // get last selectorSlot\n            // \"selectorSlot >> 3\" is a gas efficient division by 8 \"selectorSlot / 8\"\n            selectorSlot = ds.selectorSlots[selectorCount >> 3];\n        }\n        // loop through diamond cut\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; ) {\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\n                selectorCount,\n                selectorSlot,\n                _diamondCut[facetIndex].facetAddress,\n                _diamondCut[facetIndex].action,\n                _diamondCut[facetIndex].functionSelectors\n            );\n\n            unchecked {\n                facetIndex++;\n            }\n        }\n        if (selectorCount != originalSelectorCount) {\n            ds.selectorCount = uint16(selectorCount);\n        }\n        // If last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\"\n        if (selectorCount & 7 > 0) {\n            // \"selectorSlot >> 3\" is a gas efficient division by 8 \"selectorSlot / 8\"\n            ds.selectorSlots[selectorCount >> 3] = selectorSlot;\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addReplaceRemoveFacetSelectors(\n        uint256 _selectorCount,\n        bytes32 _selectorSlot,\n        address _newFacetAddress,\n        IDiamondCut.FacetCutAction _action,\n        bytes4[] memory _selectors\n    ) internal returns (uint256, bytes32) {\n        DiamondStorage storage ds = diamondStorage();\n        require(\n            _selectors.length > 0,\n            \"LibDiamondCut: No selectors in facet to cut\"\n        );\n        if (_action == IDiamondCut.FacetCutAction.Add) {\n            enforceHasContractCode(\n                _newFacetAddress,\n                \"LibDiamondCut: Add facet has no code\"\n            );\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\n                bytes4 selector = _selectors[selectorIndex];\n                bytes32 oldFacet = ds.facets[selector];\n                require(\n                    address(bytes20(oldFacet)) == address(0),\n                    \"LibDiamondCut: Can't add function that already exists\"\n                );\n                // add facet for selector\n                ds.facets[selector] =\n                    bytes20(_newFacetAddress) |\n                    bytes32(_selectorCount);\n                // \"_selectorCount & 7\" is a gas efficient modulo by eight \"_selectorCount % 8\"\n                // \" << 5 is the same as multiplying by 32 ( * 32)\n                uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\n                // clear selector position in slot and add selector\n                _selectorSlot =\n                    (_selectorSlot &\n                        ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) |\n                    (bytes32(selector) >> selectorInSlotPosition);\n                // if slot is full then write it to storage\n                if (selectorInSlotPosition == 224) {\n                    // \"_selectorSlot >> 3\" is a gas efficient division by 8 \"_selectorSlot / 8\"\n                    ds.selectorSlots[_selectorCount >> 3] = _selectorSlot;\n                    _selectorSlot = 0;\n                }\n                _selectorCount++;\n\n                unchecked {\n                    selectorIndex++;\n                }\n            }\n        } else if (_action == IDiamondCut.FacetCutAction.Replace) {\n            enforceHasContractCode(\n                _newFacetAddress,\n                \"LibDiamondCut: Replace facet has no code\"\n            );\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\n                bytes4 selector = _selectors[selectorIndex];\n                bytes32 oldFacet = ds.facets[selector];\n                address oldFacetAddress = address(bytes20(oldFacet));\n                // only useful if immutable functions exist\n                require(\n                    oldFacetAddress != address(this),\n                    \"LibDiamondCut: Can't replace immutable function\"\n                );\n                require(\n                    oldFacetAddress != _newFacetAddress,\n                    \"LibDiamondCut: Can't replace function with same function\"\n                );\n                require(\n                    oldFacetAddress != address(0),\n                    \"LibDiamondCut: Can't replace function that doesn't exist\"\n                );\n                // replace old facet address\n                ds.facets[selector] =\n                    (oldFacet & CLEAR_ADDRESS_MASK) |\n                    bytes20(_newFacetAddress);\n\n                unchecked {\n                    selectorIndex++;\n                }\n            }\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\n            require(\n                _newFacetAddress == address(0),\n                \"LibDiamondCut: Remove facet address must be address(0)\"\n            );\n            // \"_selectorCount >> 3\" is a gas efficient division by 8 \"_selectorCount / 8\"\n            uint256 selectorSlotCount = _selectorCount >> 3;\n            // \"_selectorCount & 7\" is a gas efficient modulo by eight \"_selectorCount % 8\"\n            uint256 selectorInSlotIndex = _selectorCount & 7;\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\n                if (_selectorSlot == 0) {\n                    // get last selectorSlot\n                    selectorSlotCount--;\n                    _selectorSlot = ds.selectorSlots[selectorSlotCount];\n                    selectorInSlotIndex = 7;\n                } else {\n                    selectorInSlotIndex--;\n                }\n                bytes4 lastSelector;\n                uint256 oldSelectorsSlotCount;\n                uint256 oldSelectorInSlotPosition;\n                // adding a block here prevents stack too deep error\n                {\n                    bytes4 selector = _selectors[selectorIndex];\n                    bytes32 oldFacet = ds.facets[selector];\n                    require(\n                        address(bytes20(oldFacet)) != address(0),\n                        \"LibDiamondCut: Can't remove function that doesn't exist\"\n                    );\n                    // only useful if immutable functions exist\n                    require(\n                        address(bytes20(oldFacet)) != address(this),\n                        \"LibDiamondCut: Can't remove immutable function\"\n                    );\n                    // replace selector with last selector in ds.facets\n                    // gets the last selector\n                    // \" << 5 is the same as multiplying by 32 ( * 32)\n                    lastSelector = bytes4(\n                        _selectorSlot << (selectorInSlotIndex << 5)\n                    );\n                    if (lastSelector != selector) {\n                        // update last selector slot position info\n                        ds.facets[lastSelector] =\n                            (oldFacet & CLEAR_ADDRESS_MASK) |\n                            bytes20(ds.facets[lastSelector]);\n                    }\n                    delete ds.facets[selector];\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\n                    // \"oldSelectorCount >> 3\" is a gas efficient division by 8 \"oldSelectorCount / 8\"\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\n                    // \"oldSelectorCount & 7\" is a gas efficient modulo by eight \"oldSelectorCount % 8\"\n                    // \" << 5 is the same as multiplying by 32 ( * 32)\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\n                }\n                if (oldSelectorsSlotCount != selectorSlotCount) {\n                    bytes32 oldSelectorSlot = ds.selectorSlots[\n                        oldSelectorsSlotCount\n                    ];\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    oldSelectorSlot =\n                        (oldSelectorSlot &\n                            ~(CLEAR_SELECTOR_MASK >>\n                                oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                    // update storage with the modified slot\n                    ds.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\n                } else {\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    _selectorSlot =\n                        (_selectorSlot &\n                            ~(CLEAR_SELECTOR_MASK >>\n                                oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                }\n                if (selectorInSlotIndex == 0) {\n                    delete ds.selectorSlots[selectorSlotCount];\n                    _selectorSlot = 0;\n                }\n\n                unchecked {\n                    selectorIndex++;\n                }\n            }\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\n        } else {\n            revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n        }\n        return (_selectorCount, _selectorSlot);\n    }\n\n    function initializeDiamondCut(\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        if (_init == address(0)) {\n            return;\n        }\n        enforceHasContractCode(\n            _init,\n            \"LibDiamondCut: _init address has no code\"\n        );\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\n        if (!success) {\n            if (error.length > 0) {\n                // bubble up error\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(error)\n                    revert(add(32, error), returndata_size)\n                }\n            } else {\n                revert InitializationFunctionReverted(_init, _calldata);\n            }\n        }\n    }\n\n    function enforceHasContractCode(\n        address _contract,\n        string memory _errorMessage\n    ) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n\n    function restrictionsFacet() internal view returns (address facetAddress_) {\n        bytes4 selector = bytes4(\n            keccak256(\"verifyRestrictions(address,address,uint256,bytes)\")\n        );\n        facetAddress_ = address(\n            bytes20(LibDiamond.diamondStorage().facets[selector])\n        );\n    }\n}\n"
    },
    "contracts/libraries/LibFacetStorage.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\n/**\n * @title Facet Storage\n * @dev Storage contract to store each facets variables with diamond storage\n * @author David Yongjun Kim (@Powerstream3604)\n * @author Ruslan Serebriakov (@rsrbk)\n */\n\nstruct Secp256k1VerificationStorage {\n    address signer;\n}\n\nstruct Secp256r1VerificationStorage {\n    uint256[2] q;\n}\n\nstruct GuardianStorage {\n    mapping(bytes32 => uint256) pending;\n    mapping(uint8 => StorageConfig) configs;\n}\n\nstruct Info {\n    bool exists;\n    uint128 index;\n}\n\nstruct StorageConfig {\n    address[] addresses;\n    mapping(address => Info) info;\n}\n\nstruct RecoveryConfig {\n    bytes recoveryPublicKey;\n    uint64 executeAfter;\n}\n\nstruct ApprovalConfig {\n    bool isApproved;\n    uint64 validUntil;\n}\n\nstruct RecoveryApprovalConfig {\n    mapping(bytes32 => mapping(address => ApprovalConfig)) isNewOwnerApproved;\n}\n\nstruct RecoveryStorage {\n    mapping(uint8 => RecoveryConfig) recoveryConfigs;\n    mapping(uint8 => RecoveryApprovalConfig) recoveryApprovalConfigs;\n    uint128 nonce;\n}\n\nstruct RestrictionsStorage {\n    address[] restrictions;\n    mapping(address => bool) exists;\n}\n\nstruct SignatureMigrationConfig {\n    bytes migrationPublicKey;\n    address migrationVerificationFacet;\n    bytes4[] migrationSelectors;\n    uint64 migrateAfter;\n}\n\nstruct SignatureMigrationApprovalConfig {\n    mapping(bytes32 => mapping(address => ApprovalConfig)) isMigrationApproved;\n}\n\nstruct SignatureMigrationStorage {\n    mapping(uint8 => SignatureMigrationConfig) migrationConfigs;\n    mapping(uint8 => SignatureMigrationApprovalConfig) migrationApprovalConfigs;\n    uint128 nonce;\n}\n\nstruct DiamondCutApprovalConfig {\n    mapping(bytes32 => mapping(address => ApprovalConfig)) isDiamondCutApproved;\n}\n\nstruct DiamondCutStorage {\n    mapping(uint8 => DiamondCutApprovalConfig) diamondCutApprovalConfigs;\n    uint128 nonce;\n}\n\nstruct LockStorage {\n    uint128 nonce;\n}\n\nlibrary LibFacetStorage {\n    function k1Storage()\n        internal\n        pure\n        returns (Secp256k1VerificationStorage storage ds)\n    {\n        bytes32 storagePosition = keccak256(\n            \"v0.trustwallet.diamond.storage.Secp256k1VerificationStorage\"\n        );\n        assembly {\n            ds.slot := storagePosition\n        }\n    }\n\n    function r1Storage()\n        internal\n        pure\n        returns (Secp256r1VerificationStorage storage ds)\n    {\n        bytes32 storagePosition = keccak256(\n            \"v0.trustwallet.diamond.storage.Secp256r1VerificationStorage\"\n        );\n        assembly {\n            ds.slot := storagePosition\n        }\n    }\n\n    function guardianStorage()\n        internal\n        pure\n        returns (GuardianStorage storage ds)\n    {\n        bytes32 storagePosition = keccak256(\n            \"v0.trustwallet.diamond.storage.GuardianStorage\"\n        );\n        assembly {\n            ds.slot := storagePosition\n        }\n    }\n\n    function recoveryStorage()\n        internal\n        pure\n        returns (RecoveryStorage storage ds)\n    {\n        bytes32 storagePosition = keccak256(\n            \"v0.trustwallet.diamond.storage.RecoveryStorage\"\n        );\n        assembly {\n            ds.slot := storagePosition\n        }\n    }\n\n    function restrictionsStorage()\n        internal\n        pure\n        returns (RestrictionsStorage storage ds)\n    {\n        bytes32 storagePosition = keccak256(\n            \"v0.trustwallet.diamond.storage.RestrictionsStorage\"\n        );\n        assembly {\n            ds.slot := storagePosition\n        }\n    }\n\n    function migrationStorage()\n        internal\n        pure\n        returns (SignatureMigrationStorage storage ds)\n    {\n        bytes32 storagePosition = keccak256(\n            \"v0.trustwallet.diamond.storage.SignatureMigrationStorage\"\n        );\n        assembly {\n            ds.slot := storagePosition\n        }\n    }\n\n    function diamondCutStorage()\n        internal\n        pure\n        returns (DiamondCutStorage storage ds)\n    {\n        bytes32 storagePosition = keccak256(\n            \"v0.trustwallet.diamond.storage.DiamondCutStorage\"\n        );\n        assembly {\n            ds.slot := storagePosition\n        }\n    }\n\n    function lockStorage() internal pure returns (LockStorage storage ds) {\n        bytes32 storagePosition = keccak256(\n            \"v0.trustwallet.diamond.storage.LockStorage\"\n        );\n        assembly {\n            ds.slot := storagePosition\n        }\n    }\n}\n"
    },
    "contracts/libraries/LibGuardian.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {LibFacetStorage, StorageConfig} from \"./LibFacetStorage.sol\";\n\n/**\n * @title LibGuardian\n * @dev Internal Library to provide utility feature for Guardians stored in Guardian Facet Storage\n * @author David Yongjun Kim (@Powerstream3604)\n */\nlibrary LibGuardian {\n    function majorityOfGuardians()\n        internal\n        view\n        returns (uint256 guardianNumber)\n    {\n        uint256 guardianLength = guardianCount();\n        guardianNumber = (guardianLength == 0) ? 0 : guardianLength / 2 + 1;\n    }\n\n    function isGuardian(address _guardian) internal view returns (bool) {\n        StorageConfig storage config = LibFacetStorage\n            .guardianStorage()\n            .configs[0];\n        return config.info[_guardian].exists;\n    }\n\n    function guardianCount() internal view returns (uint256) {\n        StorageConfig storage config = LibFacetStorage\n            .guardianStorage()\n            .configs[0];\n        return config.addresses.length;\n    }\n\n    function getGuardians() internal view returns (address[] memory) {\n        StorageConfig storage config = LibFacetStorage\n            .guardianStorage()\n            .configs[0];\n        address[] memory addresses = new address[](config.addresses.length);\n        uint256 addressesLen = config.addresses.length;\n        for (uint256 i; i < addressesLen; ) {\n            addresses[i] = config.addresses[i];\n            unchecked {\n                ++i;\n            }\n        }\n        return addresses;\n    }\n}\n"
    },
    "contracts/libraries/LibLoupe.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {IDiamondLoupe} from \"../facets/base/interfaces/IDiamondLoupe.sol\";\nimport {LibDiamond} from \"./LibDiamond.sol\";\n\n/**\n * @title LibLoupe\n * @dev Internal Library to provide utility feature for reading the state of diamond facets\n * @author David Yongjun Kim (@Powerstream3604)\n */\nlibrary LibLoupe {\n    /// @notice Gets all facets and their selectors.\n    /// @return facets_ Facet\n    function facets()\n        internal\n        view\n        returns (IDiamondLoupe.Facet[] memory facets_)\n    {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facets_ = new IDiamondLoupe.Facet[](ds.selectorCount);\n        uint16[] memory numFacetSelectors = new uint16[](ds.selectorCount);\n        uint256 numFacets;\n        uint256 selectorIndex;\n        // loop through function selectors\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\n            bytes32 slot = ds.selectorSlots[slotIndex];\n            for (\n                uint256 selectorSlotIndex;\n                selectorSlotIndex < 8;\n                selectorSlotIndex++\n            ) {\n                selectorIndex++;\n                if (selectorIndex > ds.selectorCount) {\n                    break;\n                }\n                // \" << 5 is the same as multiplying by 32 ( * 32)\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facetAddress_ = address(bytes20(ds.facets[selector]));\n                bool continueLoop;\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n                    if (facets_[facetIndex].facetAddress == facetAddress_) {\n                        facets_[facetIndex].functionSelectors[\n                            numFacetSelectors[facetIndex]\n                        ] = selector;\n                        // probably will never have more than 256 functions from one facet contract\n                        require(numFacetSelectors[facetIndex] < 255);\n                        numFacetSelectors[facetIndex]++;\n                        continueLoop = true;\n                        break;\n                    }\n                }\n                if (continueLoop) {\n                    continue;\n                }\n                facets_[numFacets].facetAddress = facetAddress_;\n                facets_[numFacets].functionSelectors = new bytes4[](\n                    ds.selectorCount\n                );\n                facets_[numFacets].functionSelectors[0] = selector;\n                numFacetSelectors[numFacets] = 1;\n                numFacets++;\n            }\n        }\n        for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n            uint256 numSelectors = numFacetSelectors[facetIndex];\n            bytes4[] memory selectors = facets_[facetIndex].functionSelectors;\n            // setting the number of selectors\n            assembly {\n                mstore(selectors, numSelectors)\n            }\n        }\n        // setting the number of facets\n        assembly {\n            mstore(facets_, numFacets)\n        }\n    }\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return _facetFunctionSelectors The selectors associated with a facet address.\n    function facetFunctionSelectors(\n        address _facet\n    ) internal view returns (bytes4[] memory _facetFunctionSelectors) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        uint256 numSelectors;\n        _facetFunctionSelectors = new bytes4[](ds.selectorCount);\n        uint256 selectorIndex;\n        // loop through function selectors\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\n            bytes32 slot = ds.selectorSlots[slotIndex];\n            for (\n                uint256 selectorSlotIndex;\n                selectorSlotIndex < 8;\n                selectorSlotIndex++\n            ) {\n                selectorIndex++;\n                if (selectorIndex > ds.selectorCount) {\n                    break;\n                }\n                // \" << 5 is the same as multiplying by 32 ( * 32)\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facet = address(bytes20(ds.facets[selector]));\n                if (_facet == facet) {\n                    _facetFunctionSelectors[numSelectors] = selector;\n                    numSelectors++;\n                }\n            }\n        }\n        // Set the number of selectors in the array\n        assembly {\n            mstore(_facetFunctionSelectors, numSelectors)\n        }\n    }\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses()\n        internal\n        view\n        returns (address[] memory facetAddresses_)\n    {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetAddresses_ = new address[](ds.selectorCount);\n        uint256 numFacets;\n        uint256 selectorIndex;\n        // loop through function selectors\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\n            bytes32 slot = ds.selectorSlots[slotIndex];\n            for (\n                uint256 selectorSlotIndex;\n                selectorSlotIndex < 8;\n                selectorSlotIndex++\n            ) {\n                selectorIndex++;\n                if (selectorIndex > ds.selectorCount) {\n                    break;\n                }\n                // \" << 5 is the same as multiplying by 32 ( * 32)\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facetAddress_ = address(bytes20(ds.facets[selector]));\n                bool continueLoop;\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n                    if (facetAddress_ == facetAddresses_[facetIndex]) {\n                        continueLoop = true;\n                        break;\n                    }\n                }\n                if (continueLoop) {\n                    continue;\n                }\n                facetAddresses_[numFacets] = facetAddress_;\n                numFacets++;\n            }\n        }\n        // Set the number of facet addresses in the array\n        assembly {\n            mstore(facetAddresses_, numFacets)\n        }\n    }\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(\n        bytes4 _functionSelector\n    ) internal view returns (address facetAddress_) {\n        facetAddress_ = address(\n            bytes20(LibDiamond.diamondStorage().facets[_functionSelector])\n        );\n    }\n}\n"
    },
    "contracts/libraries/LibMultiSigStorage.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\n/**\n * @title Multi-sig Storage\n * @dev Storage contract for storing Multi-sig Facet variables in diamond storage pattern\n * @author David Yongjun Kim (@Powerstream3604)\n */\n\nstruct MultiSigStorage {\n    mapping(address => address) owners;\n    mapping(uint256 => mapping(address => mapping(bytes32 => uint256))) approvedHashes;\n    uint256 ownerCount;\n    uint256 threshold;\n    uint256 counter;\n}\n\nlibrary LibMultiSigStorage {\n    function multisigStorage()\n        internal\n        pure\n        returns (MultiSigStorage storage ds)\n    {\n        bytes32 storagePosition = keccak256(\n            \"v0.trustwallet.diamond.storage.MultiSigStorage\"\n        );\n        assembly {\n            ds.slot := storagePosition\n        }\n    }\n}\n"
    },
    "contracts/libraries/LibRecoverSpender.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\n/**\n * @title RecoverSpender\n * @dev Library to determine the action and spender of calldata\n * @author Ruslan Serebriakov (@rsrbk)\n */\nlibrary LibRecoverSpender {\n    // ERC20, ERC721 & ERC1155 transfers & approvals\n    bytes4 private constant ERC20_TRANSFER =\n        bytes4(keccak256(\"transfer(address,uint256)\"));\n    bytes4 private constant ERC20_APPROVE =\n        bytes4(keccak256(\"approve(address,uint256)\"));\n    bytes4 private constant ERC20_INCREASE_ALLOWANCE =\n        bytes4(keccak256(\"increaseAllowance(address,uint256)\"));\n    bytes4 private constant ERC20_DECREASE_ALLOWANCE =\n        bytes4(keccak256(\"decreaseAllowance(address,uint256)\"));\n    bytes4 private constant ERC721_SET_APPROVAL_FOR_ALL =\n        bytes4(keccak256(\"setApprovalForAll(address,bool)\"));\n    bytes4 private constant ERC721_TRANSFER_FROM =\n        bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n    bytes4 private constant ERC721_SAFE_TRANSFER_FROM =\n        bytes4(keccak256(\"safeTransferFrom(address,address,uint256)\"));\n    bytes4 private constant ERC721_SAFE_TRANSFER_FROM_BYTES =\n        bytes4(keccak256(\"safeTransferFrom(address,address,uint256,bytes)\"));\n    bytes4 private constant ERC1155_SAFE_TRANSFER_FROM =\n        bytes4(\n            keccak256(\"safeTransferFrom(address,address,uint256,uint256,bytes)\")\n        );\n    bytes4 private constant ERC1155_SAFE_BATCH_TRANSFER_FROM =\n        bytes4(\n            keccak256(\n                \"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\"\n            )\n        );\n\n    /**\n     * @notice Helper method to recover the spender from a contract call.\n     * The method returns the contract unless the call is to a standard method of a ERC20/ERC721/ERC1155 token\n     * in which case the spender is recovered from the data.\n     * @param _to The target contract.\n     * @param _data The data payload.\n     */\n    function _recover(\n        address _to,\n        bytes memory _data\n    ) internal pure returns (address spender) {\n        if (_data.length >= 68) {\n            bytes4 methodId;\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                methodId := mload(add(_data, 0x20))\n            }\n            if (\n                methodId == ERC20_TRANSFER ||\n                methodId == ERC20_APPROVE ||\n                methodId == ERC20_INCREASE_ALLOWANCE ||\n                methodId == ERC20_DECREASE_ALLOWANCE ||\n                methodId == ERC721_SET_APPROVAL_FOR_ALL\n            ) {\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    spender := mload(add(_data, 0x24))\n                }\n                return spender;\n            }\n            if (\n                methodId == ERC721_TRANSFER_FROM ||\n                methodId == ERC721_SAFE_TRANSFER_FROM ||\n                methodId == ERC721_SAFE_TRANSFER_FROM_BYTES ||\n                methodId == ERC1155_SAFE_TRANSFER_FROM ||\n                methodId == ERC1155_SAFE_BATCH_TRANSFER_FROM\n            ) {\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    spender := mload(add(_data, 0x44))\n                }\n                return spender;\n            }\n        }\n\n        spender = _to;\n    }\n}\n"
    },
    "contracts/libraries/LibUtils.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {IDiamondLoupe} from \"../facets/base/interfaces/IDiamondLoupe.sol\";\n\nlibrary LibUtils {\n    // Internal utility functions\n    function mergeArrays(\n        bytes4[] memory _array1,\n        bytes4[] memory _array2\n    ) internal pure returns (bytes4[] memory) {\n        uint256 length1 = _array1.length;\n        uint256 length2 = _array2.length;\n        bytes4[] memory mergedArray = new bytes4[](length1 + length2);\n\n        for (uint256 i; i < length1; ) {\n            mergedArray[i] = _array1[i];\n            unchecked {\n                ++i;\n            }\n        }\n\n        for (uint256 i; i < length2; ) {\n            mergedArray[length1 + i] = _array2[i];\n            unchecked {\n                ++i;\n            }\n        }\n\n        return mergedArray;\n    }\n\n    function removeFacetElement(\n        IDiamondLoupe.Facet[] memory _facets,\n        uint256 _index\n    ) internal pure returns (IDiamondLoupe.Facet[] memory) {\n        require(_index < _facets.length, \"Invalid index\");\n        require(_facets.length != 0, \"Invalid array\");\n\n        // Create a new array with a length of `_facets.length - 1`\n        IDiamondLoupe.Facet[] memory newArray = new IDiamondLoupe.Facet[](\n            _facets.length - 1\n        );\n        uint256 newArrayLength = newArray.length;\n        // Iterate over the original array, skipping the element at the specified `index`\n        for (uint256 i; i < newArrayLength; ) {\n            if (i < _index) {\n                newArray[i] = _facets[i];\n            } else {\n                newArray[i] = _facets[i + 1];\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        return newArray;\n    }\n\n    function removeElement(\n        bytes4[] memory _array,\n        uint256 _index\n    ) internal pure returns (bytes4[] memory) {\n        require(_index < _array.length, \"Invalid index\");\n        require(_array.length != 0, \"Invalid array\");\n\n        bytes4[] memory newArray = new bytes4[](_array.length - 1);\n        uint256 newArrayLength = newArray.length;\n        for (uint256 i; i < newArrayLength; ) {\n            if (i < _index) {\n                newArray[i] = _array[i];\n            } else {\n                newArray[i] = _array[i + 1];\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        return newArray;\n    }\n\n    function setValue(\n        bytes4[] memory _keys,\n        address[] memory _values,\n        bytes4 _key,\n        address _value\n    ) internal pure returns (bytes4[] memory, address[] memory) {\n        uint256 index = findIndex(_keys, _key);\n        uint256 keysLength = _keys.length;\n        if (index < keysLength) {\n            _values[index] = _value;\n        } else {\n            // Create new storage arrays\n            bytes4[] memory newKeys = new bytes4[](keysLength + 1);\n            address[] memory newValues = new address[](_values.length + 1);\n\n            // Copy values to the new storage arrays\n            for (uint256 i; i < keysLength; ) {\n                newKeys[i] = _keys[i];\n                newValues[i] = _values[i];\n\n                unchecked {\n                    ++i;\n                }\n            }\n\n            // Add the new key-value pair\n            newKeys[keysLength] = _key;\n            newValues[_values.length] = _value;\n\n            return (newKeys, newValues);\n        }\n\n        // If the key already exists, return the original arrays\n        return (_keys, _values);\n    }\n\n    function getValue(\n        bytes4[] memory _keys,\n        address[] memory _values,\n        bytes4 _key\n    ) internal pure returns (address) {\n        uint256 index = findIndex(_keys, _key);\n        if (index >= _keys.length) return address(0);\n\n        return _values[index];\n    }\n\n    function findIndex(\n        bytes4[] memory _keys,\n        bytes4 _key\n    ) internal pure returns (uint256) {\n        uint256 keysLength = _keys.length;\n        for (uint256 i; i < keysLength; ) {\n            if (_keys[i] == _key) {\n                return i;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return keysLength;\n    }\n}\n"
    },
    "contracts/restrictions/IRestriction.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\n/**\n * @title Interface for restrictions\n * @dev Restriction is a contract which decides whether to approve a certain kind of transaction, based on its internal logic.\n * @author Ruslan Serebriakov (@rsrbk)\n */\ninterface IRestriction {\n    /**\n     * @dev Based on restriction's internal logic, it should accept or reject a certain transaction.\n     * @param from The address of the sender, that will be signing the transaction.\n     * @param to The receiving address.\n     * @param value Amount of ETH to transfer from sender to recipient.\n     * @param _calldata Optional field to include arbitrary data.\n     * @return bool value for whether the check is passed\n     */\n    function check(\n        address from,\n        address to,\n        uint256 value,\n        bytes calldata _calldata\n    ) external returns (bool);\n}\n"
    },
    "contracts/restrictions/WhitelistRestriction.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {LibRecoverSpender} from \"../libraries/LibRecoverSpender.sol\";\nimport {WhitelistStorage} from \"../infrastructure/WhitelistStorage.sol\";\nimport {IRestriction} from \"./IRestriction.sol\";\n\n/**\n * @title Whitelist Restriction\n * @dev This restriction defines a list of accepted addresses and denies any interaction with addresses outside of it.\n * @author Ruslan Serebriakov (@rsrbk)\n */\ncontract WhitelistRestriction is IRestriction {\n    WhitelistStorage public immutable whitelistStorage;\n\n    constructor(WhitelistStorage _whitelistStorage) {\n        whitelistStorage = _whitelistStorage;\n    }\n\n    /**\n     * @notice Helper method to recover the spender from a contract call.\n     * The method returns the contract unless the call is to a standard method of a ERC20/ERC721/ERC1155 token\n     * in which case the spender is recovered from the data.\n     * @param _to The target contract.\n     * @param _data The data payload.\n     */\n    function recoverSpender(\n        address _to,\n        bytes memory _data\n    ) public pure returns (address spender) {\n        return LibRecoverSpender._recover(_to, _data);\n    }\n\n    /*\n     * @dev IRestriction's implementation. It will allow transaction if the sender is whitelisted, or user, or the whitelist storage.\n     * @param _from The address of the sender, that will be signing the transaction.\n     * @param _to The receiving address.\n     * @param _calldata Optional field to include arbitrary data.\n     * @return result value for whether the check is passed\n     */\n    function check(\n        address _from,\n        address _to,\n        uint256 /*_value*/,\n        bytes calldata _calldata\n    ) external view override returns (bool result) {\n        return\n            whitelistStorage.isWhitelisted(\n                _from,\n                LibRecoverSpender._recover(_to, _calldata)\n            ) ||\n            _to == address(whitelistStorage) ||\n            _to == msg.sender;\n    }\n}\n"
    },
    "contracts/test/Counter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ncontract TestCounter {\n    int private count = 0;\n\n    function incrementCounter() public {\n        count += 1;\n    }\n\n    function decrementCounter() public {\n        count -= 1;\n    }\n\n    function getCount() public view returns (int) {\n        return count;\n    }\n}\n"
    },
    "contracts/test/TestERC1155.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\ncontract TestERC1155 is ERC1155 {\n    using Counters for Counters.Counter;\n\n    Counters.Counter private _tokenIds;\n\n    constructor() ERC1155(\"\") {}\n\n    function mint(address account, uint256 amount) external {\n        uint256 tokenId = _getNextTokenId();\n        _mint(account, tokenId, amount, \"\");\n    }\n\n    function mintBatch(\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes memory data\n    ) external {\n        require(\n            ids.length == amounts.length,\n            \"TestERC1155: arrays length mismatch\"\n        );\n\n        _mintBatch(to, ids, amounts, data);\n    }\n\n    function _getNextTokenId() private returns (uint256) {\n        _tokenIds.increment();\n        return _tokenIds.current();\n    }\n}\n"
    },
    "contracts/test/TestERC777.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC777/ERC777.sol\";\n\ncontract TestERC777 is ERC777 {\n    constructor(\n        address[] memory _operators\n    ) ERC777(\"TestERC777\", \"TERC777\", _operators) {}\n\n    function mint(address account, uint256 amount) external {\n        _mint(account, amount, \"\", \"\");\n    }\n}\n"
    },
    "contracts/test/TestInvalidSecp256k1VerificationFacet.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {IVerificationFacet} from \"../facets/interfaces/IVerificationFacet.sol\";\nimport {IERC1271} from \"../interfaces/ERC/IERC1271.sol\";\nimport {AppStorage, LibAppStorage, BarzStorage} from \"../libraries/LibAppStorage.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {LibFacetStorage, Secp256k1VerificationStorage} from \"../libraries/LibFacetStorage.sol\";\nimport {UserOperation} from \"../aa-4337/interfaces/UserOperation.sol\";\n\n/**\n * @title Test Secp256k1 verification facet\n * @dev Default Ethereum's elliptic curve\n * @author David Yongjun Kim (@Powerstream3604)\n * @author Ruslan Serebriakov (@rsrbk)\n */\ncontract TestInvalidSecp256k1VerificationFacet is BarzStorage, IERC1271 {\n    using ECDSA for bytes32;\n    error Secp256k1VerificationFacet__InvalidSignerLength();\n    error VerificationFacet__ValidateOwnerSignatureSelectorNotSet();\n\n    event SignerUninitialized();\n\n    constructor() {\n        LibAppStorage.enforceSignerInitialize();\n    }\n\n    // THIS INVALID FACET DOES NOT INCLUDE initializeSigner()\n    // THIS FACET IS USED TO TEST WHEN initializeSigner() DOESN'T EXIST IN FACET\n\n    function uninitializeSigner() external returns (uint256 uninitSuccess) {\n        LibAppStorage.enforceSignerMigration();\n        LibAppStorage.setSignerUninitialized();\n        Secp256k1VerificationStorage storage k1Storage = LibFacetStorage\n            .k1Storage();\n        k1Storage.signer = address(0);\n\n        if (LibAppStorage.getValidateOwnerSignatureSelector() == bytes4(0))\n            revert VerificationFacet__ValidateOwnerSignatureSelectorNotSet();\n        LibAppStorage.setValidateOwnerSignatureSelector(bytes4(0));\n\n        uninitSuccess = 1;\n\n        emit SignerUninitialized();\n    }\n\n    function validateOwnerSignature(\n        UserOperation calldata userOp,\n        bytes32 userOpHash\n    ) public view returns (uint256 validationData) {\n        Secp256k1VerificationStorage storage k1Storage = LibFacetStorage\n            .k1Storage();\n        return validateSignature(userOp, userOpHash, k1Storage.signer);\n    }\n\n    function validateSignature(\n        UserOperation calldata userOp,\n        bytes32 userOpHash,\n        address signer\n    ) public pure returns (uint256) {\n        bytes32 hash = userOpHash.toEthSignedMessageHash();\n        if (signer != hash.recover(userOp.signature)) return 1;\n        return 0;\n    }\n\n    // This is REMOVED for testing purpose\n    function validateOwnerSignatureSelector() public pure returns (bytes4) {\n        // return this.validateOwnerSignature.selector;\n        // The signature name could change according to the facet but the param format(UserOp, UserOpHash) should not change\n    }\n\n    function owner() public view returns (bytes memory) {\n        Secp256k1VerificationStorage storage k1Storage = LibFacetStorage\n            .k1Storage();\n        return abi.encodePacked(k1Storage.signer);\n    }\n\n    function isValidKeyType(\n        bytes memory _publicKey\n    ) public pure returns (bool) {\n        return (_publicKey.length == 65 && _publicKey[0] == 0x04);\n    }\n\n    function isValidSignature(\n        bytes32 _hash,\n        bytes memory _signature\n    ) public view override returns (bytes4 magicValue) {\n        magicValue = (_hash.recover(_signature) ==\n            LibFacetStorage.k1Storage().signer)\n            ? this.isValidSignature.selector\n            : bytes4(0xffffffff);\n    }\n}\n"
    },
    "contracts/test/TestNFT.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\ncontract TestNFT is ERC721 {\n    using Counters for Counters.Counter;\n    Counters.Counter private currentTokenId;\n\n    constructor() ERC721(\"TestNFT\", \"TNFT\") {}\n\n    function mint(address recipient) public returns (uint256) {\n        currentTokenId.increment();\n        uint256 newItemId = currentTokenId.current();\n        _safeMint(recipient, newItemId);\n        return newItemId;\n    }\n}\n"
    },
    "contracts/test/TestToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.21;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract TestToken is ERC20 {\n    constructor()\n        // solhint-disable-next-line no-empty-blocks\n        ERC20(\"TST\", \"TestToken\")\n    {}\n\n    function mint(address sender, uint256 amount) external {\n        _mint(sender, amount);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}